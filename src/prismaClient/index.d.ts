
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model RecurringData
 * 
 */
export type RecurringData = $Result.DefaultSelection<Prisma.$RecurringDataPayload>
/**
 * Model LevelRequirement
 * 
 */
export type LevelRequirement = $Result.DefaultSelection<Prisma.$LevelRequirementPayload>
/**
 * Model Badge
 * 
 */
export type Badge = $Result.DefaultSelection<Prisma.$BadgePayload>
/**
 * Model PhotoStats
 * 
 */
export type PhotoStats = $Result.DefaultSelection<Prisma.$PhotoStatsPayload>
/**
 * Model Contest
 * 
 */
export type Contest = $Result.DefaultSelection<Prisma.$ContestPayload>
/**
 * Model RecurringContest
 * 
 */
export type RecurringContest = $Result.DefaultSelection<Prisma.$RecurringContestPayload>
/**
 * Model ContestRule
 * 
 */
export type ContestRule = $Result.DefaultSelection<Prisma.$ContestRulePayload>
/**
 * Model ContestPhoto
 * 
 */
export type ContestPhoto = $Result.DefaultSelection<Prisma.$ContestPhotoPayload>
/**
 * Model ContestWinner
 * 
 */
export type ContestWinner = $Result.DefaultSelection<Prisma.$ContestWinnerPayload>
/**
 * Model ContestParticipant
 * 
 */
export type ContestParticipant = $Result.DefaultSelection<Prisma.$ContestParticipantPayload>
/**
 * Model ContestPrize
 * 
 */
export type ContestPrize = $Result.DefaultSelection<Prisma.$ContestPrizePayload>
/**
 * Model ContestAchievement
 * 
 */
export type ContestAchievement = $Result.DefaultSelection<Prisma.$ContestAchievementPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model SitePolicy
 * 
 */
export type SitePolicy = $Result.DefaultSelection<Prisma.$SitePolicyPayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model Chat
 * 
 */
export type Chat = $Result.DefaultSelection<Prisma.$ChatPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Price
 * 
 */
export type Price = $Result.DefaultSelection<Prisma.$PricePayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model TeamMember
 * 
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>
/**
 * Model TeamParticipation
 * 
 */
export type TeamParticipation = $Result.DefaultSelection<Prisma.$TeamParticipationPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserStore
 * 
 */
export type UserStore = $Result.DefaultSelection<Prisma.$UserStorePayload>
/**
 * Model UserPhoto
 * 
 */
export type UserPhoto = $Result.DefaultSelection<Prisma.$UserPhotoPayload>
/**
 * Model Like
 * 
 */
export type Like = $Result.DefaultSelection<Prisma.$LikePayload>
/**
 * Model Otp
 * 
 */
export type Otp = $Result.DefaultSelection<Prisma.$OtpPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Follow
 * 
 */
export type Follow = $Result.DefaultSelection<Prisma.$FollowPayload>
/**
 * Model Vote
 * 
 */
export type Vote = $Result.DefaultSelection<Prisma.$VotePayload>
/**
 * Model UserLevel
 * 
 */
export type UserLevel = $Result.DefaultSelection<Prisma.$UserLevelPayload>
/**
 * Model Level
 * 
 */
export type Level = $Result.DefaultSelection<Prisma.$LevelPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PrizeType: {
  TOP_PHOTO: 'TOP_PHOTO',
  TOP_PHOTOGRAPHER: 'TOP_PHOTOGRAPHER',
  TOP_YC_PICK: 'TOP_YC_PICK'
};

export type PrizeType = (typeof PrizeType)[keyof typeof PrizeType]


export const ContestMode: {
  SOLO: 'SOLO',
  TEAM: 'TEAM'
};

export type ContestMode = (typeof ContestMode)[keyof typeof ContestMode]


export const ContestStatus: {
  NEW: 'NEW',
  UPCOMING: 'UPCOMING',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  CLOSED: 'CLOSED'
};

export type ContestStatus = (typeof ContestStatus)[keyof typeof ContestStatus]


export const ContestType: {
  ONETIME: 'ONETIME',
  RECURRING: 'RECURRING'
};

export type ContestType = (typeof ContestType)[keyof typeof ContestType]


export const RecurringType: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY'
};

export type RecurringType = (typeof RecurringType)[keyof typeof RecurringType]


export const ContestLevel: {
  POPULAR: 'POPULAR',
  SKILLED: 'SKILLED',
  PREMIER: 'PREMIER',
  ELITE: 'ELITE',
  ALL_STAR: 'ALL_STAR'
};

export type ContestLevel = (typeof ContestLevel)[keyof typeof ContestLevel]


export const YCLevel: {
  AMATEUR: 'AMATEUR',
  TALANTED: 'TALANTED',
  SUPREME: 'SUPREME',
  SUPERIOR: 'SUPERIOR',
  TOP_NOTCH: 'TOP_NOTCH'
};

export type YCLevel = (typeof YCLevel)[keyof typeof YCLevel]


export const ContestParticipantStatus: {
  ACTIVE: 'ACTIVE',
  BLOCKED: 'BLOCKED'
};

export type ContestParticipantStatus = (typeof ContestParticipantStatus)[keyof typeof ContestParticipantStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  SUCCEEDED: 'SUCCEEDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const SitePolicyType: {
  TERMS: 'TERMS',
  POLICY: 'POLICY',
  ABOUT: 'ABOUT'
};

export type SitePolicyType = (typeof SitePolicyType)[keyof typeof SitePolicyType]


export const ProductType: {
  KEY: 'KEY',
  PROMOTE: 'PROMOTE',
  CHARGE: 'CHARGE'
};

export type ProductType = (typeof ProductType)[keyof typeof ProductType]


export const TeamAccessibility: {
  PUBLIC: 'PUBLIC',
  PRIVATE: 'PRIVATE'
};

export type TeamAccessibility = (typeof TeamAccessibility)[keyof typeof TeamAccessibility]


export const TeamMemberStatus: {
  ACTIVE: 'ACTIVE',
  REMOVED: 'REMOVED',
  BLOCKED: 'BLOCKED'
};

export type TeamMemberStatus = (typeof TeamMemberStatus)[keyof typeof TeamMemberStatus]


export const MemberLevel: {
  NEW: 'NEW',
  EXPERT: 'EXPERT',
  MASTER: 'MASTER',
  LEADER: 'LEADER'
};

export type MemberLevel = (typeof MemberLevel)[keyof typeof MemberLevel]


export const LevelName: {
  APPRENTICE: 'APPRENTICE',
  STUDENT: 'STUDENT',
  TRAINED: 'TRAINED',
  TALENTED: 'TALENTED',
  CONTENDER: 'CONTENDER',
  VIRTUOSO: 'VIRTUOSO',
  LEADER: 'LEADER',
  AVANTGARDE: 'AVANTGARDE',
  PRO: 'PRO'
};

export type LevelName = (typeof LevelName)[keyof typeof LevelName]


export const VoteType: {
  Promoted: 'Promoted',
  Organic: 'Organic'
};

export type VoteType = (typeof VoteType)[keyof typeof VoteType]


export const UserRole: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const OtpStatus: {
  CREATED: 'CREATED',
  VALIDATED: 'VALIDATED'
};

export type OtpStatus = (typeof OtpStatus)[keyof typeof OtpStatus]

}

export type PrizeType = $Enums.PrizeType

export const PrizeType: typeof $Enums.PrizeType

export type ContestMode = $Enums.ContestMode

export const ContestMode: typeof $Enums.ContestMode

export type ContestStatus = $Enums.ContestStatus

export const ContestStatus: typeof $Enums.ContestStatus

export type ContestType = $Enums.ContestType

export const ContestType: typeof $Enums.ContestType

export type RecurringType = $Enums.RecurringType

export const RecurringType: typeof $Enums.RecurringType

export type ContestLevel = $Enums.ContestLevel

export const ContestLevel: typeof $Enums.ContestLevel

export type YCLevel = $Enums.YCLevel

export const YCLevel: typeof $Enums.YCLevel

export type ContestParticipantStatus = $Enums.ContestParticipantStatus

export const ContestParticipantStatus: typeof $Enums.ContestParticipantStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type SitePolicyType = $Enums.SitePolicyType

export const SitePolicyType: typeof $Enums.SitePolicyType

export type ProductType = $Enums.ProductType

export const ProductType: typeof $Enums.ProductType

export type TeamAccessibility = $Enums.TeamAccessibility

export const TeamAccessibility: typeof $Enums.TeamAccessibility

export type TeamMemberStatus = $Enums.TeamMemberStatus

export const TeamMemberStatus: typeof $Enums.TeamMemberStatus

export type MemberLevel = $Enums.MemberLevel

export const MemberLevel: typeof $Enums.MemberLevel

export type LevelName = $Enums.LevelName

export const LevelName: typeof $Enums.LevelName

export type VoteType = $Enums.VoteType

export const VoteType: typeof $Enums.VoteType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type OtpStatus = $Enums.OtpStatus

export const OtpStatus: typeof $Enums.OtpStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Contests
 * const contests = await prisma.contest.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Contests
   * const contests = await prisma.contest.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.contest`: Exposes CRUD operations for the **Contest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contests
    * const contests = await prisma.contest.findMany()
    * ```
    */
  get contest(): Prisma.ContestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recurringContest`: Exposes CRUD operations for the **RecurringContest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecurringContests
    * const recurringContests = await prisma.recurringContest.findMany()
    * ```
    */
  get recurringContest(): Prisma.RecurringContestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contestRule`: Exposes CRUD operations for the **ContestRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContestRules
    * const contestRules = await prisma.contestRule.findMany()
    * ```
    */
  get contestRule(): Prisma.ContestRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contestPhoto`: Exposes CRUD operations for the **ContestPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContestPhotos
    * const contestPhotos = await prisma.contestPhoto.findMany()
    * ```
    */
  get contestPhoto(): Prisma.ContestPhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contestWinner`: Exposes CRUD operations for the **ContestWinner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContestWinners
    * const contestWinners = await prisma.contestWinner.findMany()
    * ```
    */
  get contestWinner(): Prisma.ContestWinnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contestParticipant`: Exposes CRUD operations for the **ContestParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContestParticipants
    * const contestParticipants = await prisma.contestParticipant.findMany()
    * ```
    */
  get contestParticipant(): Prisma.ContestParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contestPrize`: Exposes CRUD operations for the **ContestPrize** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContestPrizes
    * const contestPrizes = await prisma.contestPrize.findMany()
    * ```
    */
  get contestPrize(): Prisma.ContestPrizeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contestAchievement`: Exposes CRUD operations for the **ContestAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContestAchievements
    * const contestAchievements = await prisma.contestAchievement.findMany()
    * ```
    */
  get contestAchievement(): Prisma.ContestAchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sitePolicy`: Exposes CRUD operations for the **SitePolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SitePolicies
    * const sitePolicies = await prisma.sitePolicy.findMany()
    * ```
    */
  get sitePolicy(): Prisma.SitePolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.price`: Exposes CRUD operations for the **Price** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prices
    * const prices = await prisma.price.findMany()
    * ```
    */
  get price(): Prisma.PriceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamParticipation`: Exposes CRUD operations for the **TeamParticipation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamParticipations
    * const teamParticipations = await prisma.teamParticipation.findMany()
    * ```
    */
  get teamParticipation(): Prisma.TeamParticipationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userStore`: Exposes CRUD operations for the **UserStore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserStores
    * const userStores = await prisma.userStore.findMany()
    * ```
    */
  get userStore(): Prisma.UserStoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPhoto`: Exposes CRUD operations for the **UserPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPhotos
    * const userPhotos = await prisma.userPhoto.findMany()
    * ```
    */
  get userPhoto(): Prisma.UserPhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.like`: Exposes CRUD operations for the **Like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Likes
    * const likes = await prisma.like.findMany()
    * ```
    */
  get like(): Prisma.LikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.otp`: Exposes CRUD operations for the **Otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otp.findMany()
    * ```
    */
  get otp(): Prisma.OtpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.follow`: Exposes CRUD operations for the **Follow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Follows
    * const follows = await prisma.follow.findMany()
    * ```
    */
  get follow(): Prisma.FollowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vote`: Exposes CRUD operations for the **Vote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Votes
    * const votes = await prisma.vote.findMany()
    * ```
    */
  get vote(): Prisma.VoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLevel`: Exposes CRUD operations for the **UserLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLevels
    * const userLevels = await prisma.userLevel.findMany()
    * ```
    */
  get userLevel(): Prisma.UserLevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.level`: Exposes CRUD operations for the **Level** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Levels
    * const levels = await prisma.level.findMany()
    * ```
    */
  get level(): Prisma.LevelDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Contest: 'Contest',
    RecurringContest: 'RecurringContest',
    ContestRule: 'ContestRule',
    ContestPhoto: 'ContestPhoto',
    ContestWinner: 'ContestWinner',
    ContestParticipant: 'ContestParticipant',
    ContestPrize: 'ContestPrize',
    ContestAchievement: 'ContestAchievement',
    Notification: 'Notification',
    Payment: 'Payment',
    SitePolicy: 'SitePolicy',
    Room: 'Room',
    Chat: 'Chat',
    Product: 'Product',
    Price: 'Price',
    Team: 'Team',
    TeamMember: 'TeamMember',
    TeamParticipation: 'TeamParticipation',
    User: 'User',
    UserStore: 'UserStore',
    UserPhoto: 'UserPhoto',
    Like: 'Like',
    Otp: 'Otp',
    Comment: 'Comment',
    Follow: 'Follow',
    Vote: 'Vote',
    UserLevel: 'UserLevel',
    Level: 'Level'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "contest" | "recurringContest" | "contestRule" | "contestPhoto" | "contestWinner" | "contestParticipant" | "contestPrize" | "contestAchievement" | "notification" | "payment" | "sitePolicy" | "room" | "chat" | "product" | "price" | "team" | "teamMember" | "teamParticipation" | "user" | "userStore" | "userPhoto" | "like" | "otp" | "comment" | "follow" | "vote" | "userLevel" | "level"
      txIsolationLevel: never
    }
    model: {
      Contest: {
        payload: Prisma.$ContestPayload<ExtArgs>
        fields: Prisma.ContestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>
          }
          findFirst: {
            args: Prisma.ContestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>
          }
          findMany: {
            args: Prisma.ContestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>[]
          }
          create: {
            args: Prisma.ContestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>
          }
          createMany: {
            args: Prisma.ContestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>
          }
          update: {
            args: Prisma.ContestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>
          }
          deleteMany: {
            args: Prisma.ContestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>
          }
          aggregate: {
            args: Prisma.ContestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContest>
          }
          groupBy: {
            args: Prisma.ContestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContestGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ContestFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ContestAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ContestCountArgs<ExtArgs>
            result: $Utils.Optional<ContestCountAggregateOutputType> | number
          }
        }
      }
      RecurringContest: {
        payload: Prisma.$RecurringContestPayload<ExtArgs>
        fields: Prisma.RecurringContestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecurringContestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecurringContestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestPayload>
          }
          findFirst: {
            args: Prisma.RecurringContestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecurringContestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestPayload>
          }
          findMany: {
            args: Prisma.RecurringContestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestPayload>[]
          }
          create: {
            args: Prisma.RecurringContestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestPayload>
          }
          createMany: {
            args: Prisma.RecurringContestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RecurringContestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestPayload>
          }
          update: {
            args: Prisma.RecurringContestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestPayload>
          }
          deleteMany: {
            args: Prisma.RecurringContestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecurringContestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecurringContestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestPayload>
          }
          aggregate: {
            args: Prisma.RecurringContestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurringContest>
          }
          groupBy: {
            args: Prisma.RecurringContestGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecurringContestGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.RecurringContestFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.RecurringContestAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.RecurringContestCountArgs<ExtArgs>
            result: $Utils.Optional<RecurringContestCountAggregateOutputType> | number
          }
        }
      }
      ContestRule: {
        payload: Prisma.$ContestRulePayload<ExtArgs>
        fields: Prisma.ContestRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContestRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContestRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestRulePayload>
          }
          findFirst: {
            args: Prisma.ContestRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContestRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestRulePayload>
          }
          findMany: {
            args: Prisma.ContestRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestRulePayload>[]
          }
          create: {
            args: Prisma.ContestRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestRulePayload>
          }
          createMany: {
            args: Prisma.ContestRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContestRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestRulePayload>
          }
          update: {
            args: Prisma.ContestRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestRulePayload>
          }
          deleteMany: {
            args: Prisma.ContestRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContestRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContestRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestRulePayload>
          }
          aggregate: {
            args: Prisma.ContestRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContestRule>
          }
          groupBy: {
            args: Prisma.ContestRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContestRuleGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ContestRuleFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ContestRuleAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ContestRuleCountArgs<ExtArgs>
            result: $Utils.Optional<ContestRuleCountAggregateOutputType> | number
          }
        }
      }
      ContestPhoto: {
        payload: Prisma.$ContestPhotoPayload<ExtArgs>
        fields: Prisma.ContestPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContestPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContestPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPhotoPayload>
          }
          findFirst: {
            args: Prisma.ContestPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContestPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPhotoPayload>
          }
          findMany: {
            args: Prisma.ContestPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPhotoPayload>[]
          }
          create: {
            args: Prisma.ContestPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPhotoPayload>
          }
          createMany: {
            args: Prisma.ContestPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContestPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPhotoPayload>
          }
          update: {
            args: Prisma.ContestPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPhotoPayload>
          }
          deleteMany: {
            args: Prisma.ContestPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContestPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContestPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPhotoPayload>
          }
          aggregate: {
            args: Prisma.ContestPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContestPhoto>
          }
          groupBy: {
            args: Prisma.ContestPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContestPhotoGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ContestPhotoFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ContestPhotoAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ContestPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<ContestPhotoCountAggregateOutputType> | number
          }
        }
      }
      ContestWinner: {
        payload: Prisma.$ContestWinnerPayload<ExtArgs>
        fields: Prisma.ContestWinnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContestWinnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestWinnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContestWinnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestWinnerPayload>
          }
          findFirst: {
            args: Prisma.ContestWinnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestWinnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContestWinnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestWinnerPayload>
          }
          findMany: {
            args: Prisma.ContestWinnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestWinnerPayload>[]
          }
          create: {
            args: Prisma.ContestWinnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestWinnerPayload>
          }
          createMany: {
            args: Prisma.ContestWinnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContestWinnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestWinnerPayload>
          }
          update: {
            args: Prisma.ContestWinnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestWinnerPayload>
          }
          deleteMany: {
            args: Prisma.ContestWinnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContestWinnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContestWinnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestWinnerPayload>
          }
          aggregate: {
            args: Prisma.ContestWinnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContestWinner>
          }
          groupBy: {
            args: Prisma.ContestWinnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContestWinnerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ContestWinnerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ContestWinnerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ContestWinnerCountArgs<ExtArgs>
            result: $Utils.Optional<ContestWinnerCountAggregateOutputType> | number
          }
        }
      }
      ContestParticipant: {
        payload: Prisma.$ContestParticipantPayload<ExtArgs>
        fields: Prisma.ContestParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContestParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContestParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestParticipantPayload>
          }
          findFirst: {
            args: Prisma.ContestParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContestParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestParticipantPayload>
          }
          findMany: {
            args: Prisma.ContestParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestParticipantPayload>[]
          }
          create: {
            args: Prisma.ContestParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestParticipantPayload>
          }
          createMany: {
            args: Prisma.ContestParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContestParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestParticipantPayload>
          }
          update: {
            args: Prisma.ContestParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ContestParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContestParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContestParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestParticipantPayload>
          }
          aggregate: {
            args: Prisma.ContestParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContestParticipant>
          }
          groupBy: {
            args: Prisma.ContestParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContestParticipantGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ContestParticipantFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ContestParticipantAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ContestParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ContestParticipantCountAggregateOutputType> | number
          }
        }
      }
      ContestPrize: {
        payload: Prisma.$ContestPrizePayload<ExtArgs>
        fields: Prisma.ContestPrizeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContestPrizeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPrizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContestPrizeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPrizePayload>
          }
          findFirst: {
            args: Prisma.ContestPrizeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPrizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContestPrizeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPrizePayload>
          }
          findMany: {
            args: Prisma.ContestPrizeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPrizePayload>[]
          }
          create: {
            args: Prisma.ContestPrizeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPrizePayload>
          }
          createMany: {
            args: Prisma.ContestPrizeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContestPrizeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPrizePayload>
          }
          update: {
            args: Prisma.ContestPrizeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPrizePayload>
          }
          deleteMany: {
            args: Prisma.ContestPrizeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContestPrizeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContestPrizeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPrizePayload>
          }
          aggregate: {
            args: Prisma.ContestPrizeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContestPrize>
          }
          groupBy: {
            args: Prisma.ContestPrizeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContestPrizeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ContestPrizeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ContestPrizeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ContestPrizeCountArgs<ExtArgs>
            result: $Utils.Optional<ContestPrizeCountAggregateOutputType> | number
          }
        }
      }
      ContestAchievement: {
        payload: Prisma.$ContestAchievementPayload<ExtArgs>
        fields: Prisma.ContestAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContestAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContestAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAchievementPayload>
          }
          findFirst: {
            args: Prisma.ContestAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContestAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAchievementPayload>
          }
          findMany: {
            args: Prisma.ContestAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAchievementPayload>[]
          }
          create: {
            args: Prisma.ContestAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAchievementPayload>
          }
          createMany: {
            args: Prisma.ContestAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContestAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAchievementPayload>
          }
          update: {
            args: Prisma.ContestAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAchievementPayload>
          }
          deleteMany: {
            args: Prisma.ContestAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContestAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContestAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAchievementPayload>
          }
          aggregate: {
            args: Prisma.ContestAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContestAchievement>
          }
          groupBy: {
            args: Prisma.ContestAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContestAchievementGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ContestAchievementFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ContestAchievementAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ContestAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<ContestAchievementCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.NotificationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.NotificationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PaymentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PaymentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      SitePolicy: {
        payload: Prisma.$SitePolicyPayload<ExtArgs>
        fields: Prisma.SitePolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SitePolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SitePolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePolicyPayload>
          }
          findFirst: {
            args: Prisma.SitePolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SitePolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePolicyPayload>
          }
          findMany: {
            args: Prisma.SitePolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePolicyPayload>[]
          }
          create: {
            args: Prisma.SitePolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePolicyPayload>
          }
          createMany: {
            args: Prisma.SitePolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SitePolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePolicyPayload>
          }
          update: {
            args: Prisma.SitePolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePolicyPayload>
          }
          deleteMany: {
            args: Prisma.SitePolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SitePolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SitePolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitePolicyPayload>
          }
          aggregate: {
            args: Prisma.SitePolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSitePolicy>
          }
          groupBy: {
            args: Prisma.SitePolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SitePolicyGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SitePolicyFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SitePolicyAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SitePolicyCountArgs<ExtArgs>
            result: $Utils.Optional<SitePolicyCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.RoomFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.RoomAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      Chat: {
        payload: Prisma.$ChatPayload<ExtArgs>
        fields: Prisma.ChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findFirst: {
            args: Prisma.ChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findMany: {
            args: Prisma.ChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          create: {
            args: Prisma.ChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          createMany: {
            args: Prisma.ChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          update: {
            args: Prisma.ChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          deleteMany: {
            args: Prisma.ChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.ChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ChatFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ChatAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ChatCountArgs<ExtArgs>
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ProductFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ProductAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Price: {
        payload: Prisma.$PricePayload<ExtArgs>
        fields: Prisma.PriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>
          }
          findFirst: {
            args: Prisma.PriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>
          }
          findMany: {
            args: Prisma.PriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>[]
          }
          create: {
            args: Prisma.PriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>
          }
          createMany: {
            args: Prisma.PriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>
          }
          update: {
            args: Prisma.PriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>
          }
          deleteMany: {
            args: Prisma.PriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>
          }
          aggregate: {
            args: Prisma.PriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrice>
          }
          groupBy: {
            args: Prisma.PriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PriceFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PriceAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PriceCountArgs<ExtArgs>
            result: $Utils.Optional<PriceCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TeamFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TeamAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>
        fields: Prisma.TeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TeamMemberFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TeamMemberAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      TeamParticipation: {
        payload: Prisma.$TeamParticipationPayload<ExtArgs>
        fields: Prisma.TeamParticipationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamParticipationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamParticipationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamParticipationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamParticipationPayload>
          }
          findFirst: {
            args: Prisma.TeamParticipationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamParticipationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamParticipationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamParticipationPayload>
          }
          findMany: {
            args: Prisma.TeamParticipationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamParticipationPayload>[]
          }
          create: {
            args: Prisma.TeamParticipationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamParticipationPayload>
          }
          createMany: {
            args: Prisma.TeamParticipationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeamParticipationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamParticipationPayload>
          }
          update: {
            args: Prisma.TeamParticipationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamParticipationPayload>
          }
          deleteMany: {
            args: Prisma.TeamParticipationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamParticipationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamParticipationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamParticipationPayload>
          }
          aggregate: {
            args: Prisma.TeamParticipationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamParticipation>
          }
          groupBy: {
            args: Prisma.TeamParticipationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamParticipationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TeamParticipationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TeamParticipationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TeamParticipationCountArgs<ExtArgs>
            result: $Utils.Optional<TeamParticipationCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserStore: {
        payload: Prisma.$UserStorePayload<ExtArgs>
        fields: Prisma.UserStoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserStoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserStoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStorePayload>
          }
          findFirst: {
            args: Prisma.UserStoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserStoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStorePayload>
          }
          findMany: {
            args: Prisma.UserStoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStorePayload>[]
          }
          create: {
            args: Prisma.UserStoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStorePayload>
          }
          createMany: {
            args: Prisma.UserStoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserStoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStorePayload>
          }
          update: {
            args: Prisma.UserStoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStorePayload>
          }
          deleteMany: {
            args: Prisma.UserStoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserStoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserStoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStorePayload>
          }
          aggregate: {
            args: Prisma.UserStoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserStore>
          }
          groupBy: {
            args: Prisma.UserStoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserStoreGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserStoreFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserStoreAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserStoreCountArgs<ExtArgs>
            result: $Utils.Optional<UserStoreCountAggregateOutputType> | number
          }
        }
      }
      UserPhoto: {
        payload: Prisma.$UserPhotoPayload<ExtArgs>
        fields: Prisma.UserPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          findFirst: {
            args: Prisma.UserPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          findMany: {
            args: Prisma.UserPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>[]
          }
          create: {
            args: Prisma.UserPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          createMany: {
            args: Prisma.UserPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          update: {
            args: Prisma.UserPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          deleteMany: {
            args: Prisma.UserPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          aggregate: {
            args: Prisma.UserPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPhoto>
          }
          groupBy: {
            args: Prisma.UserPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPhotoGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserPhotoFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserPhotoAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<UserPhotoCountAggregateOutputType> | number
          }
        }
      }
      Like: {
        payload: Prisma.$LikePayload<ExtArgs>
        fields: Prisma.LikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findFirst: {
            args: Prisma.LikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findMany: {
            args: Prisma.LikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          create: {
            args: Prisma.LikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          createMany: {
            args: Prisma.LikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          update: {
            args: Prisma.LikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          deleteMany: {
            args: Prisma.LikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          aggregate: {
            args: Prisma.LikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLike>
          }
          groupBy: {
            args: Prisma.LikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LikeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LikeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LikeCountArgs<ExtArgs>
            result: $Utils.Optional<LikeCountAggregateOutputType> | number
          }
        }
      }
      Otp: {
        payload: Prisma.$OtpPayload<ExtArgs>
        fields: Prisma.OtpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findFirst: {
            args: Prisma.OtpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findMany: {
            args: Prisma.OtpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          create: {
            args: Prisma.OtpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          createMany: {
            args: Prisma.OtpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OtpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          update: {
            args: Prisma.OtpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          deleteMany: {
            args: Prisma.OtpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OtpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          aggregate: {
            args: Prisma.OtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtp>
          }
          groupBy: {
            args: Prisma.OtpGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.OtpFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.OtpAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.OtpCountArgs<ExtArgs>
            result: $Utils.Optional<OtpCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CommentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CommentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Follow: {
        payload: Prisma.$FollowPayload<ExtArgs>
        fields: Prisma.FollowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findFirst: {
            args: Prisma.FollowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findMany: {
            args: Prisma.FollowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          create: {
            args: Prisma.FollowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          createMany: {
            args: Prisma.FollowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FollowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          update: {
            args: Prisma.FollowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          deleteMany: {
            args: Prisma.FollowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FollowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          aggregate: {
            args: Prisma.FollowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollow>
          }
          groupBy: {
            args: Prisma.FollowGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FollowFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FollowAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FollowCountArgs<ExtArgs>
            result: $Utils.Optional<FollowCountAggregateOutputType> | number
          }
        }
      }
      Vote: {
        payload: Prisma.$VotePayload<ExtArgs>
        fields: Prisma.VoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          findFirst: {
            args: Prisma.VoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          findMany: {
            args: Prisma.VoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          create: {
            args: Prisma.VoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          createMany: {
            args: Prisma.VoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          update: {
            args: Prisma.VoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          deleteMany: {
            args: Prisma.VoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          aggregate: {
            args: Prisma.VoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVote>
          }
          groupBy: {
            args: Prisma.VoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoteGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.VoteFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.VoteAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.VoteCountArgs<ExtArgs>
            result: $Utils.Optional<VoteCountAggregateOutputType> | number
          }
        }
      }
      UserLevel: {
        payload: Prisma.$UserLevelPayload<ExtArgs>
        fields: Prisma.UserLevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLevelPayload>
          }
          findFirst: {
            args: Prisma.UserLevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLevelPayload>
          }
          findMany: {
            args: Prisma.UserLevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLevelPayload>[]
          }
          create: {
            args: Prisma.UserLevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLevelPayload>
          }
          createMany: {
            args: Prisma.UserLevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserLevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLevelPayload>
          }
          update: {
            args: Prisma.UserLevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLevelPayload>
          }
          deleteMany: {
            args: Prisma.UserLevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserLevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLevelPayload>
          }
          aggregate: {
            args: Prisma.UserLevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLevel>
          }
          groupBy: {
            args: Prisma.UserLevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLevelGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserLevelFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserLevelAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserLevelCountArgs<ExtArgs>
            result: $Utils.Optional<UserLevelCountAggregateOutputType> | number
          }
        }
      }
      Level: {
        payload: Prisma.$LevelPayload<ExtArgs>
        fields: Prisma.LevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          findFirst: {
            args: Prisma.LevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          findMany: {
            args: Prisma.LevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[]
          }
          create: {
            args: Prisma.LevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          createMany: {
            args: Prisma.LevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          update: {
            args: Prisma.LevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          deleteMany: {
            args: Prisma.LevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          aggregate: {
            args: Prisma.LevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLevel>
          }
          groupBy: {
            args: Prisma.LevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<LevelGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LevelFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LevelAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LevelCountArgs<ExtArgs>
            result: $Utils.Optional<LevelCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    contest?: ContestOmit
    recurringContest?: RecurringContestOmit
    contestRule?: ContestRuleOmit
    contestPhoto?: ContestPhotoOmit
    contestWinner?: ContestWinnerOmit
    contestParticipant?: ContestParticipantOmit
    contestPrize?: ContestPrizeOmit
    contestAchievement?: ContestAchievementOmit
    notification?: NotificationOmit
    payment?: PaymentOmit
    sitePolicy?: SitePolicyOmit
    room?: RoomOmit
    chat?: ChatOmit
    product?: ProductOmit
    price?: PriceOmit
    team?: TeamOmit
    teamMember?: TeamMemberOmit
    teamParticipation?: TeamParticipationOmit
    user?: UserOmit
    userStore?: UserStoreOmit
    userPhoto?: UserPhotoOmit
    like?: LikeOmit
    otp?: OtpOmit
    comment?: CommentOmit
    follow?: FollowOmit
    vote?: VoteOmit
    userLevel?: UserLevelOmit
    level?: LevelOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ContestCountOutputType
   */

  export type ContestCountOutputType = {
    participants: number
    teamParticipations: number
    votes: number
    contestRules: number
    contestPrizes: number
    achievements: number
  }

  export type ContestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | ContestCountOutputTypeCountParticipantsArgs
    teamParticipations?: boolean | ContestCountOutputTypeCountTeamParticipationsArgs
    votes?: boolean | ContestCountOutputTypeCountVotesArgs
    contestRules?: boolean | ContestCountOutputTypeCountContestRulesArgs
    contestPrizes?: boolean | ContestCountOutputTypeCountContestPrizesArgs
    achievements?: boolean | ContestCountOutputTypeCountAchievementsArgs
  }

  // Custom InputTypes
  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestCountOutputType
     */
    select?: ContestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestParticipantWhereInput
  }

  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountTeamParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamParticipationWhereInput
  }

  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
  }

  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountContestRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestRuleWhereInput
  }

  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountContestPrizesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestPrizeWhereInput
  }

  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestAchievementWhereInput
  }


  /**
   * Count Type ContestPhotoCountOutputType
   */

  export type ContestPhotoCountOutputType = {
    votes: number
    comments: number
    achievements: number
    ContestWinner: number
  }

  export type ContestPhotoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    votes?: boolean | ContestPhotoCountOutputTypeCountVotesArgs
    comments?: boolean | ContestPhotoCountOutputTypeCountCommentsArgs
    achievements?: boolean | ContestPhotoCountOutputTypeCountAchievementsArgs
    ContestWinner?: boolean | ContestPhotoCountOutputTypeCountContestWinnerArgs
  }

  // Custom InputTypes
  /**
   * ContestPhotoCountOutputType without action
   */
  export type ContestPhotoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhotoCountOutputType
     */
    select?: ContestPhotoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContestPhotoCountOutputType without action
   */
  export type ContestPhotoCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
  }

  /**
   * ContestPhotoCountOutputType without action
   */
  export type ContestPhotoCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * ContestPhotoCountOutputType without action
   */
  export type ContestPhotoCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestAchievementWhereInput
  }

  /**
   * ContestPhotoCountOutputType without action
   */
  export type ContestPhotoCountOutputTypeCountContestWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestWinnerWhereInput
  }


  /**
   * Count Type ContestParticipantCountOutputType
   */

  export type ContestParticipantCountOutputType = {
    photos: number
    ContestWinner: number
    contestAchievement: number
  }

  export type ContestParticipantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | ContestParticipantCountOutputTypeCountPhotosArgs
    ContestWinner?: boolean | ContestParticipantCountOutputTypeCountContestWinnerArgs
    contestAchievement?: boolean | ContestParticipantCountOutputTypeCountContestAchievementArgs
  }

  // Custom InputTypes
  /**
   * ContestParticipantCountOutputType without action
   */
  export type ContestParticipantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipantCountOutputType
     */
    select?: ContestParticipantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContestParticipantCountOutputType without action
   */
  export type ContestParticipantCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestPhotoWhereInput
  }

  /**
   * ContestParticipantCountOutputType without action
   */
  export type ContestParticipantCountOutputTypeCountContestWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestWinnerWhereInput
  }

  /**
   * ContestParticipantCountOutputType without action
   */
  export type ContestParticipantCountOutputTypeCountContestAchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestAchievementWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    members: number
    chat: number
    participations: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | TeamCountOutputTypeCountMembersArgs
    chat?: boolean | TeamCountOutputTypeCountChatArgs
    participations?: boolean | TeamCountOutputTypeCountParticipationsArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamParticipationWhereInput
  }


  /**
   * Count Type TeamMemberCountOutputType
   */

  export type TeamMemberCountOutputType = {
    contestParticipant: number
  }

  export type TeamMemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contestParticipant?: boolean | TeamMemberCountOutputTypeCountContestParticipantArgs
  }

  // Custom InputTypes
  /**
   * TeamMemberCountOutputType without action
   */
  export type TeamMemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMemberCountOutputType
     */
    select?: TeamMemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamMemberCountOutputType without action
   */
  export type TeamMemberCountOutputTypeCountContestParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestParticipantWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdTeam: number
    createdContests: number
    commentProvides: number
    followers: number
    followings: number
    votes: number
    likes: number
    userPhotos: number
    ContestParticipant: number
    chat: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdTeam?: boolean | UserCountOutputTypeCountCreatedTeamArgs
    createdContests?: boolean | UserCountOutputTypeCountCreatedContestsArgs
    commentProvides?: boolean | UserCountOutputTypeCountCommentProvidesArgs
    followers?: boolean | UserCountOutputTypeCountFollowersArgs
    followings?: boolean | UserCountOutputTypeCountFollowingsArgs
    votes?: boolean | UserCountOutputTypeCountVotesArgs
    likes?: boolean | UserCountOutputTypeCountLikesArgs
    userPhotos?: boolean | UserCountOutputTypeCountUserPhotosArgs
    ContestParticipant?: boolean | UserCountOutputTypeCountContestParticipantArgs
    chat?: boolean | UserCountOutputTypeCountChatArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedContestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentProvidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPhotoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContestParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }


  /**
   * Count Type UserPhotoCountOutputType
   */

  export type UserPhotoCountOutputType = {
    contestUpload: number
    likes: number
  }

  export type UserPhotoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contestUpload?: boolean | UserPhotoCountOutputTypeCountContestUploadArgs
    likes?: boolean | UserPhotoCountOutputTypeCountLikesArgs
  }

  // Custom InputTypes
  /**
   * UserPhotoCountOutputType without action
   */
  export type UserPhotoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhotoCountOutputType
     */
    select?: UserPhotoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserPhotoCountOutputType without action
   */
  export type UserPhotoCountOutputTypeCountContestUploadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestPhotoWhereInput
  }

  /**
   * UserPhotoCountOutputType without action
   */
  export type UserPhotoCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    CommentReplies: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CommentReplies?: boolean | CommentCountOutputTypeCountCommentRepliesArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountCommentRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model RecurringData
   */





  export type RecurringDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recurringType?: boolean
    previousOccurrence?: boolean
    nextOccurrence?: boolean
    duration?: boolean
  }, ExtArgs["result"]["recurringData"]>



  export type RecurringDataSelectScalar = {
    recurringType?: boolean
    previousOccurrence?: boolean
    nextOccurrence?: boolean
    duration?: boolean
  }

  export type RecurringDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"recurringType" | "previousOccurrence" | "nextOccurrence" | "duration", ExtArgs["result"]["recurringData"]>

  export type $RecurringDataPayload = {
    name: "RecurringData"
    objects: {}
    scalars: {
      recurringType: $Enums.RecurringType
      previousOccurrence: Date | null
      nextOccurrence: Date
      duration: number
    }
    composites: {}
  }

  type RecurringDataGetPayload<S extends boolean | null | undefined | RecurringDataDefaultArgs> = $Result.GetResult<Prisma.$RecurringDataPayload, S>





  /**
   * Fields of the RecurringData model
   */
  interface RecurringDataFieldRefs {
    readonly recurringType: FieldRef<"RecurringData", 'RecurringType'>
    readonly previousOccurrence: FieldRef<"RecurringData", 'DateTime'>
    readonly nextOccurrence: FieldRef<"RecurringData", 'DateTime'>
    readonly duration: FieldRef<"RecurringData", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RecurringData without action
   */
  export type RecurringDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringData
     */
    select?: RecurringDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringData
     */
    omit?: RecurringDataOmit<ExtArgs> | null
  }


  /**
   * Model LevelRequirement
   */





  export type LevelRequirementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    title?: boolean
    required?: boolean
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["levelRequirement"]>



  export type LevelRequirementSelectScalar = {
    title?: boolean
    required?: boolean
  }

  export type LevelRequirementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"title" | "required" | "badge", ExtArgs["result"]["levelRequirement"]>
  export type LevelRequirementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LevelRequirementPayload = {
    name: "LevelRequirement"
    objects: {}
    scalars: {
      title: string
      required: number
    }
    composites: {
      badge: Prisma.$BadgePayload
    }
  }

  type LevelRequirementGetPayload<S extends boolean | null | undefined | LevelRequirementDefaultArgs> = $Result.GetResult<Prisma.$LevelRequirementPayload, S>





  /**
   * Fields of the LevelRequirement model
   */
  interface LevelRequirementFieldRefs {
    readonly title: FieldRef<"LevelRequirement", 'String'>
    readonly required: FieldRef<"LevelRequirement", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LevelRequirement without action
   */
  export type LevelRequirementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelRequirement
     */
    select?: LevelRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LevelRequirement
     */
    omit?: LevelRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelRequirementInclude<ExtArgs> | null
  }


  /**
   * Model Badge
   */





  export type BadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    type?: boolean
    param?: boolean
  }, ExtArgs["result"]["badge"]>



  export type BadgeSelectScalar = {
    type?: boolean
    param?: boolean
  }

  export type BadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"type" | "param", ExtArgs["result"]["badge"]>

  export type $BadgePayload = {
    name: "Badge"
    objects: {}
    scalars: {
      type: string
      param: string
    }
    composites: {}
  }

  type BadgeGetPayload<S extends boolean | null | undefined | BadgeDefaultArgs> = $Result.GetResult<Prisma.$BadgePayload, S>





  /**
   * Fields of the Badge model
   */
  interface BadgeFieldRefs {
    readonly type: FieldRef<"Badge", 'String'>
    readonly param: FieldRef<"Badge", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Badge without action
   */
  export type BadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
  }


  /**
   * Model PhotoStats
   */





  export type PhotoStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Composition?: boolean
    Content?: boolean
    Creativity?: boolean
    Technique?: boolean
  }, ExtArgs["result"]["photoStats"]>



  export type PhotoStatsSelectScalar = {
    Composition?: boolean
    Content?: boolean
    Creativity?: boolean
    Technique?: boolean
  }

  export type PhotoStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Composition" | "Content" | "Creativity" | "Technique", ExtArgs["result"]["photoStats"]>

  export type $PhotoStatsPayload = {
    name: "PhotoStats"
    objects: {}
    scalars: {
      Composition: number
      Content: number
      Creativity: number
      Technique: number
    }
    composites: {}
  }

  type PhotoStatsGetPayload<S extends boolean | null | undefined | PhotoStatsDefaultArgs> = $Result.GetResult<Prisma.$PhotoStatsPayload, S>





  /**
   * Fields of the PhotoStats model
   */
  interface PhotoStatsFieldRefs {
    readonly Composition: FieldRef<"PhotoStats", 'Int'>
    readonly Content: FieldRef<"PhotoStats", 'Int'>
    readonly Creativity: FieldRef<"PhotoStats", 'Int'>
    readonly Technique: FieldRef<"PhotoStats", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PhotoStats without action
   */
  export type PhotoStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoStats
     */
    select?: PhotoStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhotoStats
     */
    omit?: PhotoStatsOmit<ExtArgs> | null
  }


  /**
   * Model Contest
   */

  export type AggregateContest = {
    _count: ContestCountAggregateOutputType | null
    _avg: ContestAvgAggregateOutputType | null
    _sum: ContestSumAggregateOutputType | null
    _min: ContestMinAggregateOutputType | null
    _max: ContestMaxAggregateOutputType | null
  }

  export type ContestAvgAggregateOutputType = {
    maxUploads: number | null
    maxPrize: number | null
    minPrize: number | null
    level_requirements: number | null
  }

  export type ContestSumAggregateOutputType = {
    maxUploads: number | null
    maxPrize: number | null
    minPrize: number | null
    level_requirements: number[]
  }

  export type ContestMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    banner: string | null
    status: $Enums.ContestStatus | null
    mode: $Enums.ContestMode | null
    maxUploads: number | null
    isMoneyContest: boolean | null
    maxPrize: number | null
    minPrize: number | null
    startDate: Date | null
    endDate: Date | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    banner: string | null
    status: $Enums.ContestStatus | null
    mode: $Enums.ContestMode | null
    maxUploads: number | null
    isMoneyContest: boolean | null
    maxPrize: number | null
    minPrize: number | null
    startDate: Date | null
    endDate: Date | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestCountAggregateOutputType = {
    id: number
    title: number
    description: number
    banner: number
    status: number
    mode: number
    maxUploads: number
    isMoneyContest: number
    maxPrize: number
    minPrize: number
    level_requirements: number
    startDate: number
    endDate: number
    creatorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContestAvgAggregateInputType = {
    maxUploads?: true
    maxPrize?: true
    minPrize?: true
    level_requirements?: true
  }

  export type ContestSumAggregateInputType = {
    maxUploads?: true
    maxPrize?: true
    minPrize?: true
    level_requirements?: true
  }

  export type ContestMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    banner?: true
    status?: true
    mode?: true
    maxUploads?: true
    isMoneyContest?: true
    maxPrize?: true
    minPrize?: true
    startDate?: true
    endDate?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    banner?: true
    status?: true
    mode?: true
    maxUploads?: true
    isMoneyContest?: true
    maxPrize?: true
    minPrize?: true
    startDate?: true
    endDate?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    banner?: true
    status?: true
    mode?: true
    maxUploads?: true
    isMoneyContest?: true
    maxPrize?: true
    minPrize?: true
    level_requirements?: true
    startDate?: true
    endDate?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contest to aggregate.
     */
    where?: ContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contests to fetch.
     */
    orderBy?: ContestOrderByWithRelationInput | ContestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contests
    **/
    _count?: true | ContestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestMaxAggregateInputType
  }

  export type GetContestAggregateType<T extends ContestAggregateArgs> = {
        [P in keyof T & keyof AggregateContest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContest[P]>
      : GetScalarType<T[P], AggregateContest[P]>
  }




  export type ContestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestWhereInput
    orderBy?: ContestOrderByWithAggregationInput | ContestOrderByWithAggregationInput[]
    by: ContestScalarFieldEnum[] | ContestScalarFieldEnum
    having?: ContestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestCountAggregateInputType | true
    _avg?: ContestAvgAggregateInputType
    _sum?: ContestSumAggregateInputType
    _min?: ContestMinAggregateInputType
    _max?: ContestMaxAggregateInputType
  }

  export type ContestGroupByOutputType = {
    id: string
    title: string
    description: string
    banner: string | null
    status: $Enums.ContestStatus
    mode: $Enums.ContestMode
    maxUploads: number
    isMoneyContest: boolean
    maxPrize: number | null
    minPrize: number | null
    level_requirements: number[]
    startDate: Date
    endDate: Date
    creatorId: string
    createdAt: Date
    updatedAt: Date
    _count: ContestCountAggregateOutputType | null
    _avg: ContestAvgAggregateOutputType | null
    _sum: ContestSumAggregateOutputType | null
    _min: ContestMinAggregateOutputType | null
    _max: ContestMaxAggregateOutputType | null
  }

  type GetContestGroupByPayload<T extends ContestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestGroupByOutputType[P]>
            : GetScalarType<T[P], ContestGroupByOutputType[P]>
        }
      >
    >


  export type ContestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    banner?: boolean
    status?: boolean
    mode?: boolean
    maxUploads?: boolean
    isMoneyContest?: boolean
    maxPrize?: boolean
    minPrize?: boolean
    level_requirements?: boolean
    startDate?: boolean
    endDate?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    participants?: boolean | Contest$participantsArgs<ExtArgs>
    teamParticipations?: boolean | Contest$teamParticipationsArgs<ExtArgs>
    votes?: boolean | Contest$votesArgs<ExtArgs>
    contestRules?: boolean | Contest$contestRulesArgs<ExtArgs>
    contestPrizes?: boolean | Contest$contestPrizesArgs<ExtArgs>
    achievements?: boolean | Contest$achievementsArgs<ExtArgs>
    _count?: boolean | ContestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contest"]>



  export type ContestSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    banner?: boolean
    status?: boolean
    mode?: boolean
    maxUploads?: boolean
    isMoneyContest?: boolean
    maxPrize?: boolean
    minPrize?: boolean
    level_requirements?: boolean
    startDate?: boolean
    endDate?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "banner" | "status" | "mode" | "maxUploads" | "isMoneyContest" | "maxPrize" | "minPrize" | "level_requirements" | "startDate" | "endDate" | "creatorId" | "createdAt" | "updatedAt", ExtArgs["result"]["contest"]>
  export type ContestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    participants?: boolean | Contest$participantsArgs<ExtArgs>
    teamParticipations?: boolean | Contest$teamParticipationsArgs<ExtArgs>
    votes?: boolean | Contest$votesArgs<ExtArgs>
    contestRules?: boolean | Contest$contestRulesArgs<ExtArgs>
    contestPrizes?: boolean | Contest$contestPrizesArgs<ExtArgs>
    achievements?: boolean | Contest$achievementsArgs<ExtArgs>
    _count?: boolean | ContestCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contest"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      participants: Prisma.$ContestParticipantPayload<ExtArgs>[]
      teamParticipations: Prisma.$TeamParticipationPayload<ExtArgs>[]
      votes: Prisma.$VotePayload<ExtArgs>[]
      contestRules: Prisma.$ContestRulePayload<ExtArgs>[]
      contestPrizes: Prisma.$ContestPrizePayload<ExtArgs>[]
      achievements: Prisma.$ContestAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      banner: string | null
      status: $Enums.ContestStatus
      mode: $Enums.ContestMode
      maxUploads: number
      isMoneyContest: boolean
      maxPrize: number | null
      minPrize: number | null
      level_requirements: number[]
      startDate: Date
      endDate: Date
      creatorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contest"]>
    composites: {}
  }

  type ContestGetPayload<S extends boolean | null | undefined | ContestDefaultArgs> = $Result.GetResult<Prisma.$ContestPayload, S>

  type ContestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContestCountAggregateInputType | true
    }

  export interface ContestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contest'], meta: { name: 'Contest' } }
    /**
     * Find zero or one Contest that matches the filter.
     * @param {ContestFindUniqueArgs} args - Arguments to find a Contest
     * @example
     * // Get one Contest
     * const contest = await prisma.contest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContestFindUniqueArgs>(args: SelectSubset<T, ContestFindUniqueArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContestFindUniqueOrThrowArgs} args - Arguments to find a Contest
     * @example
     * // Get one Contest
     * const contest = await prisma.contest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContestFindUniqueOrThrowArgs>(args: SelectSubset<T, ContestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestFindFirstArgs} args - Arguments to find a Contest
     * @example
     * // Get one Contest
     * const contest = await prisma.contest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContestFindFirstArgs>(args?: SelectSubset<T, ContestFindFirstArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestFindFirstOrThrowArgs} args - Arguments to find a Contest
     * @example
     * // Get one Contest
     * const contest = await prisma.contest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContestFindFirstOrThrowArgs>(args?: SelectSubset<T, ContestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contests
     * const contests = await prisma.contest.findMany()
     * 
     * // Get first 10 Contests
     * const contests = await prisma.contest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contestWithIdOnly = await prisma.contest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContestFindManyArgs>(args?: SelectSubset<T, ContestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contest.
     * @param {ContestCreateArgs} args - Arguments to create a Contest.
     * @example
     * // Create one Contest
     * const Contest = await prisma.contest.create({
     *   data: {
     *     // ... data to create a Contest
     *   }
     * })
     * 
     */
    create<T extends ContestCreateArgs>(args: SelectSubset<T, ContestCreateArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contests.
     * @param {ContestCreateManyArgs} args - Arguments to create many Contests.
     * @example
     * // Create many Contests
     * const contest = await prisma.contest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContestCreateManyArgs>(args?: SelectSubset<T, ContestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contest.
     * @param {ContestDeleteArgs} args - Arguments to delete one Contest.
     * @example
     * // Delete one Contest
     * const Contest = await prisma.contest.delete({
     *   where: {
     *     // ... filter to delete one Contest
     *   }
     * })
     * 
     */
    delete<T extends ContestDeleteArgs>(args: SelectSubset<T, ContestDeleteArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contest.
     * @param {ContestUpdateArgs} args - Arguments to update one Contest.
     * @example
     * // Update one Contest
     * const contest = await prisma.contest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContestUpdateArgs>(args: SelectSubset<T, ContestUpdateArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contests.
     * @param {ContestDeleteManyArgs} args - Arguments to filter Contests to delete.
     * @example
     * // Delete a few Contests
     * const { count } = await prisma.contest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContestDeleteManyArgs>(args?: SelectSubset<T, ContestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contests
     * const contest = await prisma.contest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContestUpdateManyArgs>(args: SelectSubset<T, ContestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contest.
     * @param {ContestUpsertArgs} args - Arguments to update or create a Contest.
     * @example
     * // Update or create a Contest
     * const contest = await prisma.contest.upsert({
     *   create: {
     *     // ... data to create a Contest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contest we want to update
     *   }
     * })
     */
    upsert<T extends ContestUpsertArgs>(args: SelectSubset<T, ContestUpsertArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contests that matches the filter.
     * @param {ContestFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contest = await prisma.contest.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ContestFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Contest.
     * @param {ContestAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contest = await prisma.contest.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ContestAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Contests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestCountArgs} args - Arguments to filter Contests to count.
     * @example
     * // Count the number of Contests
     * const count = await prisma.contest.count({
     *   where: {
     *     // ... the filter for the Contests we want to count
     *   }
     * })
    **/
    count<T extends ContestCountArgs>(
      args?: Subset<T, ContestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestAggregateArgs>(args: Subset<T, ContestAggregateArgs>): Prisma.PrismaPromise<GetContestAggregateType<T>>

    /**
     * Group by Contest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContestGroupByArgs['orderBy'] }
        : { orderBy?: ContestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contest model
   */
  readonly fields: ContestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participants<T extends Contest$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Contest$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamParticipations<T extends Contest$teamParticipationsArgs<ExtArgs> = {}>(args?: Subset<T, Contest$teamParticipationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    votes<T extends Contest$votesArgs<ExtArgs> = {}>(args?: Subset<T, Contest$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contestRules<T extends Contest$contestRulesArgs<ExtArgs> = {}>(args?: Subset<T, Contest$contestRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contestPrizes<T extends Contest$contestPrizesArgs<ExtArgs> = {}>(args?: Subset<T, Contest$contestPrizesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestPrizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    achievements<T extends Contest$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, Contest$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contest model
   */
  interface ContestFieldRefs {
    readonly id: FieldRef<"Contest", 'String'>
    readonly title: FieldRef<"Contest", 'String'>
    readonly description: FieldRef<"Contest", 'String'>
    readonly banner: FieldRef<"Contest", 'String'>
    readonly status: FieldRef<"Contest", 'ContestStatus'>
    readonly mode: FieldRef<"Contest", 'ContestMode'>
    readonly maxUploads: FieldRef<"Contest", 'Int'>
    readonly isMoneyContest: FieldRef<"Contest", 'Boolean'>
    readonly maxPrize: FieldRef<"Contest", 'Int'>
    readonly minPrize: FieldRef<"Contest", 'Int'>
    readonly level_requirements: FieldRef<"Contest", 'Int[]'>
    readonly startDate: FieldRef<"Contest", 'DateTime'>
    readonly endDate: FieldRef<"Contest", 'DateTime'>
    readonly creatorId: FieldRef<"Contest", 'String'>
    readonly createdAt: FieldRef<"Contest", 'DateTime'>
    readonly updatedAt: FieldRef<"Contest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contest findUnique
   */
  export type ContestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * Filter, which Contest to fetch.
     */
    where: ContestWhereUniqueInput
  }

  /**
   * Contest findUniqueOrThrow
   */
  export type ContestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * Filter, which Contest to fetch.
     */
    where: ContestWhereUniqueInput
  }

  /**
   * Contest findFirst
   */
  export type ContestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * Filter, which Contest to fetch.
     */
    where?: ContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contests to fetch.
     */
    orderBy?: ContestOrderByWithRelationInput | ContestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contests.
     */
    cursor?: ContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contests.
     */
    distinct?: ContestScalarFieldEnum | ContestScalarFieldEnum[]
  }

  /**
   * Contest findFirstOrThrow
   */
  export type ContestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * Filter, which Contest to fetch.
     */
    where?: ContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contests to fetch.
     */
    orderBy?: ContestOrderByWithRelationInput | ContestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contests.
     */
    cursor?: ContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contests.
     */
    distinct?: ContestScalarFieldEnum | ContestScalarFieldEnum[]
  }

  /**
   * Contest findMany
   */
  export type ContestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * Filter, which Contests to fetch.
     */
    where?: ContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contests to fetch.
     */
    orderBy?: ContestOrderByWithRelationInput | ContestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contests.
     */
    cursor?: ContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contests.
     */
    skip?: number
    distinct?: ContestScalarFieldEnum | ContestScalarFieldEnum[]
  }

  /**
   * Contest create
   */
  export type ContestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * The data needed to create a Contest.
     */
    data: XOR<ContestCreateInput, ContestUncheckedCreateInput>
  }

  /**
   * Contest createMany
   */
  export type ContestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contests.
     */
    data: ContestCreateManyInput | ContestCreateManyInput[]
  }

  /**
   * Contest update
   */
  export type ContestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * The data needed to update a Contest.
     */
    data: XOR<ContestUpdateInput, ContestUncheckedUpdateInput>
    /**
     * Choose, which Contest to update.
     */
    where: ContestWhereUniqueInput
  }

  /**
   * Contest updateMany
   */
  export type ContestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contests.
     */
    data: XOR<ContestUpdateManyMutationInput, ContestUncheckedUpdateManyInput>
    /**
     * Filter which Contests to update
     */
    where?: ContestWhereInput
    /**
     * Limit how many Contests to update.
     */
    limit?: number
  }

  /**
   * Contest upsert
   */
  export type ContestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * The filter to search for the Contest to update in case it exists.
     */
    where: ContestWhereUniqueInput
    /**
     * In case the Contest found by the `where` argument doesn't exist, create a new Contest with this data.
     */
    create: XOR<ContestCreateInput, ContestUncheckedCreateInput>
    /**
     * In case the Contest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContestUpdateInput, ContestUncheckedUpdateInput>
  }

  /**
   * Contest delete
   */
  export type ContestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * Filter which Contest to delete.
     */
    where: ContestWhereUniqueInput
  }

  /**
   * Contest deleteMany
   */
  export type ContestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contests to delete
     */
    where?: ContestWhereInput
    /**
     * Limit how many Contests to delete.
     */
    limit?: number
  }

  /**
   * Contest findRaw
   */
  export type ContestFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Contest aggregateRaw
   */
  export type ContestAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Contest.participants
   */
  export type Contest$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    where?: ContestParticipantWhereInput
    orderBy?: ContestParticipantOrderByWithRelationInput | ContestParticipantOrderByWithRelationInput[]
    cursor?: ContestParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestParticipantScalarFieldEnum | ContestParticipantScalarFieldEnum[]
  }

  /**
   * Contest.teamParticipations
   */
  export type Contest$teamParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamParticipation
     */
    select?: TeamParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamParticipation
     */
    omit?: TeamParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamParticipationInclude<ExtArgs> | null
    where?: TeamParticipationWhereInput
    orderBy?: TeamParticipationOrderByWithRelationInput | TeamParticipationOrderByWithRelationInput[]
    cursor?: TeamParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamParticipationScalarFieldEnum | TeamParticipationScalarFieldEnum[]
  }

  /**
   * Contest.votes
   */
  export type Contest$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    cursor?: VoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Contest.contestRules
   */
  export type Contest$contestRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
    where?: ContestRuleWhereInput
    orderBy?: ContestRuleOrderByWithRelationInput | ContestRuleOrderByWithRelationInput[]
    cursor?: ContestRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestRuleScalarFieldEnum | ContestRuleScalarFieldEnum[]
  }

  /**
   * Contest.contestPrizes
   */
  export type Contest$contestPrizesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
    where?: ContestPrizeWhereInput
    orderBy?: ContestPrizeOrderByWithRelationInput | ContestPrizeOrderByWithRelationInput[]
    cursor?: ContestPrizeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestPrizeScalarFieldEnum | ContestPrizeScalarFieldEnum[]
  }

  /**
   * Contest.achievements
   */
  export type Contest$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    where?: ContestAchievementWhereInput
    orderBy?: ContestAchievementOrderByWithRelationInput | ContestAchievementOrderByWithRelationInput[]
    cursor?: ContestAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestAchievementScalarFieldEnum | ContestAchievementScalarFieldEnum[]
  }

  /**
   * Contest without action
   */
  export type ContestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
  }


  /**
   * Model RecurringContest
   */

  export type AggregateRecurringContest = {
    _count: RecurringContestCountAggregateOutputType | null
    _avg: RecurringContestAvgAggregateOutputType | null
    _sum: RecurringContestSumAggregateOutputType | null
    _min: RecurringContestMinAggregateOutputType | null
    _max: RecurringContestMaxAggregateOutputType | null
  }

  export type RecurringContestAvgAggregateOutputType = {
    maxUploads: number | null
    maxPrize: number | null
    minPrize: number | null
    level_requirements: number | null
  }

  export type RecurringContestSumAggregateOutputType = {
    maxUploads: number | null
    maxPrize: number | null
    minPrize: number | null
    level_requirements: number[]
  }

  export type RecurringContestMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    banner: string | null
    maxUploads: number | null
    isMoneyContest: boolean | null
    maxPrize: number | null
    minPrize: number | null
    startDate: Date | null
    endDate: Date | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringContestMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    banner: string | null
    maxUploads: number | null
    isMoneyContest: boolean | null
    maxPrize: number | null
    minPrize: number | null
    startDate: Date | null
    endDate: Date | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringContestCountAggregateOutputType = {
    id: number
    title: number
    description: number
    banner: number
    maxUploads: number
    isMoneyContest: number
    maxPrize: number
    minPrize: number
    level_requirements: number
    startDate: number
    endDate: number
    creatorId: number
    rules: number
    prizes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecurringContestAvgAggregateInputType = {
    maxUploads?: true
    maxPrize?: true
    minPrize?: true
    level_requirements?: true
  }

  export type RecurringContestSumAggregateInputType = {
    maxUploads?: true
    maxPrize?: true
    minPrize?: true
    level_requirements?: true
  }

  export type RecurringContestMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    banner?: true
    maxUploads?: true
    isMoneyContest?: true
    maxPrize?: true
    minPrize?: true
    startDate?: true
    endDate?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringContestMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    banner?: true
    maxUploads?: true
    isMoneyContest?: true
    maxPrize?: true
    minPrize?: true
    startDate?: true
    endDate?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringContestCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    banner?: true
    maxUploads?: true
    isMoneyContest?: true
    maxPrize?: true
    minPrize?: true
    level_requirements?: true
    startDate?: true
    endDate?: true
    creatorId?: true
    rules?: true
    prizes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecurringContestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringContest to aggregate.
     */
    where?: RecurringContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringContests to fetch.
     */
    orderBy?: RecurringContestOrderByWithRelationInput | RecurringContestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecurringContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringContests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringContests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecurringContests
    **/
    _count?: true | RecurringContestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecurringContestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecurringContestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecurringContestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecurringContestMaxAggregateInputType
  }

  export type GetRecurringContestAggregateType<T extends RecurringContestAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurringContest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurringContest[P]>
      : GetScalarType<T[P], AggregateRecurringContest[P]>
  }




  export type RecurringContestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringContestWhereInput
    orderBy?: RecurringContestOrderByWithAggregationInput | RecurringContestOrderByWithAggregationInput[]
    by: RecurringContestScalarFieldEnum[] | RecurringContestScalarFieldEnum
    having?: RecurringContestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecurringContestCountAggregateInputType | true
    _avg?: RecurringContestAvgAggregateInputType
    _sum?: RecurringContestSumAggregateInputType
    _min?: RecurringContestMinAggregateInputType
    _max?: RecurringContestMaxAggregateInputType
  }

  export type RecurringContestGroupByOutputType = {
    id: string
    title: string
    description: string
    banner: string | null
    maxUploads: number
    isMoneyContest: boolean
    maxPrize: number | null
    minPrize: number | null
    level_requirements: number[]
    startDate: Date
    endDate: Date
    creatorId: string
    rules: JsonValue
    prizes: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: RecurringContestCountAggregateOutputType | null
    _avg: RecurringContestAvgAggregateOutputType | null
    _sum: RecurringContestSumAggregateOutputType | null
    _min: RecurringContestMinAggregateOutputType | null
    _max: RecurringContestMaxAggregateOutputType | null
  }

  type GetRecurringContestGroupByPayload<T extends RecurringContestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecurringContestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecurringContestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecurringContestGroupByOutputType[P]>
            : GetScalarType<T[P], RecurringContestGroupByOutputType[P]>
        }
      >
    >


  export type RecurringContestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    banner?: boolean
    maxUploads?: boolean
    isMoneyContest?: boolean
    maxPrize?: boolean
    minPrize?: boolean
    level_requirements?: boolean
    startDate?: boolean
    endDate?: boolean
    creatorId?: boolean
    recurring?: boolean | RecurringDataDefaultArgs<ExtArgs>
    rules?: boolean
    prizes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["recurringContest"]>



  export type RecurringContestSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    banner?: boolean
    maxUploads?: boolean
    isMoneyContest?: boolean
    maxPrize?: boolean
    minPrize?: boolean
    level_requirements?: boolean
    startDate?: boolean
    endDate?: boolean
    creatorId?: boolean
    rules?: boolean
    prizes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RecurringContestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "banner" | "maxUploads" | "isMoneyContest" | "maxPrize" | "minPrize" | "level_requirements" | "startDate" | "endDate" | "creatorId" | "recurring" | "rules" | "prizes" | "createdAt" | "updatedAt", ExtArgs["result"]["recurringContest"]>
  export type RecurringContestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RecurringContestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecurringContest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      banner: string | null
      maxUploads: number
      isMoneyContest: boolean
      maxPrize: number | null
      minPrize: number | null
      level_requirements: number[]
      startDate: Date
      endDate: Date
      creatorId: string
      rules: Prisma.JsonValue
      prizes: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recurringContest"]>
    composites: {
      recurring: Prisma.$RecurringDataPayload
    }
  }

  type RecurringContestGetPayload<S extends boolean | null | undefined | RecurringContestDefaultArgs> = $Result.GetResult<Prisma.$RecurringContestPayload, S>

  type RecurringContestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecurringContestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecurringContestCountAggregateInputType | true
    }

  export interface RecurringContestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecurringContest'], meta: { name: 'RecurringContest' } }
    /**
     * Find zero or one RecurringContest that matches the filter.
     * @param {RecurringContestFindUniqueArgs} args - Arguments to find a RecurringContest
     * @example
     * // Get one RecurringContest
     * const recurringContest = await prisma.recurringContest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecurringContestFindUniqueArgs>(args: SelectSubset<T, RecurringContestFindUniqueArgs<ExtArgs>>): Prisma__RecurringContestClient<$Result.GetResult<Prisma.$RecurringContestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecurringContest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecurringContestFindUniqueOrThrowArgs} args - Arguments to find a RecurringContest
     * @example
     * // Get one RecurringContest
     * const recurringContest = await prisma.recurringContest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecurringContestFindUniqueOrThrowArgs>(args: SelectSubset<T, RecurringContestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecurringContestClient<$Result.GetResult<Prisma.$RecurringContestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringContest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestFindFirstArgs} args - Arguments to find a RecurringContest
     * @example
     * // Get one RecurringContest
     * const recurringContest = await prisma.recurringContest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecurringContestFindFirstArgs>(args?: SelectSubset<T, RecurringContestFindFirstArgs<ExtArgs>>): Prisma__RecurringContestClient<$Result.GetResult<Prisma.$RecurringContestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringContest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestFindFirstOrThrowArgs} args - Arguments to find a RecurringContest
     * @example
     * // Get one RecurringContest
     * const recurringContest = await prisma.recurringContest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecurringContestFindFirstOrThrowArgs>(args?: SelectSubset<T, RecurringContestFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecurringContestClient<$Result.GetResult<Prisma.$RecurringContestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecurringContests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecurringContests
     * const recurringContests = await prisma.recurringContest.findMany()
     * 
     * // Get first 10 RecurringContests
     * const recurringContests = await prisma.recurringContest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recurringContestWithIdOnly = await prisma.recurringContest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecurringContestFindManyArgs>(args?: SelectSubset<T, RecurringContestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringContestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecurringContest.
     * @param {RecurringContestCreateArgs} args - Arguments to create a RecurringContest.
     * @example
     * // Create one RecurringContest
     * const RecurringContest = await prisma.recurringContest.create({
     *   data: {
     *     // ... data to create a RecurringContest
     *   }
     * })
     * 
     */
    create<T extends RecurringContestCreateArgs>(args: SelectSubset<T, RecurringContestCreateArgs<ExtArgs>>): Prisma__RecurringContestClient<$Result.GetResult<Prisma.$RecurringContestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecurringContests.
     * @param {RecurringContestCreateManyArgs} args - Arguments to create many RecurringContests.
     * @example
     * // Create many RecurringContests
     * const recurringContest = await prisma.recurringContest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecurringContestCreateManyArgs>(args?: SelectSubset<T, RecurringContestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RecurringContest.
     * @param {RecurringContestDeleteArgs} args - Arguments to delete one RecurringContest.
     * @example
     * // Delete one RecurringContest
     * const RecurringContest = await prisma.recurringContest.delete({
     *   where: {
     *     // ... filter to delete one RecurringContest
     *   }
     * })
     * 
     */
    delete<T extends RecurringContestDeleteArgs>(args: SelectSubset<T, RecurringContestDeleteArgs<ExtArgs>>): Prisma__RecurringContestClient<$Result.GetResult<Prisma.$RecurringContestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecurringContest.
     * @param {RecurringContestUpdateArgs} args - Arguments to update one RecurringContest.
     * @example
     * // Update one RecurringContest
     * const recurringContest = await prisma.recurringContest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecurringContestUpdateArgs>(args: SelectSubset<T, RecurringContestUpdateArgs<ExtArgs>>): Prisma__RecurringContestClient<$Result.GetResult<Prisma.$RecurringContestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecurringContests.
     * @param {RecurringContestDeleteManyArgs} args - Arguments to filter RecurringContests to delete.
     * @example
     * // Delete a few RecurringContests
     * const { count } = await prisma.recurringContest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecurringContestDeleteManyArgs>(args?: SelectSubset<T, RecurringContestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringContests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecurringContests
     * const recurringContest = await prisma.recurringContest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecurringContestUpdateManyArgs>(args: SelectSubset<T, RecurringContestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecurringContest.
     * @param {RecurringContestUpsertArgs} args - Arguments to update or create a RecurringContest.
     * @example
     * // Update or create a RecurringContest
     * const recurringContest = await prisma.recurringContest.upsert({
     *   create: {
     *     // ... data to create a RecurringContest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecurringContest we want to update
     *   }
     * })
     */
    upsert<T extends RecurringContestUpsertArgs>(args: SelectSubset<T, RecurringContestUpsertArgs<ExtArgs>>): Prisma__RecurringContestClient<$Result.GetResult<Prisma.$RecurringContestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecurringContests that matches the filter.
     * @param {RecurringContestFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const recurringContest = await prisma.recurringContest.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: RecurringContestFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a RecurringContest.
     * @param {RecurringContestAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const recurringContest = await prisma.recurringContest.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: RecurringContestAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of RecurringContests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestCountArgs} args - Arguments to filter RecurringContests to count.
     * @example
     * // Count the number of RecurringContests
     * const count = await prisma.recurringContest.count({
     *   where: {
     *     // ... the filter for the RecurringContests we want to count
     *   }
     * })
    **/
    count<T extends RecurringContestCountArgs>(
      args?: Subset<T, RecurringContestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecurringContestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecurringContest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecurringContestAggregateArgs>(args: Subset<T, RecurringContestAggregateArgs>): Prisma.PrismaPromise<GetRecurringContestAggregateType<T>>

    /**
     * Group by RecurringContest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecurringContestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecurringContestGroupByArgs['orderBy'] }
        : { orderBy?: RecurringContestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecurringContestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecurringContestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecurringContest model
   */
  readonly fields: RecurringContestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecurringContest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecurringContestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecurringContest model
   */
  interface RecurringContestFieldRefs {
    readonly id: FieldRef<"RecurringContest", 'String'>
    readonly title: FieldRef<"RecurringContest", 'String'>
    readonly description: FieldRef<"RecurringContest", 'String'>
    readonly banner: FieldRef<"RecurringContest", 'String'>
    readonly maxUploads: FieldRef<"RecurringContest", 'Int'>
    readonly isMoneyContest: FieldRef<"RecurringContest", 'Boolean'>
    readonly maxPrize: FieldRef<"RecurringContest", 'Int'>
    readonly minPrize: FieldRef<"RecurringContest", 'Int'>
    readonly level_requirements: FieldRef<"RecurringContest", 'Int[]'>
    readonly startDate: FieldRef<"RecurringContest", 'DateTime'>
    readonly endDate: FieldRef<"RecurringContest", 'DateTime'>
    readonly creatorId: FieldRef<"RecurringContest", 'String'>
    readonly rules: FieldRef<"RecurringContest", 'Json'>
    readonly prizes: FieldRef<"RecurringContest", 'Json'>
    readonly createdAt: FieldRef<"RecurringContest", 'DateTime'>
    readonly updatedAt: FieldRef<"RecurringContest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecurringContest findUnique
   */
  export type RecurringContestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContest
     */
    select?: RecurringContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContest
     */
    omit?: RecurringContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestInclude<ExtArgs> | null
    /**
     * Filter, which RecurringContest to fetch.
     */
    where: RecurringContestWhereUniqueInput
  }

  /**
   * RecurringContest findUniqueOrThrow
   */
  export type RecurringContestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContest
     */
    select?: RecurringContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContest
     */
    omit?: RecurringContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestInclude<ExtArgs> | null
    /**
     * Filter, which RecurringContest to fetch.
     */
    where: RecurringContestWhereUniqueInput
  }

  /**
   * RecurringContest findFirst
   */
  export type RecurringContestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContest
     */
    select?: RecurringContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContest
     */
    omit?: RecurringContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestInclude<ExtArgs> | null
    /**
     * Filter, which RecurringContest to fetch.
     */
    where?: RecurringContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringContests to fetch.
     */
    orderBy?: RecurringContestOrderByWithRelationInput | RecurringContestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringContests.
     */
    cursor?: RecurringContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringContests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringContests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringContests.
     */
    distinct?: RecurringContestScalarFieldEnum | RecurringContestScalarFieldEnum[]
  }

  /**
   * RecurringContest findFirstOrThrow
   */
  export type RecurringContestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContest
     */
    select?: RecurringContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContest
     */
    omit?: RecurringContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestInclude<ExtArgs> | null
    /**
     * Filter, which RecurringContest to fetch.
     */
    where?: RecurringContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringContests to fetch.
     */
    orderBy?: RecurringContestOrderByWithRelationInput | RecurringContestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringContests.
     */
    cursor?: RecurringContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringContests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringContests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringContests.
     */
    distinct?: RecurringContestScalarFieldEnum | RecurringContestScalarFieldEnum[]
  }

  /**
   * RecurringContest findMany
   */
  export type RecurringContestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContest
     */
    select?: RecurringContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContest
     */
    omit?: RecurringContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestInclude<ExtArgs> | null
    /**
     * Filter, which RecurringContests to fetch.
     */
    where?: RecurringContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringContests to fetch.
     */
    orderBy?: RecurringContestOrderByWithRelationInput | RecurringContestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecurringContests.
     */
    cursor?: RecurringContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringContests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringContests.
     */
    skip?: number
    distinct?: RecurringContestScalarFieldEnum | RecurringContestScalarFieldEnum[]
  }

  /**
   * RecurringContest create
   */
  export type RecurringContestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContest
     */
    select?: RecurringContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContest
     */
    omit?: RecurringContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestInclude<ExtArgs> | null
    /**
     * The data needed to create a RecurringContest.
     */
    data: XOR<RecurringContestCreateInput, RecurringContestUncheckedCreateInput>
  }

  /**
   * RecurringContest createMany
   */
  export type RecurringContestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecurringContests.
     */
    data: RecurringContestCreateManyInput | RecurringContestCreateManyInput[]
  }

  /**
   * RecurringContest update
   */
  export type RecurringContestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContest
     */
    select?: RecurringContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContest
     */
    omit?: RecurringContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestInclude<ExtArgs> | null
    /**
     * The data needed to update a RecurringContest.
     */
    data: XOR<RecurringContestUpdateInput, RecurringContestUncheckedUpdateInput>
    /**
     * Choose, which RecurringContest to update.
     */
    where: RecurringContestWhereUniqueInput
  }

  /**
   * RecurringContest updateMany
   */
  export type RecurringContestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecurringContests.
     */
    data: XOR<RecurringContestUpdateManyMutationInput, RecurringContestUncheckedUpdateManyInput>
    /**
     * Filter which RecurringContests to update
     */
    where?: RecurringContestWhereInput
    /**
     * Limit how many RecurringContests to update.
     */
    limit?: number
  }

  /**
   * RecurringContest upsert
   */
  export type RecurringContestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContest
     */
    select?: RecurringContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContest
     */
    omit?: RecurringContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestInclude<ExtArgs> | null
    /**
     * The filter to search for the RecurringContest to update in case it exists.
     */
    where: RecurringContestWhereUniqueInput
    /**
     * In case the RecurringContest found by the `where` argument doesn't exist, create a new RecurringContest with this data.
     */
    create: XOR<RecurringContestCreateInput, RecurringContestUncheckedCreateInput>
    /**
     * In case the RecurringContest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecurringContestUpdateInput, RecurringContestUncheckedUpdateInput>
  }

  /**
   * RecurringContest delete
   */
  export type RecurringContestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContest
     */
    select?: RecurringContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContest
     */
    omit?: RecurringContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestInclude<ExtArgs> | null
    /**
     * Filter which RecurringContest to delete.
     */
    where: RecurringContestWhereUniqueInput
  }

  /**
   * RecurringContest deleteMany
   */
  export type RecurringContestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringContests to delete
     */
    where?: RecurringContestWhereInput
    /**
     * Limit how many RecurringContests to delete.
     */
    limit?: number
  }

  /**
   * RecurringContest findRaw
   */
  export type RecurringContestFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * RecurringContest aggregateRaw
   */
  export type RecurringContestAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * RecurringContest without action
   */
  export type RecurringContestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContest
     */
    select?: RecurringContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContest
     */
    omit?: RecurringContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestInclude<ExtArgs> | null
  }


  /**
   * Model ContestRule
   */

  export type AggregateContestRule = {
    _count: ContestRuleCountAggregateOutputType | null
    _min: ContestRuleMinAggregateOutputType | null
    _max: ContestRuleMaxAggregateOutputType | null
  }

  export type ContestRuleMinAggregateOutputType = {
    id: string | null
    icon: string | null
    name: string | null
    description: string | null
    contestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestRuleMaxAggregateOutputType = {
    id: string | null
    icon: string | null
    name: string | null
    description: string | null
    contestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestRuleCountAggregateOutputType = {
    id: number
    icon: number
    name: number
    description: number
    contestId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContestRuleMinAggregateInputType = {
    id?: true
    icon?: true
    name?: true
    description?: true
    contestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestRuleMaxAggregateInputType = {
    id?: true
    icon?: true
    name?: true
    description?: true
    contestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestRuleCountAggregateInputType = {
    id?: true
    icon?: true
    name?: true
    description?: true
    contestId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContestRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestRule to aggregate.
     */
    where?: ContestRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestRules to fetch.
     */
    orderBy?: ContestRuleOrderByWithRelationInput | ContestRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContestRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContestRules
    **/
    _count?: true | ContestRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestRuleMaxAggregateInputType
  }

  export type GetContestRuleAggregateType<T extends ContestRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateContestRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContestRule[P]>
      : GetScalarType<T[P], AggregateContestRule[P]>
  }




  export type ContestRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestRuleWhereInput
    orderBy?: ContestRuleOrderByWithAggregationInput | ContestRuleOrderByWithAggregationInput[]
    by: ContestRuleScalarFieldEnum[] | ContestRuleScalarFieldEnum
    having?: ContestRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestRuleCountAggregateInputType | true
    _min?: ContestRuleMinAggregateInputType
    _max?: ContestRuleMaxAggregateInputType
  }

  export type ContestRuleGroupByOutputType = {
    id: string
    icon: string | null
    name: string
    description: string
    contestId: string
    createdAt: Date
    updatedAt: Date
    _count: ContestRuleCountAggregateOutputType | null
    _min: ContestRuleMinAggregateOutputType | null
    _max: ContestRuleMaxAggregateOutputType | null
  }

  type GetContestRuleGroupByPayload<T extends ContestRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestRuleGroupByOutputType[P]>
            : GetScalarType<T[P], ContestRuleGroupByOutputType[P]>
        }
      >
    >


  export type ContestRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    icon?: boolean
    name?: boolean
    description?: boolean
    contestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contest?: boolean | ContestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contestRule"]>



  export type ContestRuleSelectScalar = {
    id?: boolean
    icon?: boolean
    name?: boolean
    description?: boolean
    contestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContestRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "icon" | "name" | "description" | "contestId" | "createdAt" | "updatedAt", ExtArgs["result"]["contestRule"]>
  export type ContestRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contest?: boolean | ContestDefaultArgs<ExtArgs>
  }

  export type $ContestRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContestRule"
    objects: {
      contest: Prisma.$ContestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      icon: string | null
      name: string
      description: string
      contestId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contestRule"]>
    composites: {}
  }

  type ContestRuleGetPayload<S extends boolean | null | undefined | ContestRuleDefaultArgs> = $Result.GetResult<Prisma.$ContestRulePayload, S>

  type ContestRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContestRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContestRuleCountAggregateInputType | true
    }

  export interface ContestRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContestRule'], meta: { name: 'ContestRule' } }
    /**
     * Find zero or one ContestRule that matches the filter.
     * @param {ContestRuleFindUniqueArgs} args - Arguments to find a ContestRule
     * @example
     * // Get one ContestRule
     * const contestRule = await prisma.contestRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContestRuleFindUniqueArgs>(args: SelectSubset<T, ContestRuleFindUniqueArgs<ExtArgs>>): Prisma__ContestRuleClient<$Result.GetResult<Prisma.$ContestRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContestRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContestRuleFindUniqueOrThrowArgs} args - Arguments to find a ContestRule
     * @example
     * // Get one ContestRule
     * const contestRule = await prisma.contestRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContestRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ContestRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContestRuleClient<$Result.GetResult<Prisma.$ContestRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestRuleFindFirstArgs} args - Arguments to find a ContestRule
     * @example
     * // Get one ContestRule
     * const contestRule = await prisma.contestRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContestRuleFindFirstArgs>(args?: SelectSubset<T, ContestRuleFindFirstArgs<ExtArgs>>): Prisma__ContestRuleClient<$Result.GetResult<Prisma.$ContestRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestRuleFindFirstOrThrowArgs} args - Arguments to find a ContestRule
     * @example
     * // Get one ContestRule
     * const contestRule = await prisma.contestRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContestRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ContestRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContestRuleClient<$Result.GetResult<Prisma.$ContestRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContestRules
     * const contestRules = await prisma.contestRule.findMany()
     * 
     * // Get first 10 ContestRules
     * const contestRules = await prisma.contestRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contestRuleWithIdOnly = await prisma.contestRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContestRuleFindManyArgs>(args?: SelectSubset<T, ContestRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContestRule.
     * @param {ContestRuleCreateArgs} args - Arguments to create a ContestRule.
     * @example
     * // Create one ContestRule
     * const ContestRule = await prisma.contestRule.create({
     *   data: {
     *     // ... data to create a ContestRule
     *   }
     * })
     * 
     */
    create<T extends ContestRuleCreateArgs>(args: SelectSubset<T, ContestRuleCreateArgs<ExtArgs>>): Prisma__ContestRuleClient<$Result.GetResult<Prisma.$ContestRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContestRules.
     * @param {ContestRuleCreateManyArgs} args - Arguments to create many ContestRules.
     * @example
     * // Create many ContestRules
     * const contestRule = await prisma.contestRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContestRuleCreateManyArgs>(args?: SelectSubset<T, ContestRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContestRule.
     * @param {ContestRuleDeleteArgs} args - Arguments to delete one ContestRule.
     * @example
     * // Delete one ContestRule
     * const ContestRule = await prisma.contestRule.delete({
     *   where: {
     *     // ... filter to delete one ContestRule
     *   }
     * })
     * 
     */
    delete<T extends ContestRuleDeleteArgs>(args: SelectSubset<T, ContestRuleDeleteArgs<ExtArgs>>): Prisma__ContestRuleClient<$Result.GetResult<Prisma.$ContestRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContestRule.
     * @param {ContestRuleUpdateArgs} args - Arguments to update one ContestRule.
     * @example
     * // Update one ContestRule
     * const contestRule = await prisma.contestRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContestRuleUpdateArgs>(args: SelectSubset<T, ContestRuleUpdateArgs<ExtArgs>>): Prisma__ContestRuleClient<$Result.GetResult<Prisma.$ContestRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContestRules.
     * @param {ContestRuleDeleteManyArgs} args - Arguments to filter ContestRules to delete.
     * @example
     * // Delete a few ContestRules
     * const { count } = await prisma.contestRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContestRuleDeleteManyArgs>(args?: SelectSubset<T, ContestRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContestRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContestRules
     * const contestRule = await prisma.contestRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContestRuleUpdateManyArgs>(args: SelectSubset<T, ContestRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContestRule.
     * @param {ContestRuleUpsertArgs} args - Arguments to update or create a ContestRule.
     * @example
     * // Update or create a ContestRule
     * const contestRule = await prisma.contestRule.upsert({
     *   create: {
     *     // ... data to create a ContestRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContestRule we want to update
     *   }
     * })
     */
    upsert<T extends ContestRuleUpsertArgs>(args: SelectSubset<T, ContestRuleUpsertArgs<ExtArgs>>): Prisma__ContestRuleClient<$Result.GetResult<Prisma.$ContestRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestRules that matches the filter.
     * @param {ContestRuleFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contestRule = await prisma.contestRule.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ContestRuleFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ContestRule.
     * @param {ContestRuleAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contestRule = await prisma.contestRule.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ContestRuleAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ContestRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestRuleCountArgs} args - Arguments to filter ContestRules to count.
     * @example
     * // Count the number of ContestRules
     * const count = await prisma.contestRule.count({
     *   where: {
     *     // ... the filter for the ContestRules we want to count
     *   }
     * })
    **/
    count<T extends ContestRuleCountArgs>(
      args?: Subset<T, ContestRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContestRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestRuleAggregateArgs>(args: Subset<T, ContestRuleAggregateArgs>): Prisma.PrismaPromise<GetContestRuleAggregateType<T>>

    /**
     * Group by ContestRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContestRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContestRuleGroupByArgs['orderBy'] }
        : { orderBy?: ContestRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContestRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContestRule model
   */
  readonly fields: ContestRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContestRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContestRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contest<T extends ContestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestDefaultArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContestRule model
   */
  interface ContestRuleFieldRefs {
    readonly id: FieldRef<"ContestRule", 'String'>
    readonly icon: FieldRef<"ContestRule", 'String'>
    readonly name: FieldRef<"ContestRule", 'String'>
    readonly description: FieldRef<"ContestRule", 'String'>
    readonly contestId: FieldRef<"ContestRule", 'String'>
    readonly createdAt: FieldRef<"ContestRule", 'DateTime'>
    readonly updatedAt: FieldRef<"ContestRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContestRule findUnique
   */
  export type ContestRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
    /**
     * Filter, which ContestRule to fetch.
     */
    where: ContestRuleWhereUniqueInput
  }

  /**
   * ContestRule findUniqueOrThrow
   */
  export type ContestRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
    /**
     * Filter, which ContestRule to fetch.
     */
    where: ContestRuleWhereUniqueInput
  }

  /**
   * ContestRule findFirst
   */
  export type ContestRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
    /**
     * Filter, which ContestRule to fetch.
     */
    where?: ContestRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestRules to fetch.
     */
    orderBy?: ContestRuleOrderByWithRelationInput | ContestRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestRules.
     */
    cursor?: ContestRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestRules.
     */
    distinct?: ContestRuleScalarFieldEnum | ContestRuleScalarFieldEnum[]
  }

  /**
   * ContestRule findFirstOrThrow
   */
  export type ContestRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
    /**
     * Filter, which ContestRule to fetch.
     */
    where?: ContestRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestRules to fetch.
     */
    orderBy?: ContestRuleOrderByWithRelationInput | ContestRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestRules.
     */
    cursor?: ContestRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestRules.
     */
    distinct?: ContestRuleScalarFieldEnum | ContestRuleScalarFieldEnum[]
  }

  /**
   * ContestRule findMany
   */
  export type ContestRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
    /**
     * Filter, which ContestRules to fetch.
     */
    where?: ContestRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestRules to fetch.
     */
    orderBy?: ContestRuleOrderByWithRelationInput | ContestRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContestRules.
     */
    cursor?: ContestRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestRules.
     */
    skip?: number
    distinct?: ContestRuleScalarFieldEnum | ContestRuleScalarFieldEnum[]
  }

  /**
   * ContestRule create
   */
  export type ContestRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a ContestRule.
     */
    data: XOR<ContestRuleCreateInput, ContestRuleUncheckedCreateInput>
  }

  /**
   * ContestRule createMany
   */
  export type ContestRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContestRules.
     */
    data: ContestRuleCreateManyInput | ContestRuleCreateManyInput[]
  }

  /**
   * ContestRule update
   */
  export type ContestRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a ContestRule.
     */
    data: XOR<ContestRuleUpdateInput, ContestRuleUncheckedUpdateInput>
    /**
     * Choose, which ContestRule to update.
     */
    where: ContestRuleWhereUniqueInput
  }

  /**
   * ContestRule updateMany
   */
  export type ContestRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContestRules.
     */
    data: XOR<ContestRuleUpdateManyMutationInput, ContestRuleUncheckedUpdateManyInput>
    /**
     * Filter which ContestRules to update
     */
    where?: ContestRuleWhereInput
    /**
     * Limit how many ContestRules to update.
     */
    limit?: number
  }

  /**
   * ContestRule upsert
   */
  export type ContestRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the ContestRule to update in case it exists.
     */
    where: ContestRuleWhereUniqueInput
    /**
     * In case the ContestRule found by the `where` argument doesn't exist, create a new ContestRule with this data.
     */
    create: XOR<ContestRuleCreateInput, ContestRuleUncheckedCreateInput>
    /**
     * In case the ContestRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContestRuleUpdateInput, ContestRuleUncheckedUpdateInput>
  }

  /**
   * ContestRule delete
   */
  export type ContestRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
    /**
     * Filter which ContestRule to delete.
     */
    where: ContestRuleWhereUniqueInput
  }

  /**
   * ContestRule deleteMany
   */
  export type ContestRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestRules to delete
     */
    where?: ContestRuleWhereInput
    /**
     * Limit how many ContestRules to delete.
     */
    limit?: number
  }

  /**
   * ContestRule findRaw
   */
  export type ContestRuleFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestRule aggregateRaw
   */
  export type ContestRuleAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestRule without action
   */
  export type ContestRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
  }


  /**
   * Model ContestPhoto
   */

  export type AggregateContestPhoto = {
    _count: ContestPhotoCountAggregateOutputType | null
    _avg: ContestPhotoAvgAggregateOutputType | null
    _sum: ContestPhotoSumAggregateOutputType | null
    _min: ContestPhotoMinAggregateOutputType | null
    _max: ContestPhotoMaxAggregateOutputType | null
  }

  export type ContestPhotoAvgAggregateOutputType = {
    rank: number | null
  }

  export type ContestPhotoSumAggregateOutputType = {
    rank: number | null
  }

  export type ContestPhotoMinAggregateOutputType = {
    id: string | null
    title: string | null
    contestId: string | null
    participantId: string | null
    photoId: string | null
    rank: number | null
    promoted: boolean | null
    promotionExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestPhotoMaxAggregateOutputType = {
    id: string | null
    title: string | null
    contestId: string | null
    participantId: string | null
    photoId: string | null
    rank: number | null
    promoted: boolean | null
    promotionExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestPhotoCountAggregateOutputType = {
    id: number
    title: number
    contestId: number
    participantId: number
    photoId: number
    rank: number
    promoted: number
    promotionExpiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContestPhotoAvgAggregateInputType = {
    rank?: true
  }

  export type ContestPhotoSumAggregateInputType = {
    rank?: true
  }

  export type ContestPhotoMinAggregateInputType = {
    id?: true
    title?: true
    contestId?: true
    participantId?: true
    photoId?: true
    rank?: true
    promoted?: true
    promotionExpiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestPhotoMaxAggregateInputType = {
    id?: true
    title?: true
    contestId?: true
    participantId?: true
    photoId?: true
    rank?: true
    promoted?: true
    promotionExpiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestPhotoCountAggregateInputType = {
    id?: true
    title?: true
    contestId?: true
    participantId?: true
    photoId?: true
    rank?: true
    promoted?: true
    promotionExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContestPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestPhoto to aggregate.
     */
    where?: ContestPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestPhotos to fetch.
     */
    orderBy?: ContestPhotoOrderByWithRelationInput | ContestPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContestPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContestPhotos
    **/
    _count?: true | ContestPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContestPhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContestPhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestPhotoMaxAggregateInputType
  }

  export type GetContestPhotoAggregateType<T extends ContestPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateContestPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContestPhoto[P]>
      : GetScalarType<T[P], AggregateContestPhoto[P]>
  }




  export type ContestPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestPhotoWhereInput
    orderBy?: ContestPhotoOrderByWithAggregationInput | ContestPhotoOrderByWithAggregationInput[]
    by: ContestPhotoScalarFieldEnum[] | ContestPhotoScalarFieldEnum
    having?: ContestPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestPhotoCountAggregateInputType | true
    _avg?: ContestPhotoAvgAggregateInputType
    _sum?: ContestPhotoSumAggregateInputType
    _min?: ContestPhotoMinAggregateInputType
    _max?: ContestPhotoMaxAggregateInputType
  }

  export type ContestPhotoGroupByOutputType = {
    id: string
    title: string | null
    contestId: string
    participantId: string
    photoId: string
    rank: number | null
    promoted: boolean
    promotionExpiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ContestPhotoCountAggregateOutputType | null
    _avg: ContestPhotoAvgAggregateOutputType | null
    _sum: ContestPhotoSumAggregateOutputType | null
    _min: ContestPhotoMinAggregateOutputType | null
    _max: ContestPhotoMaxAggregateOutputType | null
  }

  type GetContestPhotoGroupByPayload<T extends ContestPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], ContestPhotoGroupByOutputType[P]>
        }
      >
    >


  export type ContestPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    contestId?: boolean
    participantId?: boolean
    photoId?: boolean
    rank?: boolean
    promoted?: boolean
    promotionExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    participant?: boolean | ContestParticipantDefaultArgs<ExtArgs>
    votes?: boolean | ContestPhoto$votesArgs<ExtArgs>
    photo?: boolean | UserPhotoDefaultArgs<ExtArgs>
    comments?: boolean | ContestPhoto$commentsArgs<ExtArgs>
    achievements?: boolean | ContestPhoto$achievementsArgs<ExtArgs>
    ContestWinner?: boolean | ContestPhoto$ContestWinnerArgs<ExtArgs>
    _count?: boolean | ContestPhotoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contestPhoto"]>



  export type ContestPhotoSelectScalar = {
    id?: boolean
    title?: boolean
    contestId?: boolean
    participantId?: boolean
    photoId?: boolean
    rank?: boolean
    promoted?: boolean
    promotionExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContestPhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "contestId" | "participantId" | "photoId" | "rank" | "promoted" | "promotionExpiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["contestPhoto"]>
  export type ContestPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | ContestParticipantDefaultArgs<ExtArgs>
    votes?: boolean | ContestPhoto$votesArgs<ExtArgs>
    photo?: boolean | UserPhotoDefaultArgs<ExtArgs>
    comments?: boolean | ContestPhoto$commentsArgs<ExtArgs>
    achievements?: boolean | ContestPhoto$achievementsArgs<ExtArgs>
    ContestWinner?: boolean | ContestPhoto$ContestWinnerArgs<ExtArgs>
    _count?: boolean | ContestPhotoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContestPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContestPhoto"
    objects: {
      participant: Prisma.$ContestParticipantPayload<ExtArgs>
      votes: Prisma.$VotePayload<ExtArgs>[]
      photo: Prisma.$UserPhotoPayload<ExtArgs>
      comments: Prisma.$CommentPayload<ExtArgs>[]
      achievements: Prisma.$ContestAchievementPayload<ExtArgs>[]
      ContestWinner: Prisma.$ContestWinnerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      contestId: string
      participantId: string
      photoId: string
      rank: number | null
      promoted: boolean
      promotionExpiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contestPhoto"]>
    composites: {}
  }

  type ContestPhotoGetPayload<S extends boolean | null | undefined | ContestPhotoDefaultArgs> = $Result.GetResult<Prisma.$ContestPhotoPayload, S>

  type ContestPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContestPhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContestPhotoCountAggregateInputType | true
    }

  export interface ContestPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContestPhoto'], meta: { name: 'ContestPhoto' } }
    /**
     * Find zero or one ContestPhoto that matches the filter.
     * @param {ContestPhotoFindUniqueArgs} args - Arguments to find a ContestPhoto
     * @example
     * // Get one ContestPhoto
     * const contestPhoto = await prisma.contestPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContestPhotoFindUniqueArgs>(args: SelectSubset<T, ContestPhotoFindUniqueArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContestPhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContestPhotoFindUniqueOrThrowArgs} args - Arguments to find a ContestPhoto
     * @example
     * // Get one ContestPhoto
     * const contestPhoto = await prisma.contestPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContestPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, ContestPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPhotoFindFirstArgs} args - Arguments to find a ContestPhoto
     * @example
     * // Get one ContestPhoto
     * const contestPhoto = await prisma.contestPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContestPhotoFindFirstArgs>(args?: SelectSubset<T, ContestPhotoFindFirstArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPhotoFindFirstOrThrowArgs} args - Arguments to find a ContestPhoto
     * @example
     * // Get one ContestPhoto
     * const contestPhoto = await prisma.contestPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContestPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, ContestPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContestPhotos
     * const contestPhotos = await prisma.contestPhoto.findMany()
     * 
     * // Get first 10 ContestPhotos
     * const contestPhotos = await prisma.contestPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contestPhotoWithIdOnly = await prisma.contestPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContestPhotoFindManyArgs>(args?: SelectSubset<T, ContestPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContestPhoto.
     * @param {ContestPhotoCreateArgs} args - Arguments to create a ContestPhoto.
     * @example
     * // Create one ContestPhoto
     * const ContestPhoto = await prisma.contestPhoto.create({
     *   data: {
     *     // ... data to create a ContestPhoto
     *   }
     * })
     * 
     */
    create<T extends ContestPhotoCreateArgs>(args: SelectSubset<T, ContestPhotoCreateArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContestPhotos.
     * @param {ContestPhotoCreateManyArgs} args - Arguments to create many ContestPhotos.
     * @example
     * // Create many ContestPhotos
     * const contestPhoto = await prisma.contestPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContestPhotoCreateManyArgs>(args?: SelectSubset<T, ContestPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContestPhoto.
     * @param {ContestPhotoDeleteArgs} args - Arguments to delete one ContestPhoto.
     * @example
     * // Delete one ContestPhoto
     * const ContestPhoto = await prisma.contestPhoto.delete({
     *   where: {
     *     // ... filter to delete one ContestPhoto
     *   }
     * })
     * 
     */
    delete<T extends ContestPhotoDeleteArgs>(args: SelectSubset<T, ContestPhotoDeleteArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContestPhoto.
     * @param {ContestPhotoUpdateArgs} args - Arguments to update one ContestPhoto.
     * @example
     * // Update one ContestPhoto
     * const contestPhoto = await prisma.contestPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContestPhotoUpdateArgs>(args: SelectSubset<T, ContestPhotoUpdateArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContestPhotos.
     * @param {ContestPhotoDeleteManyArgs} args - Arguments to filter ContestPhotos to delete.
     * @example
     * // Delete a few ContestPhotos
     * const { count } = await prisma.contestPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContestPhotoDeleteManyArgs>(args?: SelectSubset<T, ContestPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContestPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContestPhotos
     * const contestPhoto = await prisma.contestPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContestPhotoUpdateManyArgs>(args: SelectSubset<T, ContestPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContestPhoto.
     * @param {ContestPhotoUpsertArgs} args - Arguments to update or create a ContestPhoto.
     * @example
     * // Update or create a ContestPhoto
     * const contestPhoto = await prisma.contestPhoto.upsert({
     *   create: {
     *     // ... data to create a ContestPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContestPhoto we want to update
     *   }
     * })
     */
    upsert<T extends ContestPhotoUpsertArgs>(args: SelectSubset<T, ContestPhotoUpsertArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestPhotos that matches the filter.
     * @param {ContestPhotoFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contestPhoto = await prisma.contestPhoto.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ContestPhotoFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ContestPhoto.
     * @param {ContestPhotoAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contestPhoto = await prisma.contestPhoto.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ContestPhotoAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ContestPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPhotoCountArgs} args - Arguments to filter ContestPhotos to count.
     * @example
     * // Count the number of ContestPhotos
     * const count = await prisma.contestPhoto.count({
     *   where: {
     *     // ... the filter for the ContestPhotos we want to count
     *   }
     * })
    **/
    count<T extends ContestPhotoCountArgs>(
      args?: Subset<T, ContestPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContestPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestPhotoAggregateArgs>(args: Subset<T, ContestPhotoAggregateArgs>): Prisma.PrismaPromise<GetContestPhotoAggregateType<T>>

    /**
     * Group by ContestPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContestPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContestPhotoGroupByArgs['orderBy'] }
        : { orderBy?: ContestPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContestPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContestPhoto model
   */
  readonly fields: ContestPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContestPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContestPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participant<T extends ContestParticipantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestParticipantDefaultArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    votes<T extends ContestPhoto$votesArgs<ExtArgs> = {}>(args?: Subset<T, ContestPhoto$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photo<T extends UserPhotoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserPhotoDefaultArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comments<T extends ContestPhoto$commentsArgs<ExtArgs> = {}>(args?: Subset<T, ContestPhoto$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    achievements<T extends ContestPhoto$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, ContestPhoto$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ContestWinner<T extends ContestPhoto$ContestWinnerArgs<ExtArgs> = {}>(args?: Subset<T, ContestPhoto$ContestWinnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContestPhoto model
   */
  interface ContestPhotoFieldRefs {
    readonly id: FieldRef<"ContestPhoto", 'String'>
    readonly title: FieldRef<"ContestPhoto", 'String'>
    readonly contestId: FieldRef<"ContestPhoto", 'String'>
    readonly participantId: FieldRef<"ContestPhoto", 'String'>
    readonly photoId: FieldRef<"ContestPhoto", 'String'>
    readonly rank: FieldRef<"ContestPhoto", 'Int'>
    readonly promoted: FieldRef<"ContestPhoto", 'Boolean'>
    readonly promotionExpiresAt: FieldRef<"ContestPhoto", 'DateTime'>
    readonly createdAt: FieldRef<"ContestPhoto", 'DateTime'>
    readonly updatedAt: FieldRef<"ContestPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContestPhoto findUnique
   */
  export type ContestPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ContestPhoto to fetch.
     */
    where: ContestPhotoWhereUniqueInput
  }

  /**
   * ContestPhoto findUniqueOrThrow
   */
  export type ContestPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ContestPhoto to fetch.
     */
    where: ContestPhotoWhereUniqueInput
  }

  /**
   * ContestPhoto findFirst
   */
  export type ContestPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ContestPhoto to fetch.
     */
    where?: ContestPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestPhotos to fetch.
     */
    orderBy?: ContestPhotoOrderByWithRelationInput | ContestPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestPhotos.
     */
    cursor?: ContestPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestPhotos.
     */
    distinct?: ContestPhotoScalarFieldEnum | ContestPhotoScalarFieldEnum[]
  }

  /**
   * ContestPhoto findFirstOrThrow
   */
  export type ContestPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ContestPhoto to fetch.
     */
    where?: ContestPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestPhotos to fetch.
     */
    orderBy?: ContestPhotoOrderByWithRelationInput | ContestPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestPhotos.
     */
    cursor?: ContestPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestPhotos.
     */
    distinct?: ContestPhotoScalarFieldEnum | ContestPhotoScalarFieldEnum[]
  }

  /**
   * ContestPhoto findMany
   */
  export type ContestPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ContestPhotos to fetch.
     */
    where?: ContestPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestPhotos to fetch.
     */
    orderBy?: ContestPhotoOrderByWithRelationInput | ContestPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContestPhotos.
     */
    cursor?: ContestPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestPhotos.
     */
    skip?: number
    distinct?: ContestPhotoScalarFieldEnum | ContestPhotoScalarFieldEnum[]
  }

  /**
   * ContestPhoto create
   */
  export type ContestPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a ContestPhoto.
     */
    data: XOR<ContestPhotoCreateInput, ContestPhotoUncheckedCreateInput>
  }

  /**
   * ContestPhoto createMany
   */
  export type ContestPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContestPhotos.
     */
    data: ContestPhotoCreateManyInput | ContestPhotoCreateManyInput[]
  }

  /**
   * ContestPhoto update
   */
  export type ContestPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a ContestPhoto.
     */
    data: XOR<ContestPhotoUpdateInput, ContestPhotoUncheckedUpdateInput>
    /**
     * Choose, which ContestPhoto to update.
     */
    where: ContestPhotoWhereUniqueInput
  }

  /**
   * ContestPhoto updateMany
   */
  export type ContestPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContestPhotos.
     */
    data: XOR<ContestPhotoUpdateManyMutationInput, ContestPhotoUncheckedUpdateManyInput>
    /**
     * Filter which ContestPhotos to update
     */
    where?: ContestPhotoWhereInput
    /**
     * Limit how many ContestPhotos to update.
     */
    limit?: number
  }

  /**
   * ContestPhoto upsert
   */
  export type ContestPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the ContestPhoto to update in case it exists.
     */
    where: ContestPhotoWhereUniqueInput
    /**
     * In case the ContestPhoto found by the `where` argument doesn't exist, create a new ContestPhoto with this data.
     */
    create: XOR<ContestPhotoCreateInput, ContestPhotoUncheckedCreateInput>
    /**
     * In case the ContestPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContestPhotoUpdateInput, ContestPhotoUncheckedUpdateInput>
  }

  /**
   * ContestPhoto delete
   */
  export type ContestPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    /**
     * Filter which ContestPhoto to delete.
     */
    where: ContestPhotoWhereUniqueInput
  }

  /**
   * ContestPhoto deleteMany
   */
  export type ContestPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestPhotos to delete
     */
    where?: ContestPhotoWhereInput
    /**
     * Limit how many ContestPhotos to delete.
     */
    limit?: number
  }

  /**
   * ContestPhoto findRaw
   */
  export type ContestPhotoFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestPhoto aggregateRaw
   */
  export type ContestPhotoAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestPhoto.votes
   */
  export type ContestPhoto$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    cursor?: VoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * ContestPhoto.comments
   */
  export type ContestPhoto$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * ContestPhoto.achievements
   */
  export type ContestPhoto$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    where?: ContestAchievementWhereInput
    orderBy?: ContestAchievementOrderByWithRelationInput | ContestAchievementOrderByWithRelationInput[]
    cursor?: ContestAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestAchievementScalarFieldEnum | ContestAchievementScalarFieldEnum[]
  }

  /**
   * ContestPhoto.ContestWinner
   */
  export type ContestPhoto$ContestWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    where?: ContestWinnerWhereInput
    orderBy?: ContestWinnerOrderByWithRelationInput | ContestWinnerOrderByWithRelationInput[]
    cursor?: ContestWinnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestWinnerScalarFieldEnum | ContestWinnerScalarFieldEnum[]
  }

  /**
   * ContestPhoto without action
   */
  export type ContestPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
  }


  /**
   * Model ContestWinner
   */

  export type AggregateContestWinner = {
    _count: ContestWinnerCountAggregateOutputType | null
    _min: ContestWinnerMinAggregateOutputType | null
    _max: ContestWinnerMaxAggregateOutputType | null
  }

  export type ContestWinnerMinAggregateOutputType = {
    id: string | null
    participantId: string | null
    contestId: string | null
    contestPhotoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestWinnerMaxAggregateOutputType = {
    id: string | null
    participantId: string | null
    contestId: string | null
    contestPhotoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestWinnerCountAggregateOutputType = {
    id: number
    participantId: number
    contestId: number
    contestPhotoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContestWinnerMinAggregateInputType = {
    id?: true
    participantId?: true
    contestId?: true
    contestPhotoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestWinnerMaxAggregateInputType = {
    id?: true
    participantId?: true
    contestId?: true
    contestPhotoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestWinnerCountAggregateInputType = {
    id?: true
    participantId?: true
    contestId?: true
    contestPhotoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContestWinnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestWinner to aggregate.
     */
    where?: ContestWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestWinners to fetch.
     */
    orderBy?: ContestWinnerOrderByWithRelationInput | ContestWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContestWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContestWinners
    **/
    _count?: true | ContestWinnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestWinnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestWinnerMaxAggregateInputType
  }

  export type GetContestWinnerAggregateType<T extends ContestWinnerAggregateArgs> = {
        [P in keyof T & keyof AggregateContestWinner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContestWinner[P]>
      : GetScalarType<T[P], AggregateContestWinner[P]>
  }




  export type ContestWinnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestWinnerWhereInput
    orderBy?: ContestWinnerOrderByWithAggregationInput | ContestWinnerOrderByWithAggregationInput[]
    by: ContestWinnerScalarFieldEnum[] | ContestWinnerScalarFieldEnum
    having?: ContestWinnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestWinnerCountAggregateInputType | true
    _min?: ContestWinnerMinAggregateInputType
    _max?: ContestWinnerMaxAggregateInputType
  }

  export type ContestWinnerGroupByOutputType = {
    id: string
    participantId: string
    contestId: string
    contestPhotoId: string
    createdAt: Date
    updatedAt: Date
    _count: ContestWinnerCountAggregateOutputType | null
    _min: ContestWinnerMinAggregateOutputType | null
    _max: ContestWinnerMaxAggregateOutputType | null
  }

  type GetContestWinnerGroupByPayload<T extends ContestWinnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestWinnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestWinnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestWinnerGroupByOutputType[P]>
            : GetScalarType<T[P], ContestWinnerGroupByOutputType[P]>
        }
      >
    >


  export type ContestWinnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantId?: boolean
    contestId?: boolean
    contestPhotoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    participant?: boolean | ContestParticipantDefaultArgs<ExtArgs>
    photo?: boolean | ContestPhotoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contestWinner"]>



  export type ContestWinnerSelectScalar = {
    id?: boolean
    participantId?: boolean
    contestId?: boolean
    contestPhotoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContestWinnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "participantId" | "contestId" | "contestPhotoId" | "createdAt" | "updatedAt", ExtArgs["result"]["contestWinner"]>
  export type ContestWinnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | ContestParticipantDefaultArgs<ExtArgs>
    photo?: boolean | ContestPhotoDefaultArgs<ExtArgs>
  }

  export type $ContestWinnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContestWinner"
    objects: {
      participant: Prisma.$ContestParticipantPayload<ExtArgs>
      photo: Prisma.$ContestPhotoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      participantId: string
      contestId: string
      contestPhotoId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contestWinner"]>
    composites: {}
  }

  type ContestWinnerGetPayload<S extends boolean | null | undefined | ContestWinnerDefaultArgs> = $Result.GetResult<Prisma.$ContestWinnerPayload, S>

  type ContestWinnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContestWinnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContestWinnerCountAggregateInputType | true
    }

  export interface ContestWinnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContestWinner'], meta: { name: 'ContestWinner' } }
    /**
     * Find zero or one ContestWinner that matches the filter.
     * @param {ContestWinnerFindUniqueArgs} args - Arguments to find a ContestWinner
     * @example
     * // Get one ContestWinner
     * const contestWinner = await prisma.contestWinner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContestWinnerFindUniqueArgs>(args: SelectSubset<T, ContestWinnerFindUniqueArgs<ExtArgs>>): Prisma__ContestWinnerClient<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContestWinner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContestWinnerFindUniqueOrThrowArgs} args - Arguments to find a ContestWinner
     * @example
     * // Get one ContestWinner
     * const contestWinner = await prisma.contestWinner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContestWinnerFindUniqueOrThrowArgs>(args: SelectSubset<T, ContestWinnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContestWinnerClient<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestWinner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestWinnerFindFirstArgs} args - Arguments to find a ContestWinner
     * @example
     * // Get one ContestWinner
     * const contestWinner = await prisma.contestWinner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContestWinnerFindFirstArgs>(args?: SelectSubset<T, ContestWinnerFindFirstArgs<ExtArgs>>): Prisma__ContestWinnerClient<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestWinner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestWinnerFindFirstOrThrowArgs} args - Arguments to find a ContestWinner
     * @example
     * // Get one ContestWinner
     * const contestWinner = await prisma.contestWinner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContestWinnerFindFirstOrThrowArgs>(args?: SelectSubset<T, ContestWinnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContestWinnerClient<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestWinners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestWinnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContestWinners
     * const contestWinners = await prisma.contestWinner.findMany()
     * 
     * // Get first 10 ContestWinners
     * const contestWinners = await prisma.contestWinner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contestWinnerWithIdOnly = await prisma.contestWinner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContestWinnerFindManyArgs>(args?: SelectSubset<T, ContestWinnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContestWinner.
     * @param {ContestWinnerCreateArgs} args - Arguments to create a ContestWinner.
     * @example
     * // Create one ContestWinner
     * const ContestWinner = await prisma.contestWinner.create({
     *   data: {
     *     // ... data to create a ContestWinner
     *   }
     * })
     * 
     */
    create<T extends ContestWinnerCreateArgs>(args: SelectSubset<T, ContestWinnerCreateArgs<ExtArgs>>): Prisma__ContestWinnerClient<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContestWinners.
     * @param {ContestWinnerCreateManyArgs} args - Arguments to create many ContestWinners.
     * @example
     * // Create many ContestWinners
     * const contestWinner = await prisma.contestWinner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContestWinnerCreateManyArgs>(args?: SelectSubset<T, ContestWinnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContestWinner.
     * @param {ContestWinnerDeleteArgs} args - Arguments to delete one ContestWinner.
     * @example
     * // Delete one ContestWinner
     * const ContestWinner = await prisma.contestWinner.delete({
     *   where: {
     *     // ... filter to delete one ContestWinner
     *   }
     * })
     * 
     */
    delete<T extends ContestWinnerDeleteArgs>(args: SelectSubset<T, ContestWinnerDeleteArgs<ExtArgs>>): Prisma__ContestWinnerClient<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContestWinner.
     * @param {ContestWinnerUpdateArgs} args - Arguments to update one ContestWinner.
     * @example
     * // Update one ContestWinner
     * const contestWinner = await prisma.contestWinner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContestWinnerUpdateArgs>(args: SelectSubset<T, ContestWinnerUpdateArgs<ExtArgs>>): Prisma__ContestWinnerClient<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContestWinners.
     * @param {ContestWinnerDeleteManyArgs} args - Arguments to filter ContestWinners to delete.
     * @example
     * // Delete a few ContestWinners
     * const { count } = await prisma.contestWinner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContestWinnerDeleteManyArgs>(args?: SelectSubset<T, ContestWinnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContestWinners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestWinnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContestWinners
     * const contestWinner = await prisma.contestWinner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContestWinnerUpdateManyArgs>(args: SelectSubset<T, ContestWinnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContestWinner.
     * @param {ContestWinnerUpsertArgs} args - Arguments to update or create a ContestWinner.
     * @example
     * // Update or create a ContestWinner
     * const contestWinner = await prisma.contestWinner.upsert({
     *   create: {
     *     // ... data to create a ContestWinner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContestWinner we want to update
     *   }
     * })
     */
    upsert<T extends ContestWinnerUpsertArgs>(args: SelectSubset<T, ContestWinnerUpsertArgs<ExtArgs>>): Prisma__ContestWinnerClient<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestWinners that matches the filter.
     * @param {ContestWinnerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contestWinner = await prisma.contestWinner.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ContestWinnerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ContestWinner.
     * @param {ContestWinnerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contestWinner = await prisma.contestWinner.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ContestWinnerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ContestWinners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestWinnerCountArgs} args - Arguments to filter ContestWinners to count.
     * @example
     * // Count the number of ContestWinners
     * const count = await prisma.contestWinner.count({
     *   where: {
     *     // ... the filter for the ContestWinners we want to count
     *   }
     * })
    **/
    count<T extends ContestWinnerCountArgs>(
      args?: Subset<T, ContestWinnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestWinnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContestWinner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestWinnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestWinnerAggregateArgs>(args: Subset<T, ContestWinnerAggregateArgs>): Prisma.PrismaPromise<GetContestWinnerAggregateType<T>>

    /**
     * Group by ContestWinner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestWinnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContestWinnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContestWinnerGroupByArgs['orderBy'] }
        : { orderBy?: ContestWinnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContestWinnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestWinnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContestWinner model
   */
  readonly fields: ContestWinnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContestWinner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContestWinnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participant<T extends ContestParticipantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestParticipantDefaultArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    photo<T extends ContestPhotoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestPhotoDefaultArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContestWinner model
   */
  interface ContestWinnerFieldRefs {
    readonly id: FieldRef<"ContestWinner", 'String'>
    readonly participantId: FieldRef<"ContestWinner", 'String'>
    readonly contestId: FieldRef<"ContestWinner", 'String'>
    readonly contestPhotoId: FieldRef<"ContestWinner", 'String'>
    readonly createdAt: FieldRef<"ContestWinner", 'DateTime'>
    readonly updatedAt: FieldRef<"ContestWinner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContestWinner findUnique
   */
  export type ContestWinnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    /**
     * Filter, which ContestWinner to fetch.
     */
    where: ContestWinnerWhereUniqueInput
  }

  /**
   * ContestWinner findUniqueOrThrow
   */
  export type ContestWinnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    /**
     * Filter, which ContestWinner to fetch.
     */
    where: ContestWinnerWhereUniqueInput
  }

  /**
   * ContestWinner findFirst
   */
  export type ContestWinnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    /**
     * Filter, which ContestWinner to fetch.
     */
    where?: ContestWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestWinners to fetch.
     */
    orderBy?: ContestWinnerOrderByWithRelationInput | ContestWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestWinners.
     */
    cursor?: ContestWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestWinners.
     */
    distinct?: ContestWinnerScalarFieldEnum | ContestWinnerScalarFieldEnum[]
  }

  /**
   * ContestWinner findFirstOrThrow
   */
  export type ContestWinnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    /**
     * Filter, which ContestWinner to fetch.
     */
    where?: ContestWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestWinners to fetch.
     */
    orderBy?: ContestWinnerOrderByWithRelationInput | ContestWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestWinners.
     */
    cursor?: ContestWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestWinners.
     */
    distinct?: ContestWinnerScalarFieldEnum | ContestWinnerScalarFieldEnum[]
  }

  /**
   * ContestWinner findMany
   */
  export type ContestWinnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    /**
     * Filter, which ContestWinners to fetch.
     */
    where?: ContestWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestWinners to fetch.
     */
    orderBy?: ContestWinnerOrderByWithRelationInput | ContestWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContestWinners.
     */
    cursor?: ContestWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestWinners.
     */
    skip?: number
    distinct?: ContestWinnerScalarFieldEnum | ContestWinnerScalarFieldEnum[]
  }

  /**
   * ContestWinner create
   */
  export type ContestWinnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    /**
     * The data needed to create a ContestWinner.
     */
    data: XOR<ContestWinnerCreateInput, ContestWinnerUncheckedCreateInput>
  }

  /**
   * ContestWinner createMany
   */
  export type ContestWinnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContestWinners.
     */
    data: ContestWinnerCreateManyInput | ContestWinnerCreateManyInput[]
  }

  /**
   * ContestWinner update
   */
  export type ContestWinnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    /**
     * The data needed to update a ContestWinner.
     */
    data: XOR<ContestWinnerUpdateInput, ContestWinnerUncheckedUpdateInput>
    /**
     * Choose, which ContestWinner to update.
     */
    where: ContestWinnerWhereUniqueInput
  }

  /**
   * ContestWinner updateMany
   */
  export type ContestWinnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContestWinners.
     */
    data: XOR<ContestWinnerUpdateManyMutationInput, ContestWinnerUncheckedUpdateManyInput>
    /**
     * Filter which ContestWinners to update
     */
    where?: ContestWinnerWhereInput
    /**
     * Limit how many ContestWinners to update.
     */
    limit?: number
  }

  /**
   * ContestWinner upsert
   */
  export type ContestWinnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    /**
     * The filter to search for the ContestWinner to update in case it exists.
     */
    where: ContestWinnerWhereUniqueInput
    /**
     * In case the ContestWinner found by the `where` argument doesn't exist, create a new ContestWinner with this data.
     */
    create: XOR<ContestWinnerCreateInput, ContestWinnerUncheckedCreateInput>
    /**
     * In case the ContestWinner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContestWinnerUpdateInput, ContestWinnerUncheckedUpdateInput>
  }

  /**
   * ContestWinner delete
   */
  export type ContestWinnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    /**
     * Filter which ContestWinner to delete.
     */
    where: ContestWinnerWhereUniqueInput
  }

  /**
   * ContestWinner deleteMany
   */
  export type ContestWinnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestWinners to delete
     */
    where?: ContestWinnerWhereInput
    /**
     * Limit how many ContestWinners to delete.
     */
    limit?: number
  }

  /**
   * ContestWinner findRaw
   */
  export type ContestWinnerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestWinner aggregateRaw
   */
  export type ContestWinnerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestWinner without action
   */
  export type ContestWinnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
  }


  /**
   * Model ContestParticipant
   */

  export type AggregateContestParticipant = {
    _count: ContestParticipantCountAggregateOutputType | null
    _avg: ContestParticipantAvgAggregateOutputType | null
    _sum: ContestParticipantSumAggregateOutputType | null
    _min: ContestParticipantMinAggregateOutputType | null
    _max: ContestParticipantMaxAggregateOutputType | null
  }

  export type ContestParticipantAvgAggregateOutputType = {
    rank: number | null
  }

  export type ContestParticipantSumAggregateOutputType = {
    rank: number | null
  }

  export type ContestParticipantMinAggregateOutputType = {
    id: string | null
    status: $Enums.ContestParticipantStatus | null
    contestId: string | null
    userId: string | null
    memberId: string | null
    level: $Enums.YCLevel | null
    rank: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestParticipantMaxAggregateOutputType = {
    id: string | null
    status: $Enums.ContestParticipantStatus | null
    contestId: string | null
    userId: string | null
    memberId: string | null
    level: $Enums.YCLevel | null
    rank: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestParticipantCountAggregateOutputType = {
    id: number
    status: number
    contestId: number
    userId: number
    memberId: number
    level: number
    rank: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContestParticipantAvgAggregateInputType = {
    rank?: true
  }

  export type ContestParticipantSumAggregateInputType = {
    rank?: true
  }

  export type ContestParticipantMinAggregateInputType = {
    id?: true
    status?: true
    contestId?: true
    userId?: true
    memberId?: true
    level?: true
    rank?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestParticipantMaxAggregateInputType = {
    id?: true
    status?: true
    contestId?: true
    userId?: true
    memberId?: true
    level?: true
    rank?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestParticipantCountAggregateInputType = {
    id?: true
    status?: true
    contestId?: true
    userId?: true
    memberId?: true
    level?: true
    rank?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContestParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestParticipant to aggregate.
     */
    where?: ContestParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestParticipants to fetch.
     */
    orderBy?: ContestParticipantOrderByWithRelationInput | ContestParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContestParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContestParticipants
    **/
    _count?: true | ContestParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContestParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContestParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestParticipantMaxAggregateInputType
  }

  export type GetContestParticipantAggregateType<T extends ContestParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateContestParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContestParticipant[P]>
      : GetScalarType<T[P], AggregateContestParticipant[P]>
  }




  export type ContestParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestParticipantWhereInput
    orderBy?: ContestParticipantOrderByWithAggregationInput | ContestParticipantOrderByWithAggregationInput[]
    by: ContestParticipantScalarFieldEnum[] | ContestParticipantScalarFieldEnum
    having?: ContestParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestParticipantCountAggregateInputType | true
    _avg?: ContestParticipantAvgAggregateInputType
    _sum?: ContestParticipantSumAggregateInputType
    _min?: ContestParticipantMinAggregateInputType
    _max?: ContestParticipantMaxAggregateInputType
  }

  export type ContestParticipantGroupByOutputType = {
    id: string
    status: $Enums.ContestParticipantStatus
    contestId: string
    userId: string
    memberId: string | null
    level: $Enums.YCLevel
    rank: number | null
    createdAt: Date
    updatedAt: Date
    _count: ContestParticipantCountAggregateOutputType | null
    _avg: ContestParticipantAvgAggregateOutputType | null
    _sum: ContestParticipantSumAggregateOutputType | null
    _min: ContestParticipantMinAggregateOutputType | null
    _max: ContestParticipantMaxAggregateOutputType | null
  }

  type GetContestParticipantGroupByPayload<T extends ContestParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ContestParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ContestParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    contestId?: boolean
    userId?: boolean
    memberId?: boolean
    level?: boolean
    rank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contest?: boolean | ContestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    member?: boolean | ContestParticipant$memberArgs<ExtArgs>
    photos?: boolean | ContestParticipant$photosArgs<ExtArgs>
    ContestWinner?: boolean | ContestParticipant$ContestWinnerArgs<ExtArgs>
    contestAchievement?: boolean | ContestParticipant$contestAchievementArgs<ExtArgs>
    _count?: boolean | ContestParticipantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contestParticipant"]>



  export type ContestParticipantSelectScalar = {
    id?: boolean
    status?: boolean
    contestId?: boolean
    userId?: boolean
    memberId?: boolean
    level?: boolean
    rank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContestParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "contestId" | "userId" | "memberId" | "level" | "rank" | "createdAt" | "updatedAt", ExtArgs["result"]["contestParticipant"]>
  export type ContestParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contest?: boolean | ContestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    member?: boolean | ContestParticipant$memberArgs<ExtArgs>
    photos?: boolean | ContestParticipant$photosArgs<ExtArgs>
    ContestWinner?: boolean | ContestParticipant$ContestWinnerArgs<ExtArgs>
    contestAchievement?: boolean | ContestParticipant$contestAchievementArgs<ExtArgs>
    _count?: boolean | ContestParticipantCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContestParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContestParticipant"
    objects: {
      contest: Prisma.$ContestPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      member: Prisma.$TeamMemberPayload<ExtArgs> | null
      photos: Prisma.$ContestPhotoPayload<ExtArgs>[]
      ContestWinner: Prisma.$ContestWinnerPayload<ExtArgs>[]
      contestAchievement: Prisma.$ContestAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.ContestParticipantStatus
      contestId: string
      userId: string
      memberId: string | null
      level: $Enums.YCLevel
      rank: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contestParticipant"]>
    composites: {}
  }

  type ContestParticipantGetPayload<S extends boolean | null | undefined | ContestParticipantDefaultArgs> = $Result.GetResult<Prisma.$ContestParticipantPayload, S>

  type ContestParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContestParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContestParticipantCountAggregateInputType | true
    }

  export interface ContestParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContestParticipant'], meta: { name: 'ContestParticipant' } }
    /**
     * Find zero or one ContestParticipant that matches the filter.
     * @param {ContestParticipantFindUniqueArgs} args - Arguments to find a ContestParticipant
     * @example
     * // Get one ContestParticipant
     * const contestParticipant = await prisma.contestParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContestParticipantFindUniqueArgs>(args: SelectSubset<T, ContestParticipantFindUniqueArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContestParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContestParticipantFindUniqueOrThrowArgs} args - Arguments to find a ContestParticipant
     * @example
     * // Get one ContestParticipant
     * const contestParticipant = await prisma.contestParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContestParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ContestParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestParticipantFindFirstArgs} args - Arguments to find a ContestParticipant
     * @example
     * // Get one ContestParticipant
     * const contestParticipant = await prisma.contestParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContestParticipantFindFirstArgs>(args?: SelectSubset<T, ContestParticipantFindFirstArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestParticipantFindFirstOrThrowArgs} args - Arguments to find a ContestParticipant
     * @example
     * // Get one ContestParticipant
     * const contestParticipant = await prisma.contestParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContestParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ContestParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContestParticipants
     * const contestParticipants = await prisma.contestParticipant.findMany()
     * 
     * // Get first 10 ContestParticipants
     * const contestParticipants = await prisma.contestParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contestParticipantWithIdOnly = await prisma.contestParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContestParticipantFindManyArgs>(args?: SelectSubset<T, ContestParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContestParticipant.
     * @param {ContestParticipantCreateArgs} args - Arguments to create a ContestParticipant.
     * @example
     * // Create one ContestParticipant
     * const ContestParticipant = await prisma.contestParticipant.create({
     *   data: {
     *     // ... data to create a ContestParticipant
     *   }
     * })
     * 
     */
    create<T extends ContestParticipantCreateArgs>(args: SelectSubset<T, ContestParticipantCreateArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContestParticipants.
     * @param {ContestParticipantCreateManyArgs} args - Arguments to create many ContestParticipants.
     * @example
     * // Create many ContestParticipants
     * const contestParticipant = await prisma.contestParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContestParticipantCreateManyArgs>(args?: SelectSubset<T, ContestParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContestParticipant.
     * @param {ContestParticipantDeleteArgs} args - Arguments to delete one ContestParticipant.
     * @example
     * // Delete one ContestParticipant
     * const ContestParticipant = await prisma.contestParticipant.delete({
     *   where: {
     *     // ... filter to delete one ContestParticipant
     *   }
     * })
     * 
     */
    delete<T extends ContestParticipantDeleteArgs>(args: SelectSubset<T, ContestParticipantDeleteArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContestParticipant.
     * @param {ContestParticipantUpdateArgs} args - Arguments to update one ContestParticipant.
     * @example
     * // Update one ContestParticipant
     * const contestParticipant = await prisma.contestParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContestParticipantUpdateArgs>(args: SelectSubset<T, ContestParticipantUpdateArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContestParticipants.
     * @param {ContestParticipantDeleteManyArgs} args - Arguments to filter ContestParticipants to delete.
     * @example
     * // Delete a few ContestParticipants
     * const { count } = await prisma.contestParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContestParticipantDeleteManyArgs>(args?: SelectSubset<T, ContestParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContestParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContestParticipants
     * const contestParticipant = await prisma.contestParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContestParticipantUpdateManyArgs>(args: SelectSubset<T, ContestParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContestParticipant.
     * @param {ContestParticipantUpsertArgs} args - Arguments to update or create a ContestParticipant.
     * @example
     * // Update or create a ContestParticipant
     * const contestParticipant = await prisma.contestParticipant.upsert({
     *   create: {
     *     // ... data to create a ContestParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContestParticipant we want to update
     *   }
     * })
     */
    upsert<T extends ContestParticipantUpsertArgs>(args: SelectSubset<T, ContestParticipantUpsertArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestParticipants that matches the filter.
     * @param {ContestParticipantFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contestParticipant = await prisma.contestParticipant.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ContestParticipantFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ContestParticipant.
     * @param {ContestParticipantAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contestParticipant = await prisma.contestParticipant.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ContestParticipantAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ContestParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestParticipantCountArgs} args - Arguments to filter ContestParticipants to count.
     * @example
     * // Count the number of ContestParticipants
     * const count = await prisma.contestParticipant.count({
     *   where: {
     *     // ... the filter for the ContestParticipants we want to count
     *   }
     * })
    **/
    count<T extends ContestParticipantCountArgs>(
      args?: Subset<T, ContestParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContestParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestParticipantAggregateArgs>(args: Subset<T, ContestParticipantAggregateArgs>): Prisma.PrismaPromise<GetContestParticipantAggregateType<T>>

    /**
     * Group by ContestParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContestParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContestParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ContestParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContestParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContestParticipant model
   */
  readonly fields: ContestParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContestParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContestParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contest<T extends ContestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestDefaultArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    member<T extends ContestParticipant$memberArgs<ExtArgs> = {}>(args?: Subset<T, ContestParticipant$memberArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    photos<T extends ContestParticipant$photosArgs<ExtArgs> = {}>(args?: Subset<T, ContestParticipant$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ContestWinner<T extends ContestParticipant$ContestWinnerArgs<ExtArgs> = {}>(args?: Subset<T, ContestParticipant$ContestWinnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contestAchievement<T extends ContestParticipant$contestAchievementArgs<ExtArgs> = {}>(args?: Subset<T, ContestParticipant$contestAchievementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContestParticipant model
   */
  interface ContestParticipantFieldRefs {
    readonly id: FieldRef<"ContestParticipant", 'String'>
    readonly status: FieldRef<"ContestParticipant", 'ContestParticipantStatus'>
    readonly contestId: FieldRef<"ContestParticipant", 'String'>
    readonly userId: FieldRef<"ContestParticipant", 'String'>
    readonly memberId: FieldRef<"ContestParticipant", 'String'>
    readonly level: FieldRef<"ContestParticipant", 'YCLevel'>
    readonly rank: FieldRef<"ContestParticipant", 'Int'>
    readonly createdAt: FieldRef<"ContestParticipant", 'DateTime'>
    readonly updatedAt: FieldRef<"ContestParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContestParticipant findUnique
   */
  export type ContestParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ContestParticipant to fetch.
     */
    where: ContestParticipantWhereUniqueInput
  }

  /**
   * ContestParticipant findUniqueOrThrow
   */
  export type ContestParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ContestParticipant to fetch.
     */
    where: ContestParticipantWhereUniqueInput
  }

  /**
   * ContestParticipant findFirst
   */
  export type ContestParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ContestParticipant to fetch.
     */
    where?: ContestParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestParticipants to fetch.
     */
    orderBy?: ContestParticipantOrderByWithRelationInput | ContestParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestParticipants.
     */
    cursor?: ContestParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestParticipants.
     */
    distinct?: ContestParticipantScalarFieldEnum | ContestParticipantScalarFieldEnum[]
  }

  /**
   * ContestParticipant findFirstOrThrow
   */
  export type ContestParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ContestParticipant to fetch.
     */
    where?: ContestParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestParticipants to fetch.
     */
    orderBy?: ContestParticipantOrderByWithRelationInput | ContestParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestParticipants.
     */
    cursor?: ContestParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestParticipants.
     */
    distinct?: ContestParticipantScalarFieldEnum | ContestParticipantScalarFieldEnum[]
  }

  /**
   * ContestParticipant findMany
   */
  export type ContestParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ContestParticipants to fetch.
     */
    where?: ContestParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestParticipants to fetch.
     */
    orderBy?: ContestParticipantOrderByWithRelationInput | ContestParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContestParticipants.
     */
    cursor?: ContestParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestParticipants.
     */
    skip?: number
    distinct?: ContestParticipantScalarFieldEnum | ContestParticipantScalarFieldEnum[]
  }

  /**
   * ContestParticipant create
   */
  export type ContestParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a ContestParticipant.
     */
    data: XOR<ContestParticipantCreateInput, ContestParticipantUncheckedCreateInput>
  }

  /**
   * ContestParticipant createMany
   */
  export type ContestParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContestParticipants.
     */
    data: ContestParticipantCreateManyInput | ContestParticipantCreateManyInput[]
  }

  /**
   * ContestParticipant update
   */
  export type ContestParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a ContestParticipant.
     */
    data: XOR<ContestParticipantUpdateInput, ContestParticipantUncheckedUpdateInput>
    /**
     * Choose, which ContestParticipant to update.
     */
    where: ContestParticipantWhereUniqueInput
  }

  /**
   * ContestParticipant updateMany
   */
  export type ContestParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContestParticipants.
     */
    data: XOR<ContestParticipantUpdateManyMutationInput, ContestParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ContestParticipants to update
     */
    where?: ContestParticipantWhereInput
    /**
     * Limit how many ContestParticipants to update.
     */
    limit?: number
  }

  /**
   * ContestParticipant upsert
   */
  export type ContestParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the ContestParticipant to update in case it exists.
     */
    where: ContestParticipantWhereUniqueInput
    /**
     * In case the ContestParticipant found by the `where` argument doesn't exist, create a new ContestParticipant with this data.
     */
    create: XOR<ContestParticipantCreateInput, ContestParticipantUncheckedCreateInput>
    /**
     * In case the ContestParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContestParticipantUpdateInput, ContestParticipantUncheckedUpdateInput>
  }

  /**
   * ContestParticipant delete
   */
  export type ContestParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    /**
     * Filter which ContestParticipant to delete.
     */
    where: ContestParticipantWhereUniqueInput
  }

  /**
   * ContestParticipant deleteMany
   */
  export type ContestParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestParticipants to delete
     */
    where?: ContestParticipantWhereInput
    /**
     * Limit how many ContestParticipants to delete.
     */
    limit?: number
  }

  /**
   * ContestParticipant findRaw
   */
  export type ContestParticipantFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestParticipant aggregateRaw
   */
  export type ContestParticipantAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestParticipant.member
   */
  export type ContestParticipant$memberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
  }

  /**
   * ContestParticipant.photos
   */
  export type ContestParticipant$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    where?: ContestPhotoWhereInput
    orderBy?: ContestPhotoOrderByWithRelationInput | ContestPhotoOrderByWithRelationInput[]
    cursor?: ContestPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestPhotoScalarFieldEnum | ContestPhotoScalarFieldEnum[]
  }

  /**
   * ContestParticipant.ContestWinner
   */
  export type ContestParticipant$ContestWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    where?: ContestWinnerWhereInput
    orderBy?: ContestWinnerOrderByWithRelationInput | ContestWinnerOrderByWithRelationInput[]
    cursor?: ContestWinnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestWinnerScalarFieldEnum | ContestWinnerScalarFieldEnum[]
  }

  /**
   * ContestParticipant.contestAchievement
   */
  export type ContestParticipant$contestAchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    where?: ContestAchievementWhereInput
    orderBy?: ContestAchievementOrderByWithRelationInput | ContestAchievementOrderByWithRelationInput[]
    cursor?: ContestAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestAchievementScalarFieldEnum | ContestAchievementScalarFieldEnum[]
  }

  /**
   * ContestParticipant without action
   */
  export type ContestParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
  }


  /**
   * Model ContestPrize
   */

  export type AggregateContestPrize = {
    _count: ContestPrizeCountAggregateOutputType | null
    _avg: ContestPrizeAvgAggregateOutputType | null
    _sum: ContestPrizeSumAggregateOutputType | null
    _min: ContestPrizeMinAggregateOutputType | null
    _max: ContestPrizeMaxAggregateOutputType | null
  }

  export type ContestPrizeAvgAggregateOutputType = {
    trades: number | null
    charges: number | null
    keys: number | null
  }

  export type ContestPrizeSumAggregateOutputType = {
    trades: number | null
    charges: number | null
    keys: number | null
  }

  export type ContestPrizeMinAggregateOutputType = {
    id: string | null
    category: $Enums.PrizeType | null
    trades: number | null
    charges: number | null
    keys: number | null
    contestId: string | null
  }

  export type ContestPrizeMaxAggregateOutputType = {
    id: string | null
    category: $Enums.PrizeType | null
    trades: number | null
    charges: number | null
    keys: number | null
    contestId: string | null
  }

  export type ContestPrizeCountAggregateOutputType = {
    id: number
    category: number
    trades: number
    charges: number
    keys: number
    contestId: number
    _all: number
  }


  export type ContestPrizeAvgAggregateInputType = {
    trades?: true
    charges?: true
    keys?: true
  }

  export type ContestPrizeSumAggregateInputType = {
    trades?: true
    charges?: true
    keys?: true
  }

  export type ContestPrizeMinAggregateInputType = {
    id?: true
    category?: true
    trades?: true
    charges?: true
    keys?: true
    contestId?: true
  }

  export type ContestPrizeMaxAggregateInputType = {
    id?: true
    category?: true
    trades?: true
    charges?: true
    keys?: true
    contestId?: true
  }

  export type ContestPrizeCountAggregateInputType = {
    id?: true
    category?: true
    trades?: true
    charges?: true
    keys?: true
    contestId?: true
    _all?: true
  }

  export type ContestPrizeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestPrize to aggregate.
     */
    where?: ContestPrizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestPrizes to fetch.
     */
    orderBy?: ContestPrizeOrderByWithRelationInput | ContestPrizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContestPrizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestPrizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestPrizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContestPrizes
    **/
    _count?: true | ContestPrizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContestPrizeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContestPrizeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestPrizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestPrizeMaxAggregateInputType
  }

  export type GetContestPrizeAggregateType<T extends ContestPrizeAggregateArgs> = {
        [P in keyof T & keyof AggregateContestPrize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContestPrize[P]>
      : GetScalarType<T[P], AggregateContestPrize[P]>
  }




  export type ContestPrizeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestPrizeWhereInput
    orderBy?: ContestPrizeOrderByWithAggregationInput | ContestPrizeOrderByWithAggregationInput[]
    by: ContestPrizeScalarFieldEnum[] | ContestPrizeScalarFieldEnum
    having?: ContestPrizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestPrizeCountAggregateInputType | true
    _avg?: ContestPrizeAvgAggregateInputType
    _sum?: ContestPrizeSumAggregateInputType
    _min?: ContestPrizeMinAggregateInputType
    _max?: ContestPrizeMaxAggregateInputType
  }

  export type ContestPrizeGroupByOutputType = {
    id: string
    category: $Enums.PrizeType
    trades: number
    charges: number
    keys: number
    contestId: string
    _count: ContestPrizeCountAggregateOutputType | null
    _avg: ContestPrizeAvgAggregateOutputType | null
    _sum: ContestPrizeSumAggregateOutputType | null
    _min: ContestPrizeMinAggregateOutputType | null
    _max: ContestPrizeMaxAggregateOutputType | null
  }

  type GetContestPrizeGroupByPayload<T extends ContestPrizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestPrizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestPrizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestPrizeGroupByOutputType[P]>
            : GetScalarType<T[P], ContestPrizeGroupByOutputType[P]>
        }
      >
    >


  export type ContestPrizeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    trades?: boolean
    charges?: boolean
    keys?: boolean
    contestId?: boolean
    contest?: boolean | ContestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contestPrize"]>



  export type ContestPrizeSelectScalar = {
    id?: boolean
    category?: boolean
    trades?: boolean
    charges?: boolean
    keys?: boolean
    contestId?: boolean
  }

  export type ContestPrizeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category" | "trades" | "charges" | "keys" | "contestId", ExtArgs["result"]["contestPrize"]>
  export type ContestPrizeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contest?: boolean | ContestDefaultArgs<ExtArgs>
  }

  export type $ContestPrizePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContestPrize"
    objects: {
      contest: Prisma.$ContestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: $Enums.PrizeType
      trades: number
      charges: number
      keys: number
      contestId: string
    }, ExtArgs["result"]["contestPrize"]>
    composites: {}
  }

  type ContestPrizeGetPayload<S extends boolean | null | undefined | ContestPrizeDefaultArgs> = $Result.GetResult<Prisma.$ContestPrizePayload, S>

  type ContestPrizeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContestPrizeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContestPrizeCountAggregateInputType | true
    }

  export interface ContestPrizeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContestPrize'], meta: { name: 'ContestPrize' } }
    /**
     * Find zero or one ContestPrize that matches the filter.
     * @param {ContestPrizeFindUniqueArgs} args - Arguments to find a ContestPrize
     * @example
     * // Get one ContestPrize
     * const contestPrize = await prisma.contestPrize.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContestPrizeFindUniqueArgs>(args: SelectSubset<T, ContestPrizeFindUniqueArgs<ExtArgs>>): Prisma__ContestPrizeClient<$Result.GetResult<Prisma.$ContestPrizePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContestPrize that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContestPrizeFindUniqueOrThrowArgs} args - Arguments to find a ContestPrize
     * @example
     * // Get one ContestPrize
     * const contestPrize = await prisma.contestPrize.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContestPrizeFindUniqueOrThrowArgs>(args: SelectSubset<T, ContestPrizeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContestPrizeClient<$Result.GetResult<Prisma.$ContestPrizePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestPrize that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPrizeFindFirstArgs} args - Arguments to find a ContestPrize
     * @example
     * // Get one ContestPrize
     * const contestPrize = await prisma.contestPrize.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContestPrizeFindFirstArgs>(args?: SelectSubset<T, ContestPrizeFindFirstArgs<ExtArgs>>): Prisma__ContestPrizeClient<$Result.GetResult<Prisma.$ContestPrizePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestPrize that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPrizeFindFirstOrThrowArgs} args - Arguments to find a ContestPrize
     * @example
     * // Get one ContestPrize
     * const contestPrize = await prisma.contestPrize.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContestPrizeFindFirstOrThrowArgs>(args?: SelectSubset<T, ContestPrizeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContestPrizeClient<$Result.GetResult<Prisma.$ContestPrizePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestPrizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPrizeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContestPrizes
     * const contestPrizes = await prisma.contestPrize.findMany()
     * 
     * // Get first 10 ContestPrizes
     * const contestPrizes = await prisma.contestPrize.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contestPrizeWithIdOnly = await prisma.contestPrize.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContestPrizeFindManyArgs>(args?: SelectSubset<T, ContestPrizeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestPrizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContestPrize.
     * @param {ContestPrizeCreateArgs} args - Arguments to create a ContestPrize.
     * @example
     * // Create one ContestPrize
     * const ContestPrize = await prisma.contestPrize.create({
     *   data: {
     *     // ... data to create a ContestPrize
     *   }
     * })
     * 
     */
    create<T extends ContestPrizeCreateArgs>(args: SelectSubset<T, ContestPrizeCreateArgs<ExtArgs>>): Prisma__ContestPrizeClient<$Result.GetResult<Prisma.$ContestPrizePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContestPrizes.
     * @param {ContestPrizeCreateManyArgs} args - Arguments to create many ContestPrizes.
     * @example
     * // Create many ContestPrizes
     * const contestPrize = await prisma.contestPrize.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContestPrizeCreateManyArgs>(args?: SelectSubset<T, ContestPrizeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContestPrize.
     * @param {ContestPrizeDeleteArgs} args - Arguments to delete one ContestPrize.
     * @example
     * // Delete one ContestPrize
     * const ContestPrize = await prisma.contestPrize.delete({
     *   where: {
     *     // ... filter to delete one ContestPrize
     *   }
     * })
     * 
     */
    delete<T extends ContestPrizeDeleteArgs>(args: SelectSubset<T, ContestPrizeDeleteArgs<ExtArgs>>): Prisma__ContestPrizeClient<$Result.GetResult<Prisma.$ContestPrizePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContestPrize.
     * @param {ContestPrizeUpdateArgs} args - Arguments to update one ContestPrize.
     * @example
     * // Update one ContestPrize
     * const contestPrize = await prisma.contestPrize.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContestPrizeUpdateArgs>(args: SelectSubset<T, ContestPrizeUpdateArgs<ExtArgs>>): Prisma__ContestPrizeClient<$Result.GetResult<Prisma.$ContestPrizePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContestPrizes.
     * @param {ContestPrizeDeleteManyArgs} args - Arguments to filter ContestPrizes to delete.
     * @example
     * // Delete a few ContestPrizes
     * const { count } = await prisma.contestPrize.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContestPrizeDeleteManyArgs>(args?: SelectSubset<T, ContestPrizeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContestPrizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPrizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContestPrizes
     * const contestPrize = await prisma.contestPrize.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContestPrizeUpdateManyArgs>(args: SelectSubset<T, ContestPrizeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContestPrize.
     * @param {ContestPrizeUpsertArgs} args - Arguments to update or create a ContestPrize.
     * @example
     * // Update or create a ContestPrize
     * const contestPrize = await prisma.contestPrize.upsert({
     *   create: {
     *     // ... data to create a ContestPrize
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContestPrize we want to update
     *   }
     * })
     */
    upsert<T extends ContestPrizeUpsertArgs>(args: SelectSubset<T, ContestPrizeUpsertArgs<ExtArgs>>): Prisma__ContestPrizeClient<$Result.GetResult<Prisma.$ContestPrizePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestPrizes that matches the filter.
     * @param {ContestPrizeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contestPrize = await prisma.contestPrize.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ContestPrizeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ContestPrize.
     * @param {ContestPrizeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contestPrize = await prisma.contestPrize.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ContestPrizeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ContestPrizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPrizeCountArgs} args - Arguments to filter ContestPrizes to count.
     * @example
     * // Count the number of ContestPrizes
     * const count = await prisma.contestPrize.count({
     *   where: {
     *     // ... the filter for the ContestPrizes we want to count
     *   }
     * })
    **/
    count<T extends ContestPrizeCountArgs>(
      args?: Subset<T, ContestPrizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestPrizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContestPrize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPrizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestPrizeAggregateArgs>(args: Subset<T, ContestPrizeAggregateArgs>): Prisma.PrismaPromise<GetContestPrizeAggregateType<T>>

    /**
     * Group by ContestPrize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPrizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContestPrizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContestPrizeGroupByArgs['orderBy'] }
        : { orderBy?: ContestPrizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContestPrizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestPrizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContestPrize model
   */
  readonly fields: ContestPrizeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContestPrize.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContestPrizeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contest<T extends ContestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestDefaultArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContestPrize model
   */
  interface ContestPrizeFieldRefs {
    readonly id: FieldRef<"ContestPrize", 'String'>
    readonly category: FieldRef<"ContestPrize", 'PrizeType'>
    readonly trades: FieldRef<"ContestPrize", 'Int'>
    readonly charges: FieldRef<"ContestPrize", 'Int'>
    readonly keys: FieldRef<"ContestPrize", 'Int'>
    readonly contestId: FieldRef<"ContestPrize", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContestPrize findUnique
   */
  export type ContestPrizeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
    /**
     * Filter, which ContestPrize to fetch.
     */
    where: ContestPrizeWhereUniqueInput
  }

  /**
   * ContestPrize findUniqueOrThrow
   */
  export type ContestPrizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
    /**
     * Filter, which ContestPrize to fetch.
     */
    where: ContestPrizeWhereUniqueInput
  }

  /**
   * ContestPrize findFirst
   */
  export type ContestPrizeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
    /**
     * Filter, which ContestPrize to fetch.
     */
    where?: ContestPrizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestPrizes to fetch.
     */
    orderBy?: ContestPrizeOrderByWithRelationInput | ContestPrizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestPrizes.
     */
    cursor?: ContestPrizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestPrizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestPrizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestPrizes.
     */
    distinct?: ContestPrizeScalarFieldEnum | ContestPrizeScalarFieldEnum[]
  }

  /**
   * ContestPrize findFirstOrThrow
   */
  export type ContestPrizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
    /**
     * Filter, which ContestPrize to fetch.
     */
    where?: ContestPrizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestPrizes to fetch.
     */
    orderBy?: ContestPrizeOrderByWithRelationInput | ContestPrizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestPrizes.
     */
    cursor?: ContestPrizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestPrizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestPrizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestPrizes.
     */
    distinct?: ContestPrizeScalarFieldEnum | ContestPrizeScalarFieldEnum[]
  }

  /**
   * ContestPrize findMany
   */
  export type ContestPrizeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
    /**
     * Filter, which ContestPrizes to fetch.
     */
    where?: ContestPrizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestPrizes to fetch.
     */
    orderBy?: ContestPrizeOrderByWithRelationInput | ContestPrizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContestPrizes.
     */
    cursor?: ContestPrizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestPrizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestPrizes.
     */
    skip?: number
    distinct?: ContestPrizeScalarFieldEnum | ContestPrizeScalarFieldEnum[]
  }

  /**
   * ContestPrize create
   */
  export type ContestPrizeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
    /**
     * The data needed to create a ContestPrize.
     */
    data: XOR<ContestPrizeCreateInput, ContestPrizeUncheckedCreateInput>
  }

  /**
   * ContestPrize createMany
   */
  export type ContestPrizeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContestPrizes.
     */
    data: ContestPrizeCreateManyInput | ContestPrizeCreateManyInput[]
  }

  /**
   * ContestPrize update
   */
  export type ContestPrizeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
    /**
     * The data needed to update a ContestPrize.
     */
    data: XOR<ContestPrizeUpdateInput, ContestPrizeUncheckedUpdateInput>
    /**
     * Choose, which ContestPrize to update.
     */
    where: ContestPrizeWhereUniqueInput
  }

  /**
   * ContestPrize updateMany
   */
  export type ContestPrizeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContestPrizes.
     */
    data: XOR<ContestPrizeUpdateManyMutationInput, ContestPrizeUncheckedUpdateManyInput>
    /**
     * Filter which ContestPrizes to update
     */
    where?: ContestPrizeWhereInput
    /**
     * Limit how many ContestPrizes to update.
     */
    limit?: number
  }

  /**
   * ContestPrize upsert
   */
  export type ContestPrizeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
    /**
     * The filter to search for the ContestPrize to update in case it exists.
     */
    where: ContestPrizeWhereUniqueInput
    /**
     * In case the ContestPrize found by the `where` argument doesn't exist, create a new ContestPrize with this data.
     */
    create: XOR<ContestPrizeCreateInput, ContestPrizeUncheckedCreateInput>
    /**
     * In case the ContestPrize was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContestPrizeUpdateInput, ContestPrizeUncheckedUpdateInput>
  }

  /**
   * ContestPrize delete
   */
  export type ContestPrizeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
    /**
     * Filter which ContestPrize to delete.
     */
    where: ContestPrizeWhereUniqueInput
  }

  /**
   * ContestPrize deleteMany
   */
  export type ContestPrizeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestPrizes to delete
     */
    where?: ContestPrizeWhereInput
    /**
     * Limit how many ContestPrizes to delete.
     */
    limit?: number
  }

  /**
   * ContestPrize findRaw
   */
  export type ContestPrizeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestPrize aggregateRaw
   */
  export type ContestPrizeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestPrize without action
   */
  export type ContestPrizeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
  }


  /**
   * Model ContestAchievement
   */

  export type AggregateContestAchievement = {
    _count: ContestAchievementCountAggregateOutputType | null
    _min: ContestAchievementMinAggregateOutputType | null
    _max: ContestAchievementMaxAggregateOutputType | null
  }

  export type ContestAchievementMinAggregateOutputType = {
    id: string | null
    category: $Enums.PrizeType | null
    photoId: string | null
    participantId: string | null
    contestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestAchievementMaxAggregateOutputType = {
    id: string | null
    category: $Enums.PrizeType | null
    photoId: string | null
    participantId: string | null
    contestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestAchievementCountAggregateOutputType = {
    id: number
    category: number
    photoId: number
    participantId: number
    contestId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContestAchievementMinAggregateInputType = {
    id?: true
    category?: true
    photoId?: true
    participantId?: true
    contestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestAchievementMaxAggregateInputType = {
    id?: true
    category?: true
    photoId?: true
    participantId?: true
    contestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestAchievementCountAggregateInputType = {
    id?: true
    category?: true
    photoId?: true
    participantId?: true
    contestId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContestAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestAchievement to aggregate.
     */
    where?: ContestAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestAchievements to fetch.
     */
    orderBy?: ContestAchievementOrderByWithRelationInput | ContestAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContestAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContestAchievements
    **/
    _count?: true | ContestAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestAchievementMaxAggregateInputType
  }

  export type GetContestAchievementAggregateType<T extends ContestAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateContestAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContestAchievement[P]>
      : GetScalarType<T[P], AggregateContestAchievement[P]>
  }




  export type ContestAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestAchievementWhereInput
    orderBy?: ContestAchievementOrderByWithAggregationInput | ContestAchievementOrderByWithAggregationInput[]
    by: ContestAchievementScalarFieldEnum[] | ContestAchievementScalarFieldEnum
    having?: ContestAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestAchievementCountAggregateInputType | true
    _min?: ContestAchievementMinAggregateInputType
    _max?: ContestAchievementMaxAggregateInputType
  }

  export type ContestAchievementGroupByOutputType = {
    id: string
    category: $Enums.PrizeType
    photoId: string | null
    participantId: string | null
    contestId: string
    createdAt: Date
    updatedAt: Date
    _count: ContestAchievementCountAggregateOutputType | null
    _min: ContestAchievementMinAggregateOutputType | null
    _max: ContestAchievementMaxAggregateOutputType | null
  }

  type GetContestAchievementGroupByPayload<T extends ContestAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], ContestAchievementGroupByOutputType[P]>
        }
      >
    >


  export type ContestAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    photoId?: boolean
    participantId?: boolean
    contestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    photo?: boolean | ContestAchievement$photoArgs<ExtArgs>
    contest?: boolean | ContestDefaultArgs<ExtArgs>
    participant?: boolean | ContestAchievement$participantArgs<ExtArgs>
  }, ExtArgs["result"]["contestAchievement"]>



  export type ContestAchievementSelectScalar = {
    id?: boolean
    category?: boolean
    photoId?: boolean
    participantId?: boolean
    contestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContestAchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category" | "photoId" | "participantId" | "contestId" | "createdAt" | "updatedAt", ExtArgs["result"]["contestAchievement"]>
  export type ContestAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photo?: boolean | ContestAchievement$photoArgs<ExtArgs>
    contest?: boolean | ContestDefaultArgs<ExtArgs>
    participant?: boolean | ContestAchievement$participantArgs<ExtArgs>
  }

  export type $ContestAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContestAchievement"
    objects: {
      photo: Prisma.$ContestPhotoPayload<ExtArgs> | null
      contest: Prisma.$ContestPayload<ExtArgs>
      participant: Prisma.$ContestParticipantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: $Enums.PrizeType
      photoId: string | null
      participantId: string | null
      contestId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contestAchievement"]>
    composites: {}
  }

  type ContestAchievementGetPayload<S extends boolean | null | undefined | ContestAchievementDefaultArgs> = $Result.GetResult<Prisma.$ContestAchievementPayload, S>

  type ContestAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContestAchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContestAchievementCountAggregateInputType | true
    }

  export interface ContestAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContestAchievement'], meta: { name: 'ContestAchievement' } }
    /**
     * Find zero or one ContestAchievement that matches the filter.
     * @param {ContestAchievementFindUniqueArgs} args - Arguments to find a ContestAchievement
     * @example
     * // Get one ContestAchievement
     * const contestAchievement = await prisma.contestAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContestAchievementFindUniqueArgs>(args: SelectSubset<T, ContestAchievementFindUniqueArgs<ExtArgs>>): Prisma__ContestAchievementClient<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContestAchievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContestAchievementFindUniqueOrThrowArgs} args - Arguments to find a ContestAchievement
     * @example
     * // Get one ContestAchievement
     * const contestAchievement = await prisma.contestAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContestAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, ContestAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContestAchievementClient<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAchievementFindFirstArgs} args - Arguments to find a ContestAchievement
     * @example
     * // Get one ContestAchievement
     * const contestAchievement = await prisma.contestAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContestAchievementFindFirstArgs>(args?: SelectSubset<T, ContestAchievementFindFirstArgs<ExtArgs>>): Prisma__ContestAchievementClient<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAchievementFindFirstOrThrowArgs} args - Arguments to find a ContestAchievement
     * @example
     * // Get one ContestAchievement
     * const contestAchievement = await prisma.contestAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContestAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, ContestAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContestAchievementClient<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContestAchievements
     * const contestAchievements = await prisma.contestAchievement.findMany()
     * 
     * // Get first 10 ContestAchievements
     * const contestAchievements = await prisma.contestAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contestAchievementWithIdOnly = await prisma.contestAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContestAchievementFindManyArgs>(args?: SelectSubset<T, ContestAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContestAchievement.
     * @param {ContestAchievementCreateArgs} args - Arguments to create a ContestAchievement.
     * @example
     * // Create one ContestAchievement
     * const ContestAchievement = await prisma.contestAchievement.create({
     *   data: {
     *     // ... data to create a ContestAchievement
     *   }
     * })
     * 
     */
    create<T extends ContestAchievementCreateArgs>(args: SelectSubset<T, ContestAchievementCreateArgs<ExtArgs>>): Prisma__ContestAchievementClient<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContestAchievements.
     * @param {ContestAchievementCreateManyArgs} args - Arguments to create many ContestAchievements.
     * @example
     * // Create many ContestAchievements
     * const contestAchievement = await prisma.contestAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContestAchievementCreateManyArgs>(args?: SelectSubset<T, ContestAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContestAchievement.
     * @param {ContestAchievementDeleteArgs} args - Arguments to delete one ContestAchievement.
     * @example
     * // Delete one ContestAchievement
     * const ContestAchievement = await prisma.contestAchievement.delete({
     *   where: {
     *     // ... filter to delete one ContestAchievement
     *   }
     * })
     * 
     */
    delete<T extends ContestAchievementDeleteArgs>(args: SelectSubset<T, ContestAchievementDeleteArgs<ExtArgs>>): Prisma__ContestAchievementClient<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContestAchievement.
     * @param {ContestAchievementUpdateArgs} args - Arguments to update one ContestAchievement.
     * @example
     * // Update one ContestAchievement
     * const contestAchievement = await prisma.contestAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContestAchievementUpdateArgs>(args: SelectSubset<T, ContestAchievementUpdateArgs<ExtArgs>>): Prisma__ContestAchievementClient<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContestAchievements.
     * @param {ContestAchievementDeleteManyArgs} args - Arguments to filter ContestAchievements to delete.
     * @example
     * // Delete a few ContestAchievements
     * const { count } = await prisma.contestAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContestAchievementDeleteManyArgs>(args?: SelectSubset<T, ContestAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContestAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContestAchievements
     * const contestAchievement = await prisma.contestAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContestAchievementUpdateManyArgs>(args: SelectSubset<T, ContestAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContestAchievement.
     * @param {ContestAchievementUpsertArgs} args - Arguments to update or create a ContestAchievement.
     * @example
     * // Update or create a ContestAchievement
     * const contestAchievement = await prisma.contestAchievement.upsert({
     *   create: {
     *     // ... data to create a ContestAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContestAchievement we want to update
     *   }
     * })
     */
    upsert<T extends ContestAchievementUpsertArgs>(args: SelectSubset<T, ContestAchievementUpsertArgs<ExtArgs>>): Prisma__ContestAchievementClient<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestAchievements that matches the filter.
     * @param {ContestAchievementFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contestAchievement = await prisma.contestAchievement.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ContestAchievementFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ContestAchievement.
     * @param {ContestAchievementAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contestAchievement = await prisma.contestAchievement.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ContestAchievementAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ContestAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAchievementCountArgs} args - Arguments to filter ContestAchievements to count.
     * @example
     * // Count the number of ContestAchievements
     * const count = await prisma.contestAchievement.count({
     *   where: {
     *     // ... the filter for the ContestAchievements we want to count
     *   }
     * })
    **/
    count<T extends ContestAchievementCountArgs>(
      args?: Subset<T, ContestAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContestAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestAchievementAggregateArgs>(args: Subset<T, ContestAchievementAggregateArgs>): Prisma.PrismaPromise<GetContestAchievementAggregateType<T>>

    /**
     * Group by ContestAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContestAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContestAchievementGroupByArgs['orderBy'] }
        : { orderBy?: ContestAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContestAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContestAchievement model
   */
  readonly fields: ContestAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContestAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContestAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photo<T extends ContestAchievement$photoArgs<ExtArgs> = {}>(args?: Subset<T, ContestAchievement$photoArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contest<T extends ContestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestDefaultArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participant<T extends ContestAchievement$participantArgs<ExtArgs> = {}>(args?: Subset<T, ContestAchievement$participantArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContestAchievement model
   */
  interface ContestAchievementFieldRefs {
    readonly id: FieldRef<"ContestAchievement", 'String'>
    readonly category: FieldRef<"ContestAchievement", 'PrizeType'>
    readonly photoId: FieldRef<"ContestAchievement", 'String'>
    readonly participantId: FieldRef<"ContestAchievement", 'String'>
    readonly contestId: FieldRef<"ContestAchievement", 'String'>
    readonly createdAt: FieldRef<"ContestAchievement", 'DateTime'>
    readonly updatedAt: FieldRef<"ContestAchievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContestAchievement findUnique
   */
  export type ContestAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    /**
     * Filter, which ContestAchievement to fetch.
     */
    where: ContestAchievementWhereUniqueInput
  }

  /**
   * ContestAchievement findUniqueOrThrow
   */
  export type ContestAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    /**
     * Filter, which ContestAchievement to fetch.
     */
    where: ContestAchievementWhereUniqueInput
  }

  /**
   * ContestAchievement findFirst
   */
  export type ContestAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    /**
     * Filter, which ContestAchievement to fetch.
     */
    where?: ContestAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestAchievements to fetch.
     */
    orderBy?: ContestAchievementOrderByWithRelationInput | ContestAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestAchievements.
     */
    cursor?: ContestAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestAchievements.
     */
    distinct?: ContestAchievementScalarFieldEnum | ContestAchievementScalarFieldEnum[]
  }

  /**
   * ContestAchievement findFirstOrThrow
   */
  export type ContestAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    /**
     * Filter, which ContestAchievement to fetch.
     */
    where?: ContestAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestAchievements to fetch.
     */
    orderBy?: ContestAchievementOrderByWithRelationInput | ContestAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestAchievements.
     */
    cursor?: ContestAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestAchievements.
     */
    distinct?: ContestAchievementScalarFieldEnum | ContestAchievementScalarFieldEnum[]
  }

  /**
   * ContestAchievement findMany
   */
  export type ContestAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    /**
     * Filter, which ContestAchievements to fetch.
     */
    where?: ContestAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestAchievements to fetch.
     */
    orderBy?: ContestAchievementOrderByWithRelationInput | ContestAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContestAchievements.
     */
    cursor?: ContestAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestAchievements.
     */
    skip?: number
    distinct?: ContestAchievementScalarFieldEnum | ContestAchievementScalarFieldEnum[]
  }

  /**
   * ContestAchievement create
   */
  export type ContestAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a ContestAchievement.
     */
    data: XOR<ContestAchievementCreateInput, ContestAchievementUncheckedCreateInput>
  }

  /**
   * ContestAchievement createMany
   */
  export type ContestAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContestAchievements.
     */
    data: ContestAchievementCreateManyInput | ContestAchievementCreateManyInput[]
  }

  /**
   * ContestAchievement update
   */
  export type ContestAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a ContestAchievement.
     */
    data: XOR<ContestAchievementUpdateInput, ContestAchievementUncheckedUpdateInput>
    /**
     * Choose, which ContestAchievement to update.
     */
    where: ContestAchievementWhereUniqueInput
  }

  /**
   * ContestAchievement updateMany
   */
  export type ContestAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContestAchievements.
     */
    data: XOR<ContestAchievementUpdateManyMutationInput, ContestAchievementUncheckedUpdateManyInput>
    /**
     * Filter which ContestAchievements to update
     */
    where?: ContestAchievementWhereInput
    /**
     * Limit how many ContestAchievements to update.
     */
    limit?: number
  }

  /**
   * ContestAchievement upsert
   */
  export type ContestAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the ContestAchievement to update in case it exists.
     */
    where: ContestAchievementWhereUniqueInput
    /**
     * In case the ContestAchievement found by the `where` argument doesn't exist, create a new ContestAchievement with this data.
     */
    create: XOR<ContestAchievementCreateInput, ContestAchievementUncheckedCreateInput>
    /**
     * In case the ContestAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContestAchievementUpdateInput, ContestAchievementUncheckedUpdateInput>
  }

  /**
   * ContestAchievement delete
   */
  export type ContestAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    /**
     * Filter which ContestAchievement to delete.
     */
    where: ContestAchievementWhereUniqueInput
  }

  /**
   * ContestAchievement deleteMany
   */
  export type ContestAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestAchievements to delete
     */
    where?: ContestAchievementWhereInput
    /**
     * Limit how many ContestAchievements to delete.
     */
    limit?: number
  }

  /**
   * ContestAchievement findRaw
   */
  export type ContestAchievementFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestAchievement aggregateRaw
   */
  export type ContestAchievementAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestAchievement.photo
   */
  export type ContestAchievement$photoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    where?: ContestPhotoWhereInput
  }

  /**
   * ContestAchievement.participant
   */
  export type ContestAchievement$participantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    where?: ContestParticipantWhereInput
  }

  /**
   * ContestAchievement without action
   */
  export type ContestAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    isSent: boolean | null
    isRead: boolean | null
    receiverId: string | null
    createdAt: Date | null
    updatedAT: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    isSent: boolean | null
    isRead: boolean | null
    receiverId: string | null
    createdAt: Date | null
    updatedAT: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    message: number
    isSent: number
    isRead: number
    receiverId: number
    createdAt: number
    updatedAT: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    message?: true
    isSent?: true
    isRead?: true
    receiverId?: true
    createdAt?: true
    updatedAT?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    message?: true
    isSent?: true
    isRead?: true
    receiverId?: true
    createdAt?: true
    updatedAT?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    message?: true
    isSent?: true
    isRead?: true
    receiverId?: true
    createdAt?: true
    updatedAT?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    title: string
    message: string
    isSent: boolean
    isRead: boolean
    receiverId: string
    createdAt: Date
    updatedAT: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    isSent?: boolean
    isRead?: boolean
    receiverId?: boolean
    createdAt?: boolean
    updatedAT?: boolean
  }, ExtArgs["result"]["notification"]>



  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    message?: boolean
    isSent?: boolean
    isRead?: boolean
    receiverId?: boolean
    createdAt?: boolean
    updatedAT?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "message" | "isSent" | "isRead" | "receiverId" | "createdAt" | "updatedAT", ExtArgs["result"]["notification"]>

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      message: string
      isSent: boolean
      isRead: boolean
      receiverId: string
      createdAt: Date
      updatedAT: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * @param {NotificationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const notification = await prisma.notification.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: NotificationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Notification.
     * @param {NotificationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const notification = await prisma.notification.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: NotificationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isSent: FieldRef<"Notification", 'Boolean'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly receiverId: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAT: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification findRaw
   */
  export type NotificationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Notification aggregateRaw
   */
  export type NotificationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    status: $Enums.PaymentStatus | null
    productId: string | null
    userId: string | null
    stripe_intent_id: string | null
    amount: number | null
    currency: string | null
    method: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    status: $Enums.PaymentStatus | null
    productId: string | null
    userId: string | null
    stripe_intent_id: string | null
    amount: number | null
    currency: string | null
    method: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    status: number
    productId: number
    userId: number
    stripe_intent_id: number
    amount: number
    currency: number
    method: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    status?: true
    productId?: true
    userId?: true
    stripe_intent_id?: true
    amount?: true
    currency?: true
    method?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    status?: true
    productId?: true
    userId?: true
    stripe_intent_id?: true
    amount?: true
    currency?: true
    method?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    status?: true
    productId?: true
    userId?: true
    stripe_intent_id?: true
    amount?: true
    currency?: true
    method?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    status: $Enums.PaymentStatus
    productId: string
    userId: string
    stripe_intent_id: string | null
    amount: number
    currency: string
    method: string
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    productId?: boolean
    userId?: boolean
    stripe_intent_id?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["payment"]>



  export type PaymentSelectScalar = {
    id?: boolean
    status?: boolean
    productId?: boolean
    userId?: boolean
    stripe_intent_id?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "productId" | "userId" | "stripe_intent_id" | "amount" | "currency" | "method" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.PaymentStatus
      productId: string
      userId: string
      stripe_intent_id: string | null
      amount: number
      currency: string
      method: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * @param {PaymentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const payment = await prisma.payment.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PaymentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Payment.
     * @param {PaymentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const payment = await prisma.payment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PaymentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly productId: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly stripe_intent_id: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly method: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment findRaw
   */
  export type PaymentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Payment aggregateRaw
   */
  export type PaymentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
  }


  /**
   * Model SitePolicy
   */

  export type AggregateSitePolicy = {
    _count: SitePolicyCountAggregateOutputType | null
    _min: SitePolicyMinAggregateOutputType | null
    _max: SitePolicyMaxAggregateOutputType | null
  }

  export type SitePolicyMinAggregateOutputType = {
    id: string | null
    type: $Enums.SitePolicyType | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SitePolicyMaxAggregateOutputType = {
    id: string | null
    type: $Enums.SitePolicyType | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SitePolicyCountAggregateOutputType = {
    id: number
    type: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SitePolicyMinAggregateInputType = {
    id?: true
    type?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SitePolicyMaxAggregateInputType = {
    id?: true
    type?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SitePolicyCountAggregateInputType = {
    id?: true
    type?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SitePolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SitePolicy to aggregate.
     */
    where?: SitePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SitePolicies to fetch.
     */
    orderBy?: SitePolicyOrderByWithRelationInput | SitePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SitePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SitePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SitePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SitePolicies
    **/
    _count?: true | SitePolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SitePolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SitePolicyMaxAggregateInputType
  }

  export type GetSitePolicyAggregateType<T extends SitePolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateSitePolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSitePolicy[P]>
      : GetScalarType<T[P], AggregateSitePolicy[P]>
  }




  export type SitePolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SitePolicyWhereInput
    orderBy?: SitePolicyOrderByWithAggregationInput | SitePolicyOrderByWithAggregationInput[]
    by: SitePolicyScalarFieldEnum[] | SitePolicyScalarFieldEnum
    having?: SitePolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SitePolicyCountAggregateInputType | true
    _min?: SitePolicyMinAggregateInputType
    _max?: SitePolicyMaxAggregateInputType
  }

  export type SitePolicyGroupByOutputType = {
    id: string
    type: $Enums.SitePolicyType
    content: string
    createdAt: Date
    updatedAt: Date
    _count: SitePolicyCountAggregateOutputType | null
    _min: SitePolicyMinAggregateOutputType | null
    _max: SitePolicyMaxAggregateOutputType | null
  }

  type GetSitePolicyGroupByPayload<T extends SitePolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SitePolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SitePolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SitePolicyGroupByOutputType[P]>
            : GetScalarType<T[P], SitePolicyGroupByOutputType[P]>
        }
      >
    >


  export type SitePolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sitePolicy"]>



  export type SitePolicySelectScalar = {
    id?: boolean
    type?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SitePolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["sitePolicy"]>

  export type $SitePolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SitePolicy"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.SitePolicyType
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sitePolicy"]>
    composites: {}
  }

  type SitePolicyGetPayload<S extends boolean | null | undefined | SitePolicyDefaultArgs> = $Result.GetResult<Prisma.$SitePolicyPayload, S>

  type SitePolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SitePolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SitePolicyCountAggregateInputType | true
    }

  export interface SitePolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SitePolicy'], meta: { name: 'SitePolicy' } }
    /**
     * Find zero or one SitePolicy that matches the filter.
     * @param {SitePolicyFindUniqueArgs} args - Arguments to find a SitePolicy
     * @example
     * // Get one SitePolicy
     * const sitePolicy = await prisma.sitePolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SitePolicyFindUniqueArgs>(args: SelectSubset<T, SitePolicyFindUniqueArgs<ExtArgs>>): Prisma__SitePolicyClient<$Result.GetResult<Prisma.$SitePolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SitePolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SitePolicyFindUniqueOrThrowArgs} args - Arguments to find a SitePolicy
     * @example
     * // Get one SitePolicy
     * const sitePolicy = await prisma.sitePolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SitePolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, SitePolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SitePolicyClient<$Result.GetResult<Prisma.$SitePolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SitePolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitePolicyFindFirstArgs} args - Arguments to find a SitePolicy
     * @example
     * // Get one SitePolicy
     * const sitePolicy = await prisma.sitePolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SitePolicyFindFirstArgs>(args?: SelectSubset<T, SitePolicyFindFirstArgs<ExtArgs>>): Prisma__SitePolicyClient<$Result.GetResult<Prisma.$SitePolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SitePolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitePolicyFindFirstOrThrowArgs} args - Arguments to find a SitePolicy
     * @example
     * // Get one SitePolicy
     * const sitePolicy = await prisma.sitePolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SitePolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, SitePolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SitePolicyClient<$Result.GetResult<Prisma.$SitePolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SitePolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitePolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SitePolicies
     * const sitePolicies = await prisma.sitePolicy.findMany()
     * 
     * // Get first 10 SitePolicies
     * const sitePolicies = await prisma.sitePolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sitePolicyWithIdOnly = await prisma.sitePolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SitePolicyFindManyArgs>(args?: SelectSubset<T, SitePolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitePolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SitePolicy.
     * @param {SitePolicyCreateArgs} args - Arguments to create a SitePolicy.
     * @example
     * // Create one SitePolicy
     * const SitePolicy = await prisma.sitePolicy.create({
     *   data: {
     *     // ... data to create a SitePolicy
     *   }
     * })
     * 
     */
    create<T extends SitePolicyCreateArgs>(args: SelectSubset<T, SitePolicyCreateArgs<ExtArgs>>): Prisma__SitePolicyClient<$Result.GetResult<Prisma.$SitePolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SitePolicies.
     * @param {SitePolicyCreateManyArgs} args - Arguments to create many SitePolicies.
     * @example
     * // Create many SitePolicies
     * const sitePolicy = await prisma.sitePolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SitePolicyCreateManyArgs>(args?: SelectSubset<T, SitePolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SitePolicy.
     * @param {SitePolicyDeleteArgs} args - Arguments to delete one SitePolicy.
     * @example
     * // Delete one SitePolicy
     * const SitePolicy = await prisma.sitePolicy.delete({
     *   where: {
     *     // ... filter to delete one SitePolicy
     *   }
     * })
     * 
     */
    delete<T extends SitePolicyDeleteArgs>(args: SelectSubset<T, SitePolicyDeleteArgs<ExtArgs>>): Prisma__SitePolicyClient<$Result.GetResult<Prisma.$SitePolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SitePolicy.
     * @param {SitePolicyUpdateArgs} args - Arguments to update one SitePolicy.
     * @example
     * // Update one SitePolicy
     * const sitePolicy = await prisma.sitePolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SitePolicyUpdateArgs>(args: SelectSubset<T, SitePolicyUpdateArgs<ExtArgs>>): Prisma__SitePolicyClient<$Result.GetResult<Prisma.$SitePolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SitePolicies.
     * @param {SitePolicyDeleteManyArgs} args - Arguments to filter SitePolicies to delete.
     * @example
     * // Delete a few SitePolicies
     * const { count } = await prisma.sitePolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SitePolicyDeleteManyArgs>(args?: SelectSubset<T, SitePolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SitePolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitePolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SitePolicies
     * const sitePolicy = await prisma.sitePolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SitePolicyUpdateManyArgs>(args: SelectSubset<T, SitePolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SitePolicy.
     * @param {SitePolicyUpsertArgs} args - Arguments to update or create a SitePolicy.
     * @example
     * // Update or create a SitePolicy
     * const sitePolicy = await prisma.sitePolicy.upsert({
     *   create: {
     *     // ... data to create a SitePolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SitePolicy we want to update
     *   }
     * })
     */
    upsert<T extends SitePolicyUpsertArgs>(args: SelectSubset<T, SitePolicyUpsertArgs<ExtArgs>>): Prisma__SitePolicyClient<$Result.GetResult<Prisma.$SitePolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SitePolicies that matches the filter.
     * @param {SitePolicyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const sitePolicy = await prisma.sitePolicy.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SitePolicyFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SitePolicy.
     * @param {SitePolicyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const sitePolicy = await prisma.sitePolicy.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SitePolicyAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SitePolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitePolicyCountArgs} args - Arguments to filter SitePolicies to count.
     * @example
     * // Count the number of SitePolicies
     * const count = await prisma.sitePolicy.count({
     *   where: {
     *     // ... the filter for the SitePolicies we want to count
     *   }
     * })
    **/
    count<T extends SitePolicyCountArgs>(
      args?: Subset<T, SitePolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SitePolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SitePolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitePolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SitePolicyAggregateArgs>(args: Subset<T, SitePolicyAggregateArgs>): Prisma.PrismaPromise<GetSitePolicyAggregateType<T>>

    /**
     * Group by SitePolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitePolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SitePolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SitePolicyGroupByArgs['orderBy'] }
        : { orderBy?: SitePolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SitePolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSitePolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SitePolicy model
   */
  readonly fields: SitePolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SitePolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SitePolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SitePolicy model
   */
  interface SitePolicyFieldRefs {
    readonly id: FieldRef<"SitePolicy", 'String'>
    readonly type: FieldRef<"SitePolicy", 'SitePolicyType'>
    readonly content: FieldRef<"SitePolicy", 'String'>
    readonly createdAt: FieldRef<"SitePolicy", 'DateTime'>
    readonly updatedAt: FieldRef<"SitePolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SitePolicy findUnique
   */
  export type SitePolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitePolicy
     */
    select?: SitePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitePolicy
     */
    omit?: SitePolicyOmit<ExtArgs> | null
    /**
     * Filter, which SitePolicy to fetch.
     */
    where: SitePolicyWhereUniqueInput
  }

  /**
   * SitePolicy findUniqueOrThrow
   */
  export type SitePolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitePolicy
     */
    select?: SitePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitePolicy
     */
    omit?: SitePolicyOmit<ExtArgs> | null
    /**
     * Filter, which SitePolicy to fetch.
     */
    where: SitePolicyWhereUniqueInput
  }

  /**
   * SitePolicy findFirst
   */
  export type SitePolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitePolicy
     */
    select?: SitePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitePolicy
     */
    omit?: SitePolicyOmit<ExtArgs> | null
    /**
     * Filter, which SitePolicy to fetch.
     */
    where?: SitePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SitePolicies to fetch.
     */
    orderBy?: SitePolicyOrderByWithRelationInput | SitePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SitePolicies.
     */
    cursor?: SitePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SitePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SitePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SitePolicies.
     */
    distinct?: SitePolicyScalarFieldEnum | SitePolicyScalarFieldEnum[]
  }

  /**
   * SitePolicy findFirstOrThrow
   */
  export type SitePolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitePolicy
     */
    select?: SitePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitePolicy
     */
    omit?: SitePolicyOmit<ExtArgs> | null
    /**
     * Filter, which SitePolicy to fetch.
     */
    where?: SitePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SitePolicies to fetch.
     */
    orderBy?: SitePolicyOrderByWithRelationInput | SitePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SitePolicies.
     */
    cursor?: SitePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SitePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SitePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SitePolicies.
     */
    distinct?: SitePolicyScalarFieldEnum | SitePolicyScalarFieldEnum[]
  }

  /**
   * SitePolicy findMany
   */
  export type SitePolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitePolicy
     */
    select?: SitePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitePolicy
     */
    omit?: SitePolicyOmit<ExtArgs> | null
    /**
     * Filter, which SitePolicies to fetch.
     */
    where?: SitePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SitePolicies to fetch.
     */
    orderBy?: SitePolicyOrderByWithRelationInput | SitePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SitePolicies.
     */
    cursor?: SitePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SitePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SitePolicies.
     */
    skip?: number
    distinct?: SitePolicyScalarFieldEnum | SitePolicyScalarFieldEnum[]
  }

  /**
   * SitePolicy create
   */
  export type SitePolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitePolicy
     */
    select?: SitePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitePolicy
     */
    omit?: SitePolicyOmit<ExtArgs> | null
    /**
     * The data needed to create a SitePolicy.
     */
    data: XOR<SitePolicyCreateInput, SitePolicyUncheckedCreateInput>
  }

  /**
   * SitePolicy createMany
   */
  export type SitePolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SitePolicies.
     */
    data: SitePolicyCreateManyInput | SitePolicyCreateManyInput[]
  }

  /**
   * SitePolicy update
   */
  export type SitePolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitePolicy
     */
    select?: SitePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitePolicy
     */
    omit?: SitePolicyOmit<ExtArgs> | null
    /**
     * The data needed to update a SitePolicy.
     */
    data: XOR<SitePolicyUpdateInput, SitePolicyUncheckedUpdateInput>
    /**
     * Choose, which SitePolicy to update.
     */
    where: SitePolicyWhereUniqueInput
  }

  /**
   * SitePolicy updateMany
   */
  export type SitePolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SitePolicies.
     */
    data: XOR<SitePolicyUpdateManyMutationInput, SitePolicyUncheckedUpdateManyInput>
    /**
     * Filter which SitePolicies to update
     */
    where?: SitePolicyWhereInput
    /**
     * Limit how many SitePolicies to update.
     */
    limit?: number
  }

  /**
   * SitePolicy upsert
   */
  export type SitePolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitePolicy
     */
    select?: SitePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitePolicy
     */
    omit?: SitePolicyOmit<ExtArgs> | null
    /**
     * The filter to search for the SitePolicy to update in case it exists.
     */
    where: SitePolicyWhereUniqueInput
    /**
     * In case the SitePolicy found by the `where` argument doesn't exist, create a new SitePolicy with this data.
     */
    create: XOR<SitePolicyCreateInput, SitePolicyUncheckedCreateInput>
    /**
     * In case the SitePolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SitePolicyUpdateInput, SitePolicyUncheckedUpdateInput>
  }

  /**
   * SitePolicy delete
   */
  export type SitePolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitePolicy
     */
    select?: SitePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitePolicy
     */
    omit?: SitePolicyOmit<ExtArgs> | null
    /**
     * Filter which SitePolicy to delete.
     */
    where: SitePolicyWhereUniqueInput
  }

  /**
   * SitePolicy deleteMany
   */
  export type SitePolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SitePolicies to delete
     */
    where?: SitePolicyWhereInput
    /**
     * Limit how many SitePolicies to delete.
     */
    limit?: number
  }

  /**
   * SitePolicy findRaw
   */
  export type SitePolicyFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SitePolicy aggregateRaw
   */
  export type SitePolicyAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SitePolicy without action
   */
  export type SitePolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitePolicy
     */
    select?: SitePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitePolicy
     */
    omit?: SitePolicyOmit<ExtArgs> | null
  }


  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomMinAggregateOutputType = {
    id: string | null
    teamId: string | null
  }

  export type RoomMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    teamId: number
    _all: number
  }


  export type RoomMinAggregateInputType = {
    id?: true
    teamId?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    teamId?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    teamId?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: string
    teamId: string
    _count: RoomCountAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
  }, ExtArgs["result"]["room"]>



  export type RoomSelectScalar = {
    id?: boolean
    teamId?: boolean
  }

  export type RoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId", ExtArgs["result"]["room"]>

  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomFindUniqueArgs>(args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomFindFirstArgs>(args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomFindManyArgs>(args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends RoomCreateArgs>(args: SelectSubset<T, RoomCreateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rooms.
     * @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomCreateManyArgs>(args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends RoomDeleteArgs>(args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomUpdateArgs>(args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomDeleteManyArgs>(args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomUpdateManyArgs>(args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends RoomUpsertArgs>(args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rooms that matches the filter.
     * @param {RoomFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const room = await prisma.room.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: RoomFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Room.
     * @param {RoomAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const room = await prisma.room.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: RoomAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Room model
   */
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'String'>
    readonly teamId: FieldRef<"Room", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }

  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
  }

  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to update.
     */
    limit?: number
  }

  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }

  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to delete.
     */
    limit?: number
  }

  /**
   * Room findRaw
   */
  export type RoomFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Room aggregateRaw
   */
  export type RoomAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
  }


  /**
   * Model Chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    senderId: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    senderId: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    teamId: number
    senderId: number
    message: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChatMinAggregateInputType = {
    id?: true
    teamId?: true
    senderId?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    teamId?: true
    senderId?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    teamId?: true
    senderId?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chat to aggregate.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type ChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithAggregationInput | ChatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: string
    teamId: string
    senderId: string
    message: string
    createdAt: Date
    updatedAt: Date
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type ChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    senderId?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>



  export type ChatSelectScalar = {
    id?: boolean
    teamId?: boolean
    senderId?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "senderId" | "message" | "createdAt" | "updatedAt", ExtArgs["result"]["chat"]>
  export type ChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chat"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      senderId: string
      message: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type ChatGetPayload<S extends boolean | null | undefined | ChatDefaultArgs> = $Result.GetResult<Prisma.$ChatPayload, S>

  type ChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface ChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chat'], meta: { name: 'Chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatFindUniqueArgs>(args: SelectSubset<T, ChatFindUniqueArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatFindFirstArgs>(args?: SelectSubset<T, ChatFindFirstArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatFindManyArgs>(args?: SelectSubset<T, ChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
     */
    create<T extends ChatCreateArgs>(args: SelectSubset<T, ChatCreateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chats.
     * @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatCreateManyArgs>(args?: SelectSubset<T, ChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
     */
    delete<T extends ChatDeleteArgs>(args: SelectSubset<T, ChatDeleteArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatUpdateArgs>(args: SelectSubset<T, ChatUpdateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatDeleteManyArgs>(args?: SelectSubset<T, ChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatUpdateManyArgs>(args: SelectSubset<T, ChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
     */
    upsert<T extends ChatUpsertArgs>(args: SelectSubset<T, ChatUpsertArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chats that matches the filter.
     * @param {ChatFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const chat = await prisma.chat.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ChatFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Chat.
     * @param {ChatAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const chat = await prisma.chat.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ChatAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chat model
   */
  readonly fields: ChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chat model
   */
  interface ChatFieldRefs {
    readonly id: FieldRef<"Chat", 'String'>
    readonly teamId: FieldRef<"Chat", 'String'>
    readonly senderId: FieldRef<"Chat", 'String'>
    readonly message: FieldRef<"Chat", 'String'>
    readonly createdAt: FieldRef<"Chat", 'DateTime'>
    readonly updatedAt: FieldRef<"Chat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chat findUnique
   */
  export type ChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findUniqueOrThrow
   */
  export type ChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findFirst
   */
  export type ChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findFirstOrThrow
   */
  export type ChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findMany
   */
  export type ChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chats to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat create
   */
  export type ChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to create a Chat.
     */
    data: XOR<ChatCreateInput, ChatUncheckedCreateInput>
  }

  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
  }

  /**
   * Chat update
   */
  export type ChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to update a Chat.
     */
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to update.
     */
    limit?: number
  }

  /**
   * Chat upsert
   */
  export type ChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The filter to search for the Chat to update in case it exists.
     */
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     */
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
  }

  /**
   * Chat delete
   */
  export type ChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter which Chat to delete.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chats to delete
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to delete.
     */
    limit?: number
  }

  /**
   * Chat findRaw
   */
  export type ChatFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Chat aggregateRaw
   */
  export type ChatAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Chat without action
   */
  export type ChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    quantity: number | null
    amount: number | null
  }

  export type ProductSumAggregateOutputType = {
    quantity: number | null
    amount: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    productType: $Enums.ProductType | null
    title: string | null
    quantity: number | null
    amount: number | null
    icon: string | null
    description: string | null
    image: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    productType: $Enums.ProductType | null
    title: string | null
    quantity: number | null
    amount: number | null
    icon: string | null
    description: string | null
    image: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    productType: number
    title: number
    quantity: number
    amount: number
    icon: number
    description: number
    image: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    quantity?: true
    amount?: true
  }

  export type ProductSumAggregateInputType = {
    quantity?: true
    amount?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    productType?: true
    title?: true
    quantity?: true
    amount?: true
    icon?: true
    description?: true
    image?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    productType?: true
    title?: true
    quantity?: true
    amount?: true
    icon?: true
    description?: true
    image?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    productType?: true
    title?: true
    quantity?: true
    amount?: true
    icon?: true
    description?: true
    image?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    productType: $Enums.ProductType
    title: string
    quantity: number
    amount: number
    icon: string | null
    description: string | null
    image: string | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productType?: boolean
    title?: boolean
    quantity?: boolean
    amount?: boolean
    icon?: boolean
    description?: boolean
    image?: boolean
  }, ExtArgs["result"]["product"]>



  export type ProductSelectScalar = {
    id?: boolean
    productType?: boolean
    title?: boolean
    quantity?: boolean
    amount?: boolean
    icon?: boolean
    description?: boolean
    image?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productType" | "title" | "quantity" | "amount" | "icon" | "description" | "image", ExtArgs["result"]["product"]>

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productType: $Enums.ProductType
      title: string
      quantity: number
      amount: number
      icon: string | null
      description: string | null
      image: string | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * @param {ProductFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const product = await prisma.product.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ProductFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Product.
     * @param {ProductAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const product = await prisma.product.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ProductAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly productType: FieldRef<"Product", 'ProductType'>
    readonly title: FieldRef<"Product", 'String'>
    readonly quantity: FieldRef<"Product", 'Int'>
    readonly amount: FieldRef<"Product", 'Float'>
    readonly icon: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly image: FieldRef<"Product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product findRaw
   */
  export type ProductFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Product aggregateRaw
   */
  export type ProductAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
  }


  /**
   * Model Price
   */

  export type AggregatePrice = {
    _count: PriceCountAggregateOutputType | null
    _avg: PriceAvgAggregateOutputType | null
    _sum: PriceSumAggregateOutputType | null
    _min: PriceMinAggregateOutputType | null
    _max: PriceMaxAggregateOutputType | null
  }

  export type PriceAvgAggregateOutputType = {
    amount: number | null
    quantity: number | null
  }

  export type PriceSumAggregateOutputType = {
    amount: number | null
    quantity: number | null
  }

  export type PriceMinAggregateOutputType = {
    id: string | null
    product_id: string | null
    name: string | null
    amount: number | null
    quantity: number | null
    price_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PriceMaxAggregateOutputType = {
    id: string | null
    product_id: string | null
    name: string | null
    amount: number | null
    quantity: number | null
    price_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PriceCountAggregateOutputType = {
    id: number
    product_id: number
    name: number
    amount: number
    quantity: number
    price_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PriceAvgAggregateInputType = {
    amount?: true
    quantity?: true
  }

  export type PriceSumAggregateInputType = {
    amount?: true
    quantity?: true
  }

  export type PriceMinAggregateInputType = {
    id?: true
    product_id?: true
    name?: true
    amount?: true
    quantity?: true
    price_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PriceMaxAggregateInputType = {
    id?: true
    product_id?: true
    name?: true
    amount?: true
    quantity?: true
    price_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PriceCountAggregateInputType = {
    id?: true
    product_id?: true
    name?: true
    amount?: true
    quantity?: true
    price_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Price to aggregate.
     */
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: PriceOrderByWithRelationInput | PriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prices
    **/
    _count?: true | PriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceMaxAggregateInputType
  }

  export type GetPriceAggregateType<T extends PriceAggregateArgs> = {
        [P in keyof T & keyof AggregatePrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrice[P]>
      : GetScalarType<T[P], AggregatePrice[P]>
  }




  export type PriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceWhereInput
    orderBy?: PriceOrderByWithAggregationInput | PriceOrderByWithAggregationInput[]
    by: PriceScalarFieldEnum[] | PriceScalarFieldEnum
    having?: PriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceCountAggregateInputType | true
    _avg?: PriceAvgAggregateInputType
    _sum?: PriceSumAggregateInputType
    _min?: PriceMinAggregateInputType
    _max?: PriceMaxAggregateInputType
  }

  export type PriceGroupByOutputType = {
    id: string
    product_id: string
    name: string
    amount: number
    quantity: number
    price_id: string
    createdAt: Date
    updatedAt: Date
    _count: PriceCountAggregateOutputType | null
    _avg: PriceAvgAggregateOutputType | null
    _sum: PriceSumAggregateOutputType | null
    _min: PriceMinAggregateOutputType | null
    _max: PriceMaxAggregateOutputType | null
  }

  type GetPriceGroupByPayload<T extends PriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceGroupByOutputType[P]>
            : GetScalarType<T[P], PriceGroupByOutputType[P]>
        }
      >
    >


  export type PriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    product_id?: boolean
    name?: boolean
    amount?: boolean
    quantity?: boolean
    price_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["price"]>



  export type PriceSelectScalar = {
    id?: boolean
    product_id?: boolean
    name?: boolean
    amount?: boolean
    quantity?: boolean
    price_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PriceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "product_id" | "name" | "amount" | "quantity" | "price_id" | "createdAt" | "updatedAt", ExtArgs["result"]["price"]>

  export type $PricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Price"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      product_id: string
      name: string
      amount: number
      quantity: number
      price_id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["price"]>
    composites: {}
  }

  type PriceGetPayload<S extends boolean | null | undefined | PriceDefaultArgs> = $Result.GetResult<Prisma.$PricePayload, S>

  type PriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PriceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PriceCountAggregateInputType | true
    }

  export interface PriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Price'], meta: { name: 'Price' } }
    /**
     * Find zero or one Price that matches the filter.
     * @param {PriceFindUniqueArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceFindUniqueArgs>(args: SelectSubset<T, PriceFindUniqueArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Price that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PriceFindUniqueOrThrowArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Price that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceFindFirstArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceFindFirstArgs>(args?: SelectSubset<T, PriceFindFirstArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Price that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceFindFirstOrThrowArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prices
     * const prices = await prisma.price.findMany()
     * 
     * // Get first 10 Prices
     * const prices = await prisma.price.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceWithIdOnly = await prisma.price.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceFindManyArgs>(args?: SelectSubset<T, PriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Price.
     * @param {PriceCreateArgs} args - Arguments to create a Price.
     * @example
     * // Create one Price
     * const Price = await prisma.price.create({
     *   data: {
     *     // ... data to create a Price
     *   }
     * })
     * 
     */
    create<T extends PriceCreateArgs>(args: SelectSubset<T, PriceCreateArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Prices.
     * @param {PriceCreateManyArgs} args - Arguments to create many Prices.
     * @example
     * // Create many Prices
     * const price = await prisma.price.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceCreateManyArgs>(args?: SelectSubset<T, PriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Price.
     * @param {PriceDeleteArgs} args - Arguments to delete one Price.
     * @example
     * // Delete one Price
     * const Price = await prisma.price.delete({
     *   where: {
     *     // ... filter to delete one Price
     *   }
     * })
     * 
     */
    delete<T extends PriceDeleteArgs>(args: SelectSubset<T, PriceDeleteArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Price.
     * @param {PriceUpdateArgs} args - Arguments to update one Price.
     * @example
     * // Update one Price
     * const price = await prisma.price.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceUpdateArgs>(args: SelectSubset<T, PriceUpdateArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Prices.
     * @param {PriceDeleteManyArgs} args - Arguments to filter Prices to delete.
     * @example
     * // Delete a few Prices
     * const { count } = await prisma.price.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceDeleteManyArgs>(args?: SelectSubset<T, PriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prices
     * const price = await prisma.price.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceUpdateManyArgs>(args: SelectSubset<T, PriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Price.
     * @param {PriceUpsertArgs} args - Arguments to update or create a Price.
     * @example
     * // Update or create a Price
     * const price = await prisma.price.upsert({
     *   create: {
     *     // ... data to create a Price
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Price we want to update
     *   }
     * })
     */
    upsert<T extends PriceUpsertArgs>(args: SelectSubset<T, PriceUpsertArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Prices that matches the filter.
     * @param {PriceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const price = await prisma.price.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PriceFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Price.
     * @param {PriceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const price = await prisma.price.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PriceAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceCountArgs} args - Arguments to filter Prices to count.
     * @example
     * // Count the number of Prices
     * const count = await prisma.price.count({
     *   where: {
     *     // ... the filter for the Prices we want to count
     *   }
     * })
    **/
    count<T extends PriceCountArgs>(
      args?: Subset<T, PriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceAggregateArgs>(args: Subset<T, PriceAggregateArgs>): Prisma.PrismaPromise<GetPriceAggregateType<T>>

    /**
     * Group by Price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceGroupByArgs['orderBy'] }
        : { orderBy?: PriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Price model
   */
  readonly fields: PriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Price.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Price model
   */
  interface PriceFieldRefs {
    readonly id: FieldRef<"Price", 'String'>
    readonly product_id: FieldRef<"Price", 'String'>
    readonly name: FieldRef<"Price", 'String'>
    readonly amount: FieldRef<"Price", 'Float'>
    readonly quantity: FieldRef<"Price", 'Int'>
    readonly price_id: FieldRef<"Price", 'String'>
    readonly createdAt: FieldRef<"Price", 'DateTime'>
    readonly updatedAt: FieldRef<"Price", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Price findUnique
   */
  export type PriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Price
     */
    omit?: PriceOmit<ExtArgs> | null
    /**
     * Filter, which Price to fetch.
     */
    where: PriceWhereUniqueInput
  }

  /**
   * Price findUniqueOrThrow
   */
  export type PriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Price
     */
    omit?: PriceOmit<ExtArgs> | null
    /**
     * Filter, which Price to fetch.
     */
    where: PriceWhereUniqueInput
  }

  /**
   * Price findFirst
   */
  export type PriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Price
     */
    omit?: PriceOmit<ExtArgs> | null
    /**
     * Filter, which Price to fetch.
     */
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: PriceOrderByWithRelationInput | PriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prices.
     */
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prices.
     */
    distinct?: PriceScalarFieldEnum | PriceScalarFieldEnum[]
  }

  /**
   * Price findFirstOrThrow
   */
  export type PriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Price
     */
    omit?: PriceOmit<ExtArgs> | null
    /**
     * Filter, which Price to fetch.
     */
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: PriceOrderByWithRelationInput | PriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prices.
     */
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prices.
     */
    distinct?: PriceScalarFieldEnum | PriceScalarFieldEnum[]
  }

  /**
   * Price findMany
   */
  export type PriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Price
     */
    omit?: PriceOmit<ExtArgs> | null
    /**
     * Filter, which Prices to fetch.
     */
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: PriceOrderByWithRelationInput | PriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prices.
     */
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    distinct?: PriceScalarFieldEnum | PriceScalarFieldEnum[]
  }

  /**
   * Price create
   */
  export type PriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Price
     */
    omit?: PriceOmit<ExtArgs> | null
    /**
     * The data needed to create a Price.
     */
    data: XOR<PriceCreateInput, PriceUncheckedCreateInput>
  }

  /**
   * Price createMany
   */
  export type PriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prices.
     */
    data: PriceCreateManyInput | PriceCreateManyInput[]
  }

  /**
   * Price update
   */
  export type PriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Price
     */
    omit?: PriceOmit<ExtArgs> | null
    /**
     * The data needed to update a Price.
     */
    data: XOR<PriceUpdateInput, PriceUncheckedUpdateInput>
    /**
     * Choose, which Price to update.
     */
    where: PriceWhereUniqueInput
  }

  /**
   * Price updateMany
   */
  export type PriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prices.
     */
    data: XOR<PriceUpdateManyMutationInput, PriceUncheckedUpdateManyInput>
    /**
     * Filter which Prices to update
     */
    where?: PriceWhereInput
    /**
     * Limit how many Prices to update.
     */
    limit?: number
  }

  /**
   * Price upsert
   */
  export type PriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Price
     */
    omit?: PriceOmit<ExtArgs> | null
    /**
     * The filter to search for the Price to update in case it exists.
     */
    where: PriceWhereUniqueInput
    /**
     * In case the Price found by the `where` argument doesn't exist, create a new Price with this data.
     */
    create: XOR<PriceCreateInput, PriceUncheckedCreateInput>
    /**
     * In case the Price was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceUpdateInput, PriceUncheckedUpdateInput>
  }

  /**
   * Price delete
   */
  export type PriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Price
     */
    omit?: PriceOmit<ExtArgs> | null
    /**
     * Filter which Price to delete.
     */
    where: PriceWhereUniqueInput
  }

  /**
   * Price deleteMany
   */
  export type PriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prices to delete
     */
    where?: PriceWhereInput
    /**
     * Limit how many Prices to delete.
     */
    limit?: number
  }

  /**
   * Price findRaw
   */
  export type PriceFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Price aggregateRaw
   */
  export type PriceAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Price without action
   */
  export type PriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Price
     */
    omit?: PriceOmit<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    score: number | null
    win: number | null
    lost: number | null
    min_requirement: number | null
  }

  export type TeamSumAggregateOutputType = {
    score: number | null
    win: number | null
    lost: number | null
    min_requirement: number | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    level: string | null
    language: string | null
    country: string | null
    description: string | null
    accessibility: $Enums.TeamAccessibility | null
    score: number | null
    win: number | null
    lost: number | null
    badge: string | null
    min_requirement: number | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    level: string | null
    language: string | null
    country: string | null
    description: string | null
    accessibility: $Enums.TeamAccessibility | null
    score: number | null
    win: number | null
    lost: number | null
    badge: string | null
    min_requirement: number | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    level: number
    language: number
    country: number
    description: number
    accessibility: number
    score: number
    win: number
    lost: number
    badge: number
    min_requirement: number
    creatorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    score?: true
    win?: true
    lost?: true
    min_requirement?: true
  }

  export type TeamSumAggregateInputType = {
    score?: true
    win?: true
    lost?: true
    min_requirement?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    level?: true
    language?: true
    country?: true
    description?: true
    accessibility?: true
    score?: true
    win?: true
    lost?: true
    badge?: true
    min_requirement?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    level?: true
    language?: true
    country?: true
    description?: true
    accessibility?: true
    score?: true
    win?: true
    lost?: true
    badge?: true
    min_requirement?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    level?: true
    language?: true
    country?: true
    description?: true
    accessibility?: true
    score?: true
    win?: true
    lost?: true
    badge?: true
    min_requirement?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility: $Enums.TeamAccessibility
    score: number
    win: number
    lost: number
    badge: string
    min_requirement: number
    creatorId: string
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    language?: boolean
    country?: boolean
    description?: boolean
    accessibility?: boolean
    score?: boolean
    win?: boolean
    lost?: boolean
    badge?: boolean
    min_requirement?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    chat?: boolean | Team$chatArgs<ExtArgs>
    participations?: boolean | Team$participationsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>



  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    level?: boolean
    language?: boolean
    country?: boolean
    description?: boolean
    accessibility?: boolean
    score?: boolean
    win?: boolean
    lost?: boolean
    badge?: boolean
    min_requirement?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "level" | "language" | "country" | "description" | "accessibility" | "score" | "win" | "lost" | "badge" | "min_requirement" | "creatorId" | "createdAt" | "updatedAt", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    chat?: boolean | Team$chatArgs<ExtArgs>
    participations?: boolean | Team$participationsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$TeamMemberPayload<ExtArgs>[]
      chat: Prisma.$ChatPayload<ExtArgs>[]
      participations: Prisma.$TeamParticipationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      level: string
      language: string
      country: string
      description: string
      accessibility: $Enums.TeamAccessibility
      score: number
      win: number
      lost: number
      badge: string
      min_requirement: number
      creatorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * @param {TeamFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const team = await prisma.team.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TeamFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Team.
     * @param {TeamAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const team = await prisma.team.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TeamAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends Team$membersArgs<ExtArgs> = {}>(args?: Subset<T, Team$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chat<T extends Team$chatArgs<ExtArgs> = {}>(args?: Subset<T, Team$chatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    participations<T extends Team$participationsArgs<ExtArgs> = {}>(args?: Subset<T, Team$participationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly level: FieldRef<"Team", 'String'>
    readonly language: FieldRef<"Team", 'String'>
    readonly country: FieldRef<"Team", 'String'>
    readonly description: FieldRef<"Team", 'String'>
    readonly accessibility: FieldRef<"Team", 'TeamAccessibility'>
    readonly score: FieldRef<"Team", 'Int'>
    readonly win: FieldRef<"Team", 'Int'>
    readonly lost: FieldRef<"Team", 'Int'>
    readonly badge: FieldRef<"Team", 'String'>
    readonly min_requirement: FieldRef<"Team", 'Int'>
    readonly creatorId: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team findRaw
   */
  export type TeamFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Team aggregateRaw
   */
  export type TeamAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Team.members
   */
  export type Team$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * Team.chat
   */
  export type Team$chatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Team.participations
   */
  export type Team$participationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamParticipation
     */
    select?: TeamParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamParticipation
     */
    omit?: TeamParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamParticipationInclude<ExtArgs> | null
    where?: TeamParticipationWhereInput
    orderBy?: TeamParticipationOrderByWithRelationInput | TeamParticipationOrderByWithRelationInput[]
    cursor?: TeamParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamParticipationScalarFieldEnum | TeamParticipationScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: string | null
    status: $Enums.TeamMemberStatus | null
    level: $Enums.MemberLevel | null
    teamId: string | null
    memberId: string | null
    contestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: string | null
    status: $Enums.TeamMemberStatus | null
    level: $Enums.MemberLevel | null
    teamId: string | null
    memberId: string | null
    contestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    status: number
    level: number
    teamId: number
    memberId: number
    contestId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMemberMinAggregateInputType = {
    id?: true
    status?: true
    level?: true
    teamId?: true
    memberId?: true
    contestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    status?: true
    level?: true
    teamId?: true
    memberId?: true
    contestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    status?: true
    level?: true
    teamId?: true
    memberId?: true
    contestId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    id: string
    status: $Enums.TeamMemberStatus
    level: $Enums.MemberLevel
    teamId: string
    memberId: string
    contestId: string
    createdAt: Date
    updatedAt: Date
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    level?: boolean
    teamId?: boolean
    memberId?: boolean
    contestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    member?: boolean | UserDefaultArgs<ExtArgs>
    contestParticipant?: boolean | TeamMember$contestParticipantArgs<ExtArgs>
    _count?: boolean | TeamMemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>



  export type TeamMemberSelectScalar = {
    id?: boolean
    status?: boolean
    level?: boolean
    teamId?: boolean
    memberId?: boolean
    contestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "level" | "teamId" | "memberId" | "contestId" | "createdAt" | "updatedAt", ExtArgs["result"]["teamMember"]>
  export type TeamMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    member?: boolean | UserDefaultArgs<ExtArgs>
    contestParticipant?: boolean | TeamMember$contestParticipantArgs<ExtArgs>
    _count?: boolean | TeamMemberCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMember"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      member: Prisma.$UserPayload<ExtArgs>
      contestParticipant: Prisma.$ContestParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.TeamMemberStatus
      level: $Enums.MemberLevel
      teamId: string
      memberId: string
      contestId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> = $Result.GetResult<Prisma.$TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMemberFindManyArgs>(args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
     */
    create<T extends TeamMemberCreateArgs>(args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMemberCreateManyArgs>(args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
     */
    delete<T extends TeamMemberDeleteArgs>(args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMemberUpdateArgs>(args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * @param {TeamMemberFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const teamMember = await prisma.teamMember.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TeamMemberFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TeamMember.
     * @param {TeamMemberAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const teamMember = await prisma.teamMember.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TeamMemberAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMember model
   */
  readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    member<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contestParticipant<T extends TeamMember$contestParticipantArgs<ExtArgs> = {}>(args?: Subset<T, TeamMember$contestParticipantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMember model
   */
  interface TeamMemberFieldRefs {
    readonly id: FieldRef<"TeamMember", 'String'>
    readonly status: FieldRef<"TeamMember", 'TeamMemberStatus'>
    readonly level: FieldRef<"TeamMember", 'MemberLevel'>
    readonly teamId: FieldRef<"TeamMember", 'String'>
    readonly memberId: FieldRef<"TeamMember", 'String'>
    readonly contestId: FieldRef<"TeamMember", 'String'>
    readonly createdAt: FieldRef<"TeamMember", 'DateTime'>
    readonly updatedAt: FieldRef<"TeamMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
  }

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
  }

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to delete.
     */
    limit?: number
  }

  /**
   * TeamMember findRaw
   */
  export type TeamMemberFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TeamMember aggregateRaw
   */
  export type TeamMemberAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TeamMember.contestParticipant
   */
  export type TeamMember$contestParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    where?: ContestParticipantWhereInput
    orderBy?: ContestParticipantOrderByWithRelationInput | ContestParticipantOrderByWithRelationInput[]
    cursor?: ContestParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestParticipantScalarFieldEnum | ContestParticipantScalarFieldEnum[]
  }

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
  }


  /**
   * Model TeamParticipation
   */

  export type AggregateTeamParticipation = {
    _count: TeamParticipationCountAggregateOutputType | null
    _min: TeamParticipationMinAggregateOutputType | null
    _max: TeamParticipationMaxAggregateOutputType | null
  }

  export type TeamParticipationMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    contestId: string | null
  }

  export type TeamParticipationMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    contestId: string | null
  }

  export type TeamParticipationCountAggregateOutputType = {
    id: number
    teamId: number
    contestId: number
    _all: number
  }


  export type TeamParticipationMinAggregateInputType = {
    id?: true
    teamId?: true
    contestId?: true
  }

  export type TeamParticipationMaxAggregateInputType = {
    id?: true
    teamId?: true
    contestId?: true
  }

  export type TeamParticipationCountAggregateInputType = {
    id?: true
    teamId?: true
    contestId?: true
    _all?: true
  }

  export type TeamParticipationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamParticipation to aggregate.
     */
    where?: TeamParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamParticipations to fetch.
     */
    orderBy?: TeamParticipationOrderByWithRelationInput | TeamParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamParticipations
    **/
    _count?: true | TeamParticipationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamParticipationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamParticipationMaxAggregateInputType
  }

  export type GetTeamParticipationAggregateType<T extends TeamParticipationAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamParticipation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamParticipation[P]>
      : GetScalarType<T[P], AggregateTeamParticipation[P]>
  }




  export type TeamParticipationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamParticipationWhereInput
    orderBy?: TeamParticipationOrderByWithAggregationInput | TeamParticipationOrderByWithAggregationInput[]
    by: TeamParticipationScalarFieldEnum[] | TeamParticipationScalarFieldEnum
    having?: TeamParticipationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamParticipationCountAggregateInputType | true
    _min?: TeamParticipationMinAggregateInputType
    _max?: TeamParticipationMaxAggregateInputType
  }

  export type TeamParticipationGroupByOutputType = {
    id: string
    teamId: string
    contestId: string
    _count: TeamParticipationCountAggregateOutputType | null
    _min: TeamParticipationMinAggregateOutputType | null
    _max: TeamParticipationMaxAggregateOutputType | null
  }

  type GetTeamParticipationGroupByPayload<T extends TeamParticipationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamParticipationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamParticipationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamParticipationGroupByOutputType[P]>
            : GetScalarType<T[P], TeamParticipationGroupByOutputType[P]>
        }
      >
    >


  export type TeamParticipationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    contestId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    contest?: boolean | ContestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamParticipation"]>



  export type TeamParticipationSelectScalar = {
    id?: boolean
    teamId?: boolean
    contestId?: boolean
  }

  export type TeamParticipationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "contestId", ExtArgs["result"]["teamParticipation"]>
  export type TeamParticipationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    contest?: boolean | ContestDefaultArgs<ExtArgs>
  }

  export type $TeamParticipationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamParticipation"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      contest: Prisma.$ContestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      contestId: string
    }, ExtArgs["result"]["teamParticipation"]>
    composites: {}
  }

  type TeamParticipationGetPayload<S extends boolean | null | undefined | TeamParticipationDefaultArgs> = $Result.GetResult<Prisma.$TeamParticipationPayload, S>

  type TeamParticipationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamParticipationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamParticipationCountAggregateInputType | true
    }

  export interface TeamParticipationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamParticipation'], meta: { name: 'TeamParticipation' } }
    /**
     * Find zero or one TeamParticipation that matches the filter.
     * @param {TeamParticipationFindUniqueArgs} args - Arguments to find a TeamParticipation
     * @example
     * // Get one TeamParticipation
     * const teamParticipation = await prisma.teamParticipation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamParticipationFindUniqueArgs>(args: SelectSubset<T, TeamParticipationFindUniqueArgs<ExtArgs>>): Prisma__TeamParticipationClient<$Result.GetResult<Prisma.$TeamParticipationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamParticipation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamParticipationFindUniqueOrThrowArgs} args - Arguments to find a TeamParticipation
     * @example
     * // Get one TeamParticipation
     * const teamParticipation = await prisma.teamParticipation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamParticipationFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamParticipationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamParticipationClient<$Result.GetResult<Prisma.$TeamParticipationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamParticipation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamParticipationFindFirstArgs} args - Arguments to find a TeamParticipation
     * @example
     * // Get one TeamParticipation
     * const teamParticipation = await prisma.teamParticipation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamParticipationFindFirstArgs>(args?: SelectSubset<T, TeamParticipationFindFirstArgs<ExtArgs>>): Prisma__TeamParticipationClient<$Result.GetResult<Prisma.$TeamParticipationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamParticipation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamParticipationFindFirstOrThrowArgs} args - Arguments to find a TeamParticipation
     * @example
     * // Get one TeamParticipation
     * const teamParticipation = await prisma.teamParticipation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamParticipationFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamParticipationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamParticipationClient<$Result.GetResult<Prisma.$TeamParticipationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamParticipations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamParticipationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamParticipations
     * const teamParticipations = await prisma.teamParticipation.findMany()
     * 
     * // Get first 10 TeamParticipations
     * const teamParticipations = await prisma.teamParticipation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamParticipationWithIdOnly = await prisma.teamParticipation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamParticipationFindManyArgs>(args?: SelectSubset<T, TeamParticipationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamParticipation.
     * @param {TeamParticipationCreateArgs} args - Arguments to create a TeamParticipation.
     * @example
     * // Create one TeamParticipation
     * const TeamParticipation = await prisma.teamParticipation.create({
     *   data: {
     *     // ... data to create a TeamParticipation
     *   }
     * })
     * 
     */
    create<T extends TeamParticipationCreateArgs>(args: SelectSubset<T, TeamParticipationCreateArgs<ExtArgs>>): Prisma__TeamParticipationClient<$Result.GetResult<Prisma.$TeamParticipationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamParticipations.
     * @param {TeamParticipationCreateManyArgs} args - Arguments to create many TeamParticipations.
     * @example
     * // Create many TeamParticipations
     * const teamParticipation = await prisma.teamParticipation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamParticipationCreateManyArgs>(args?: SelectSubset<T, TeamParticipationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeamParticipation.
     * @param {TeamParticipationDeleteArgs} args - Arguments to delete one TeamParticipation.
     * @example
     * // Delete one TeamParticipation
     * const TeamParticipation = await prisma.teamParticipation.delete({
     *   where: {
     *     // ... filter to delete one TeamParticipation
     *   }
     * })
     * 
     */
    delete<T extends TeamParticipationDeleteArgs>(args: SelectSubset<T, TeamParticipationDeleteArgs<ExtArgs>>): Prisma__TeamParticipationClient<$Result.GetResult<Prisma.$TeamParticipationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamParticipation.
     * @param {TeamParticipationUpdateArgs} args - Arguments to update one TeamParticipation.
     * @example
     * // Update one TeamParticipation
     * const teamParticipation = await prisma.teamParticipation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamParticipationUpdateArgs>(args: SelectSubset<T, TeamParticipationUpdateArgs<ExtArgs>>): Prisma__TeamParticipationClient<$Result.GetResult<Prisma.$TeamParticipationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamParticipations.
     * @param {TeamParticipationDeleteManyArgs} args - Arguments to filter TeamParticipations to delete.
     * @example
     * // Delete a few TeamParticipations
     * const { count } = await prisma.teamParticipation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamParticipationDeleteManyArgs>(args?: SelectSubset<T, TeamParticipationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamParticipationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamParticipations
     * const teamParticipation = await prisma.teamParticipation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamParticipationUpdateManyArgs>(args: SelectSubset<T, TeamParticipationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamParticipation.
     * @param {TeamParticipationUpsertArgs} args - Arguments to update or create a TeamParticipation.
     * @example
     * // Update or create a TeamParticipation
     * const teamParticipation = await prisma.teamParticipation.upsert({
     *   create: {
     *     // ... data to create a TeamParticipation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamParticipation we want to update
     *   }
     * })
     */
    upsert<T extends TeamParticipationUpsertArgs>(args: SelectSubset<T, TeamParticipationUpsertArgs<ExtArgs>>): Prisma__TeamParticipationClient<$Result.GetResult<Prisma.$TeamParticipationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamParticipations that matches the filter.
     * @param {TeamParticipationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const teamParticipation = await prisma.teamParticipation.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TeamParticipationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TeamParticipation.
     * @param {TeamParticipationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const teamParticipation = await prisma.teamParticipation.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TeamParticipationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TeamParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamParticipationCountArgs} args - Arguments to filter TeamParticipations to count.
     * @example
     * // Count the number of TeamParticipations
     * const count = await prisma.teamParticipation.count({
     *   where: {
     *     // ... the filter for the TeamParticipations we want to count
     *   }
     * })
    **/
    count<T extends TeamParticipationCountArgs>(
      args?: Subset<T, TeamParticipationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamParticipationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamParticipationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamParticipationAggregateArgs>(args: Subset<T, TeamParticipationAggregateArgs>): Prisma.PrismaPromise<GetTeamParticipationAggregateType<T>>

    /**
     * Group by TeamParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamParticipationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamParticipationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamParticipationGroupByArgs['orderBy'] }
        : { orderBy?: TeamParticipationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamParticipationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamParticipationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamParticipation model
   */
  readonly fields: TeamParticipationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamParticipation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamParticipationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contest<T extends ContestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestDefaultArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamParticipation model
   */
  interface TeamParticipationFieldRefs {
    readonly id: FieldRef<"TeamParticipation", 'String'>
    readonly teamId: FieldRef<"TeamParticipation", 'String'>
    readonly contestId: FieldRef<"TeamParticipation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TeamParticipation findUnique
   */
  export type TeamParticipationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamParticipation
     */
    select?: TeamParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamParticipation
     */
    omit?: TeamParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamParticipationInclude<ExtArgs> | null
    /**
     * Filter, which TeamParticipation to fetch.
     */
    where: TeamParticipationWhereUniqueInput
  }

  /**
   * TeamParticipation findUniqueOrThrow
   */
  export type TeamParticipationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamParticipation
     */
    select?: TeamParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamParticipation
     */
    omit?: TeamParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamParticipationInclude<ExtArgs> | null
    /**
     * Filter, which TeamParticipation to fetch.
     */
    where: TeamParticipationWhereUniqueInput
  }

  /**
   * TeamParticipation findFirst
   */
  export type TeamParticipationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamParticipation
     */
    select?: TeamParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamParticipation
     */
    omit?: TeamParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamParticipationInclude<ExtArgs> | null
    /**
     * Filter, which TeamParticipation to fetch.
     */
    where?: TeamParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamParticipations to fetch.
     */
    orderBy?: TeamParticipationOrderByWithRelationInput | TeamParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamParticipations.
     */
    cursor?: TeamParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamParticipations.
     */
    distinct?: TeamParticipationScalarFieldEnum | TeamParticipationScalarFieldEnum[]
  }

  /**
   * TeamParticipation findFirstOrThrow
   */
  export type TeamParticipationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamParticipation
     */
    select?: TeamParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamParticipation
     */
    omit?: TeamParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamParticipationInclude<ExtArgs> | null
    /**
     * Filter, which TeamParticipation to fetch.
     */
    where?: TeamParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamParticipations to fetch.
     */
    orderBy?: TeamParticipationOrderByWithRelationInput | TeamParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamParticipations.
     */
    cursor?: TeamParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamParticipations.
     */
    distinct?: TeamParticipationScalarFieldEnum | TeamParticipationScalarFieldEnum[]
  }

  /**
   * TeamParticipation findMany
   */
  export type TeamParticipationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamParticipation
     */
    select?: TeamParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamParticipation
     */
    omit?: TeamParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamParticipationInclude<ExtArgs> | null
    /**
     * Filter, which TeamParticipations to fetch.
     */
    where?: TeamParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamParticipations to fetch.
     */
    orderBy?: TeamParticipationOrderByWithRelationInput | TeamParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamParticipations.
     */
    cursor?: TeamParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamParticipations.
     */
    skip?: number
    distinct?: TeamParticipationScalarFieldEnum | TeamParticipationScalarFieldEnum[]
  }

  /**
   * TeamParticipation create
   */
  export type TeamParticipationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamParticipation
     */
    select?: TeamParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamParticipation
     */
    omit?: TeamParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamParticipationInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamParticipation.
     */
    data: XOR<TeamParticipationCreateInput, TeamParticipationUncheckedCreateInput>
  }

  /**
   * TeamParticipation createMany
   */
  export type TeamParticipationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamParticipations.
     */
    data: TeamParticipationCreateManyInput | TeamParticipationCreateManyInput[]
  }

  /**
   * TeamParticipation update
   */
  export type TeamParticipationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamParticipation
     */
    select?: TeamParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamParticipation
     */
    omit?: TeamParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamParticipationInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamParticipation.
     */
    data: XOR<TeamParticipationUpdateInput, TeamParticipationUncheckedUpdateInput>
    /**
     * Choose, which TeamParticipation to update.
     */
    where: TeamParticipationWhereUniqueInput
  }

  /**
   * TeamParticipation updateMany
   */
  export type TeamParticipationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamParticipations.
     */
    data: XOR<TeamParticipationUpdateManyMutationInput, TeamParticipationUncheckedUpdateManyInput>
    /**
     * Filter which TeamParticipations to update
     */
    where?: TeamParticipationWhereInput
    /**
     * Limit how many TeamParticipations to update.
     */
    limit?: number
  }

  /**
   * TeamParticipation upsert
   */
  export type TeamParticipationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamParticipation
     */
    select?: TeamParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamParticipation
     */
    omit?: TeamParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamParticipationInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamParticipation to update in case it exists.
     */
    where: TeamParticipationWhereUniqueInput
    /**
     * In case the TeamParticipation found by the `where` argument doesn't exist, create a new TeamParticipation with this data.
     */
    create: XOR<TeamParticipationCreateInput, TeamParticipationUncheckedCreateInput>
    /**
     * In case the TeamParticipation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamParticipationUpdateInput, TeamParticipationUncheckedUpdateInput>
  }

  /**
   * TeamParticipation delete
   */
  export type TeamParticipationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamParticipation
     */
    select?: TeamParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamParticipation
     */
    omit?: TeamParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamParticipationInclude<ExtArgs> | null
    /**
     * Filter which TeamParticipation to delete.
     */
    where: TeamParticipationWhereUniqueInput
  }

  /**
   * TeamParticipation deleteMany
   */
  export type TeamParticipationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamParticipations to delete
     */
    where?: TeamParticipationWhereInput
    /**
     * Limit how many TeamParticipations to delete.
     */
    limit?: number
  }

  /**
   * TeamParticipation findRaw
   */
  export type TeamParticipationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TeamParticipation aggregateRaw
   */
  export type TeamParticipationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TeamParticipation without action
   */
  export type TeamParticipationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamParticipation
     */
    select?: TeamParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamParticipation
     */
    omit?: TeamParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamParticipationInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    cover: string | null
    avatar: string | null
    socialId: string | null
    socialProvider: string | null
    firstName: string | null
    lastName: string | null
    fullName: string | null
    username: string | null
    phone: string | null
    email: string | null
    location: string | null
    password: string | null
    role: $Enums.UserRole | null
    accessToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    cover: string | null
    avatar: string | null
    socialId: string | null
    socialProvider: string | null
    firstName: string | null
    lastName: string | null
    fullName: string | null
    username: string | null
    phone: string | null
    email: string | null
    location: string | null
    password: string | null
    role: $Enums.UserRole | null
    accessToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    cover: number
    avatar: number
    socialId: number
    socialProvider: number
    firstName: number
    lastName: number
    fullName: number
    username: number
    phone: number
    email: number
    location: number
    password: number
    role: number
    accessToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    cover?: true
    avatar?: true
    socialId?: true
    socialProvider?: true
    firstName?: true
    lastName?: true
    fullName?: true
    username?: true
    phone?: true
    email?: true
    location?: true
    password?: true
    role?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    cover?: true
    avatar?: true
    socialId?: true
    socialProvider?: true
    firstName?: true
    lastName?: true
    fullName?: true
    username?: true
    phone?: true
    email?: true
    location?: true
    password?: true
    role?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    cover?: true
    avatar?: true
    socialId?: true
    socialProvider?: true
    firstName?: true
    lastName?: true
    fullName?: true
    username?: true
    phone?: true
    email?: true
    location?: true
    password?: true
    role?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    cover: string | null
    avatar: string | null
    socialId: string | null
    socialProvider: string | null
    firstName: string | null
    lastName: string | null
    fullName: string | null
    username: string | null
    phone: string | null
    email: string
    location: string | null
    password: string | null
    role: $Enums.UserRole
    accessToken: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cover?: boolean
    avatar?: boolean
    socialId?: boolean
    socialProvider?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    username?: boolean
    phone?: boolean
    email?: boolean
    location?: boolean
    password?: boolean
    role?: boolean
    accessToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    otps?: boolean | User$otpsArgs<ExtArgs>
    store?: boolean | User$storeArgs<ExtArgs>
    createdTeam?: boolean | User$createdTeamArgs<ExtArgs>
    joinedTeam?: boolean | User$joinedTeamArgs<ExtArgs>
    createdContests?: boolean | User$createdContestsArgs<ExtArgs>
    commentProvides?: boolean | User$commentProvidesArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    followings?: boolean | User$followingsArgs<ExtArgs>
    votes?: boolean | User$votesArgs<ExtArgs>
    likes?: boolean | User$likesArgs<ExtArgs>
    userPhotos?: boolean | User$userPhotosArgs<ExtArgs>
    ContestParticipant?: boolean | User$ContestParticipantArgs<ExtArgs>
    chat?: boolean | User$chatArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    cover?: boolean
    avatar?: boolean
    socialId?: boolean
    socialProvider?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    username?: boolean
    phone?: boolean
    email?: boolean
    location?: boolean
    password?: boolean
    role?: boolean
    accessToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cover" | "avatar" | "socialId" | "socialProvider" | "firstName" | "lastName" | "fullName" | "username" | "phone" | "email" | "location" | "password" | "role" | "accessToken" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    otps?: boolean | User$otpsArgs<ExtArgs>
    store?: boolean | User$storeArgs<ExtArgs>
    createdTeam?: boolean | User$createdTeamArgs<ExtArgs>
    joinedTeam?: boolean | User$joinedTeamArgs<ExtArgs>
    createdContests?: boolean | User$createdContestsArgs<ExtArgs>
    commentProvides?: boolean | User$commentProvidesArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    followings?: boolean | User$followingsArgs<ExtArgs>
    votes?: boolean | User$votesArgs<ExtArgs>
    likes?: boolean | User$likesArgs<ExtArgs>
    userPhotos?: boolean | User$userPhotosArgs<ExtArgs>
    ContestParticipant?: boolean | User$ContestParticipantArgs<ExtArgs>
    chat?: boolean | User$chatArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      otps: Prisma.$OtpPayload<ExtArgs> | null
      store: Prisma.$UserStorePayload<ExtArgs> | null
      createdTeam: Prisma.$TeamPayload<ExtArgs>[]
      joinedTeam: Prisma.$TeamMemberPayload<ExtArgs> | null
      createdContests: Prisma.$ContestPayload<ExtArgs>[]
      commentProvides: Prisma.$CommentPayload<ExtArgs>[]
      followers: Prisma.$FollowPayload<ExtArgs>[]
      followings: Prisma.$FollowPayload<ExtArgs>[]
      votes: Prisma.$VotePayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
      userPhotos: Prisma.$UserPhotoPayload<ExtArgs>[]
      ContestParticipant: Prisma.$ContestParticipantPayload<ExtArgs>[]
      chat: Prisma.$ChatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cover: string | null
      avatar: string | null
      socialId: string | null
      socialProvider: string | null
      firstName: string | null
      lastName: string | null
      fullName: string | null
      username: string | null
      phone: string | null
      email: string
      location: string | null
      password: string | null
      role: $Enums.UserRole
      accessToken: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    otps<T extends User$otpsArgs<ExtArgs> = {}>(args?: Subset<T, User$otpsArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    store<T extends User$storeArgs<ExtArgs> = {}>(args?: Subset<T, User$storeArgs<ExtArgs>>): Prisma__UserStoreClient<$Result.GetResult<Prisma.$UserStorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdTeam<T extends User$createdTeamArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTeamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    joinedTeam<T extends User$joinedTeamArgs<ExtArgs> = {}>(args?: Subset<T, User$joinedTeamArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdContests<T extends User$createdContestsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdContestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commentProvides<T extends User$commentProvidesArgs<ExtArgs> = {}>(args?: Subset<T, User$commentProvidesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followers<T extends User$followersArgs<ExtArgs> = {}>(args?: Subset<T, User$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followings<T extends User$followingsArgs<ExtArgs> = {}>(args?: Subset<T, User$followingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    votes<T extends User$votesArgs<ExtArgs> = {}>(args?: Subset<T, User$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends User$likesArgs<ExtArgs> = {}>(args?: Subset<T, User$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userPhotos<T extends User$userPhotosArgs<ExtArgs> = {}>(args?: Subset<T, User$userPhotosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ContestParticipant<T extends User$ContestParticipantArgs<ExtArgs> = {}>(args?: Subset<T, User$ContestParticipantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chat<T extends User$chatArgs<ExtArgs> = {}>(args?: Subset<T, User$chatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly cover: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly socialId: FieldRef<"User", 'String'>
    readonly socialProvider: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly location: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly accessToken: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.otps
   */
  export type User$otpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    where?: OtpWhereInput
  }

  /**
   * User.store
   */
  export type User$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStore
     */
    select?: UserStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStore
     */
    omit?: UserStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoreInclude<ExtArgs> | null
    where?: UserStoreWhereInput
  }

  /**
   * User.createdTeam
   */
  export type User$createdTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * User.joinedTeam
   */
  export type User$joinedTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
  }

  /**
   * User.createdContests
   */
  export type User$createdContestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    where?: ContestWhereInput
    orderBy?: ContestOrderByWithRelationInput | ContestOrderByWithRelationInput[]
    cursor?: ContestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestScalarFieldEnum | ContestScalarFieldEnum[]
  }

  /**
   * User.commentProvides
   */
  export type User$commentProvidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.followers
   */
  export type User$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * User.followings
   */
  export type User$followingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * User.votes
   */
  export type User$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    cursor?: VoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * User.likes
   */
  export type User$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * User.userPhotos
   */
  export type User$userPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    where?: UserPhotoWhereInput
    orderBy?: UserPhotoOrderByWithRelationInput | UserPhotoOrderByWithRelationInput[]
    cursor?: UserPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPhotoScalarFieldEnum | UserPhotoScalarFieldEnum[]
  }

  /**
   * User.ContestParticipant
   */
  export type User$ContestParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    where?: ContestParticipantWhereInput
    orderBy?: ContestParticipantOrderByWithRelationInput | ContestParticipantOrderByWithRelationInput[]
    cursor?: ContestParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestParticipantScalarFieldEnum | ContestParticipantScalarFieldEnum[]
  }

  /**
   * User.chat
   */
  export type User$chatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserStore
   */

  export type AggregateUserStore = {
    _count: UserStoreCountAggregateOutputType | null
    _avg: UserStoreAvgAggregateOutputType | null
    _sum: UserStoreSumAggregateOutputType | null
    _min: UserStoreMinAggregateOutputType | null
    _max: UserStoreMaxAggregateOutputType | null
  }

  export type UserStoreAvgAggregateOutputType = {
    promotes: number | null
    trades: number | null
    charges: number | null
  }

  export type UserStoreSumAggregateOutputType = {
    promotes: number | null
    trades: number | null
    charges: number | null
  }

  export type UserStoreMinAggregateOutputType = {
    id: string | null
    userId: string | null
    promotes: number | null
    trades: number | null
    charges: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserStoreMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    promotes: number | null
    trades: number | null
    charges: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserStoreCountAggregateOutputType = {
    id: number
    userId: number
    promotes: number
    trades: number
    charges: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserStoreAvgAggregateInputType = {
    promotes?: true
    trades?: true
    charges?: true
  }

  export type UserStoreSumAggregateInputType = {
    promotes?: true
    trades?: true
    charges?: true
  }

  export type UserStoreMinAggregateInputType = {
    id?: true
    userId?: true
    promotes?: true
    trades?: true
    charges?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserStoreMaxAggregateInputType = {
    id?: true
    userId?: true
    promotes?: true
    trades?: true
    charges?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserStoreCountAggregateInputType = {
    id?: true
    userId?: true
    promotes?: true
    trades?: true
    charges?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserStoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStore to aggregate.
     */
    where?: UserStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStores to fetch.
     */
    orderBy?: UserStoreOrderByWithRelationInput | UserStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserStores
    **/
    _count?: true | UserStoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserStoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserStoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserStoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserStoreMaxAggregateInputType
  }

  export type GetUserStoreAggregateType<T extends UserStoreAggregateArgs> = {
        [P in keyof T & keyof AggregateUserStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserStore[P]>
      : GetScalarType<T[P], AggregateUserStore[P]>
  }




  export type UserStoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserStoreWhereInput
    orderBy?: UserStoreOrderByWithAggregationInput | UserStoreOrderByWithAggregationInput[]
    by: UserStoreScalarFieldEnum[] | UserStoreScalarFieldEnum
    having?: UserStoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserStoreCountAggregateInputType | true
    _avg?: UserStoreAvgAggregateInputType
    _sum?: UserStoreSumAggregateInputType
    _min?: UserStoreMinAggregateInputType
    _max?: UserStoreMaxAggregateInputType
  }

  export type UserStoreGroupByOutputType = {
    id: string
    userId: string
    promotes: number
    trades: number
    charges: number
    createdAt: Date
    updatedAt: Date
    _count: UserStoreCountAggregateOutputType | null
    _avg: UserStoreAvgAggregateOutputType | null
    _sum: UserStoreSumAggregateOutputType | null
    _min: UserStoreMinAggregateOutputType | null
    _max: UserStoreMaxAggregateOutputType | null
  }

  type GetUserStoreGroupByPayload<T extends UserStoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserStoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserStoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserStoreGroupByOutputType[P]>
            : GetScalarType<T[P], UserStoreGroupByOutputType[P]>
        }
      >
    >


  export type UserStoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    promotes?: boolean
    trades?: boolean
    charges?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserStore$userArgs<ExtArgs>
  }, ExtArgs["result"]["userStore"]>



  export type UserStoreSelectScalar = {
    id?: boolean
    userId?: boolean
    promotes?: boolean
    trades?: boolean
    charges?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserStoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "promotes" | "trades" | "charges" | "createdAt" | "updatedAt", ExtArgs["result"]["userStore"]>
  export type UserStoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserStore$userArgs<ExtArgs>
  }

  export type $UserStorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserStore"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      promotes: number
      trades: number
      charges: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userStore"]>
    composites: {}
  }

  type UserStoreGetPayload<S extends boolean | null | undefined | UserStoreDefaultArgs> = $Result.GetResult<Prisma.$UserStorePayload, S>

  type UserStoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserStoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserStoreCountAggregateInputType | true
    }

  export interface UserStoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserStore'], meta: { name: 'UserStore' } }
    /**
     * Find zero or one UserStore that matches the filter.
     * @param {UserStoreFindUniqueArgs} args - Arguments to find a UserStore
     * @example
     * // Get one UserStore
     * const userStore = await prisma.userStore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserStoreFindUniqueArgs>(args: SelectSubset<T, UserStoreFindUniqueArgs<ExtArgs>>): Prisma__UserStoreClient<$Result.GetResult<Prisma.$UserStorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserStore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserStoreFindUniqueOrThrowArgs} args - Arguments to find a UserStore
     * @example
     * // Get one UserStore
     * const userStore = await prisma.userStore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserStoreFindUniqueOrThrowArgs>(args: SelectSubset<T, UserStoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserStoreClient<$Result.GetResult<Prisma.$UserStorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserStore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStoreFindFirstArgs} args - Arguments to find a UserStore
     * @example
     * // Get one UserStore
     * const userStore = await prisma.userStore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserStoreFindFirstArgs>(args?: SelectSubset<T, UserStoreFindFirstArgs<ExtArgs>>): Prisma__UserStoreClient<$Result.GetResult<Prisma.$UserStorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserStore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStoreFindFirstOrThrowArgs} args - Arguments to find a UserStore
     * @example
     * // Get one UserStore
     * const userStore = await prisma.userStore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserStoreFindFirstOrThrowArgs>(args?: SelectSubset<T, UserStoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserStoreClient<$Result.GetResult<Prisma.$UserStorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserStores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserStores
     * const userStores = await prisma.userStore.findMany()
     * 
     * // Get first 10 UserStores
     * const userStores = await prisma.userStore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userStoreWithIdOnly = await prisma.userStore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserStoreFindManyArgs>(args?: SelectSubset<T, UserStoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserStore.
     * @param {UserStoreCreateArgs} args - Arguments to create a UserStore.
     * @example
     * // Create one UserStore
     * const UserStore = await prisma.userStore.create({
     *   data: {
     *     // ... data to create a UserStore
     *   }
     * })
     * 
     */
    create<T extends UserStoreCreateArgs>(args: SelectSubset<T, UserStoreCreateArgs<ExtArgs>>): Prisma__UserStoreClient<$Result.GetResult<Prisma.$UserStorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserStores.
     * @param {UserStoreCreateManyArgs} args - Arguments to create many UserStores.
     * @example
     * // Create many UserStores
     * const userStore = await prisma.userStore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserStoreCreateManyArgs>(args?: SelectSubset<T, UserStoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserStore.
     * @param {UserStoreDeleteArgs} args - Arguments to delete one UserStore.
     * @example
     * // Delete one UserStore
     * const UserStore = await prisma.userStore.delete({
     *   where: {
     *     // ... filter to delete one UserStore
     *   }
     * })
     * 
     */
    delete<T extends UserStoreDeleteArgs>(args: SelectSubset<T, UserStoreDeleteArgs<ExtArgs>>): Prisma__UserStoreClient<$Result.GetResult<Prisma.$UserStorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserStore.
     * @param {UserStoreUpdateArgs} args - Arguments to update one UserStore.
     * @example
     * // Update one UserStore
     * const userStore = await prisma.userStore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserStoreUpdateArgs>(args: SelectSubset<T, UserStoreUpdateArgs<ExtArgs>>): Prisma__UserStoreClient<$Result.GetResult<Prisma.$UserStorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserStores.
     * @param {UserStoreDeleteManyArgs} args - Arguments to filter UserStores to delete.
     * @example
     * // Delete a few UserStores
     * const { count } = await prisma.userStore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserStoreDeleteManyArgs>(args?: SelectSubset<T, UserStoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserStores
     * const userStore = await prisma.userStore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserStoreUpdateManyArgs>(args: SelectSubset<T, UserStoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserStore.
     * @param {UserStoreUpsertArgs} args - Arguments to update or create a UserStore.
     * @example
     * // Update or create a UserStore
     * const userStore = await prisma.userStore.upsert({
     *   create: {
     *     // ... data to create a UserStore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserStore we want to update
     *   }
     * })
     */
    upsert<T extends UserStoreUpsertArgs>(args: SelectSubset<T, UserStoreUpsertArgs<ExtArgs>>): Prisma__UserStoreClient<$Result.GetResult<Prisma.$UserStorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserStores that matches the filter.
     * @param {UserStoreFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userStore = await prisma.userStore.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserStoreFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserStore.
     * @param {UserStoreAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userStore = await prisma.userStore.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserStoreAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserStores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStoreCountArgs} args - Arguments to filter UserStores to count.
     * @example
     * // Count the number of UserStores
     * const count = await prisma.userStore.count({
     *   where: {
     *     // ... the filter for the UserStores we want to count
     *   }
     * })
    **/
    count<T extends UserStoreCountArgs>(
      args?: Subset<T, UserStoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserStoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserStore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserStoreAggregateArgs>(args: Subset<T, UserStoreAggregateArgs>): Prisma.PrismaPromise<GetUserStoreAggregateType<T>>

    /**
     * Group by UserStore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserStoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserStoreGroupByArgs['orderBy'] }
        : { orderBy?: UserStoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserStoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserStore model
   */
  readonly fields: UserStoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserStore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserStoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserStore$userArgs<ExtArgs> = {}>(args?: Subset<T, UserStore$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserStore model
   */
  interface UserStoreFieldRefs {
    readonly id: FieldRef<"UserStore", 'String'>
    readonly userId: FieldRef<"UserStore", 'String'>
    readonly promotes: FieldRef<"UserStore", 'Int'>
    readonly trades: FieldRef<"UserStore", 'Int'>
    readonly charges: FieldRef<"UserStore", 'Int'>
    readonly createdAt: FieldRef<"UserStore", 'DateTime'>
    readonly updatedAt: FieldRef<"UserStore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserStore findUnique
   */
  export type UserStoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStore
     */
    select?: UserStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStore
     */
    omit?: UserStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoreInclude<ExtArgs> | null
    /**
     * Filter, which UserStore to fetch.
     */
    where: UserStoreWhereUniqueInput
  }

  /**
   * UserStore findUniqueOrThrow
   */
  export type UserStoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStore
     */
    select?: UserStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStore
     */
    omit?: UserStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoreInclude<ExtArgs> | null
    /**
     * Filter, which UserStore to fetch.
     */
    where: UserStoreWhereUniqueInput
  }

  /**
   * UserStore findFirst
   */
  export type UserStoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStore
     */
    select?: UserStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStore
     */
    omit?: UserStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoreInclude<ExtArgs> | null
    /**
     * Filter, which UserStore to fetch.
     */
    where?: UserStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStores to fetch.
     */
    orderBy?: UserStoreOrderByWithRelationInput | UserStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStores.
     */
    cursor?: UserStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStores.
     */
    distinct?: UserStoreScalarFieldEnum | UserStoreScalarFieldEnum[]
  }

  /**
   * UserStore findFirstOrThrow
   */
  export type UserStoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStore
     */
    select?: UserStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStore
     */
    omit?: UserStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoreInclude<ExtArgs> | null
    /**
     * Filter, which UserStore to fetch.
     */
    where?: UserStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStores to fetch.
     */
    orderBy?: UserStoreOrderByWithRelationInput | UserStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStores.
     */
    cursor?: UserStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStores.
     */
    distinct?: UserStoreScalarFieldEnum | UserStoreScalarFieldEnum[]
  }

  /**
   * UserStore findMany
   */
  export type UserStoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStore
     */
    select?: UserStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStore
     */
    omit?: UserStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoreInclude<ExtArgs> | null
    /**
     * Filter, which UserStores to fetch.
     */
    where?: UserStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStores to fetch.
     */
    orderBy?: UserStoreOrderByWithRelationInput | UserStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserStores.
     */
    cursor?: UserStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStores.
     */
    skip?: number
    distinct?: UserStoreScalarFieldEnum | UserStoreScalarFieldEnum[]
  }

  /**
   * UserStore create
   */
  export type UserStoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStore
     */
    select?: UserStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStore
     */
    omit?: UserStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoreInclude<ExtArgs> | null
    /**
     * The data needed to create a UserStore.
     */
    data: XOR<UserStoreCreateInput, UserStoreUncheckedCreateInput>
  }

  /**
   * UserStore createMany
   */
  export type UserStoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserStores.
     */
    data: UserStoreCreateManyInput | UserStoreCreateManyInput[]
  }

  /**
   * UserStore update
   */
  export type UserStoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStore
     */
    select?: UserStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStore
     */
    omit?: UserStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoreInclude<ExtArgs> | null
    /**
     * The data needed to update a UserStore.
     */
    data: XOR<UserStoreUpdateInput, UserStoreUncheckedUpdateInput>
    /**
     * Choose, which UserStore to update.
     */
    where: UserStoreWhereUniqueInput
  }

  /**
   * UserStore updateMany
   */
  export type UserStoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserStores.
     */
    data: XOR<UserStoreUpdateManyMutationInput, UserStoreUncheckedUpdateManyInput>
    /**
     * Filter which UserStores to update
     */
    where?: UserStoreWhereInput
    /**
     * Limit how many UserStores to update.
     */
    limit?: number
  }

  /**
   * UserStore upsert
   */
  export type UserStoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStore
     */
    select?: UserStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStore
     */
    omit?: UserStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoreInclude<ExtArgs> | null
    /**
     * The filter to search for the UserStore to update in case it exists.
     */
    where: UserStoreWhereUniqueInput
    /**
     * In case the UserStore found by the `where` argument doesn't exist, create a new UserStore with this data.
     */
    create: XOR<UserStoreCreateInput, UserStoreUncheckedCreateInput>
    /**
     * In case the UserStore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserStoreUpdateInput, UserStoreUncheckedUpdateInput>
  }

  /**
   * UserStore delete
   */
  export type UserStoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStore
     */
    select?: UserStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStore
     */
    omit?: UserStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoreInclude<ExtArgs> | null
    /**
     * Filter which UserStore to delete.
     */
    where: UserStoreWhereUniqueInput
  }

  /**
   * UserStore deleteMany
   */
  export type UserStoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStores to delete
     */
    where?: UserStoreWhereInput
    /**
     * Limit how many UserStores to delete.
     */
    limit?: number
  }

  /**
   * UserStore findRaw
   */
  export type UserStoreFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserStore aggregateRaw
   */
  export type UserStoreAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserStore.user
   */
  export type UserStore$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UserStore without action
   */
  export type UserStoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStore
     */
    select?: UserStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStore
     */
    omit?: UserStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStoreInclude<ExtArgs> | null
  }


  /**
   * Model UserPhoto
   */

  export type AggregateUserPhoto = {
    _count: UserPhotoCountAggregateOutputType | null
    _avg: UserPhotoAvgAggregateOutputType | null
    _sum: UserPhotoSumAggregateOutputType | null
    _min: UserPhotoMinAggregateOutputType | null
    _max: UserPhotoMaxAggregateOutputType | null
  }

  export type UserPhotoAvgAggregateOutputType = {
    views: number | null
  }

  export type UserPhotoSumAggregateOutputType = {
    views: number | null
  }

  export type UserPhotoMinAggregateOutputType = {
    id: string | null
    url: string | null
    userId: string | null
    views: number | null
    title: string | null
    description: string | null
    adult: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPhotoMaxAggregateOutputType = {
    id: string | null
    url: string | null
    userId: string | null
    views: number | null
    title: string | null
    description: string | null
    adult: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPhotoCountAggregateOutputType = {
    id: number
    url: number
    userId: number
    views: number
    labels: number
    title: number
    description: number
    adult: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPhotoAvgAggregateInputType = {
    views?: true
  }

  export type UserPhotoSumAggregateInputType = {
    views?: true
  }

  export type UserPhotoMinAggregateInputType = {
    id?: true
    url?: true
    userId?: true
    views?: true
    title?: true
    description?: true
    adult?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPhotoMaxAggregateInputType = {
    id?: true
    url?: true
    userId?: true
    views?: true
    title?: true
    description?: true
    adult?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPhotoCountAggregateInputType = {
    id?: true
    url?: true
    userId?: true
    views?: true
    labels?: true
    title?: true
    description?: true
    adult?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPhoto to aggregate.
     */
    where?: UserPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhotos to fetch.
     */
    orderBy?: UserPhotoOrderByWithRelationInput | UserPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPhotos
    **/
    _count?: true | UserPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPhotoMaxAggregateInputType
  }

  export type GetUserPhotoAggregateType<T extends UserPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPhoto[P]>
      : GetScalarType<T[P], AggregateUserPhoto[P]>
  }




  export type UserPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPhotoWhereInput
    orderBy?: UserPhotoOrderByWithAggregationInput | UserPhotoOrderByWithAggregationInput[]
    by: UserPhotoScalarFieldEnum[] | UserPhotoScalarFieldEnum
    having?: UserPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPhotoCountAggregateInputType | true
    _avg?: UserPhotoAvgAggregateInputType
    _sum?: UserPhotoSumAggregateInputType
    _min?: UserPhotoMinAggregateInputType
    _max?: UserPhotoMaxAggregateInputType
  }

  export type UserPhotoGroupByOutputType = {
    id: string
    url: string
    userId: string
    views: number
    labels: string[]
    title: string | null
    description: string | null
    adult: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserPhotoCountAggregateOutputType | null
    _avg: UserPhotoAvgAggregateOutputType | null
    _sum: UserPhotoSumAggregateOutputType | null
    _min: UserPhotoMinAggregateOutputType | null
    _max: UserPhotoMaxAggregateOutputType | null
  }

  type GetUserPhotoGroupByPayload<T extends UserPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], UserPhotoGroupByOutputType[P]>
        }
      >
    >


  export type UserPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    userId?: boolean
    states?: boolean | PhotoStatsDefaultArgs<ExtArgs>
    views?: boolean
    labels?: boolean
    title?: boolean
    description?: boolean
    adult?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contestUpload?: boolean | UserPhoto$contestUploadArgs<ExtArgs>
    likes?: boolean | UserPhoto$likesArgs<ExtArgs>
    _count?: boolean | UserPhotoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPhoto"]>



  export type UserPhotoSelectScalar = {
    id?: boolean
    url?: boolean
    userId?: boolean
    views?: boolean
    labels?: boolean
    title?: boolean
    description?: boolean
    adult?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "userId" | "states" | "views" | "labels" | "title" | "description" | "adult" | "createdAt" | "updatedAt", ExtArgs["result"]["userPhoto"]>
  export type UserPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contestUpload?: boolean | UserPhoto$contestUploadArgs<ExtArgs>
    likes?: boolean | UserPhoto$likesArgs<ExtArgs>
    _count?: boolean | UserPhotoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPhoto"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      contestUpload: Prisma.$ContestPhotoPayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      userId: string
      views: number
      labels: string[]
      title: string | null
      description: string | null
      adult: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPhoto"]>
    composites: {
      states: Prisma.$PhotoStatsPayload | null
    }
  }

  type UserPhotoGetPayload<S extends boolean | null | undefined | UserPhotoDefaultArgs> = $Result.GetResult<Prisma.$UserPhotoPayload, S>

  type UserPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPhotoCountAggregateInputType | true
    }

  export interface UserPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPhoto'], meta: { name: 'UserPhoto' } }
    /**
     * Find zero or one UserPhoto that matches the filter.
     * @param {UserPhotoFindUniqueArgs} args - Arguments to find a UserPhoto
     * @example
     * // Get one UserPhoto
     * const userPhoto = await prisma.userPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPhotoFindUniqueArgs>(args: SelectSubset<T, UserPhotoFindUniqueArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPhotoFindUniqueOrThrowArgs} args - Arguments to find a UserPhoto
     * @example
     * // Get one UserPhoto
     * const userPhoto = await prisma.userPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoFindFirstArgs} args - Arguments to find a UserPhoto
     * @example
     * // Get one UserPhoto
     * const userPhoto = await prisma.userPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPhotoFindFirstArgs>(args?: SelectSubset<T, UserPhotoFindFirstArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoFindFirstOrThrowArgs} args - Arguments to find a UserPhoto
     * @example
     * // Get one UserPhoto
     * const userPhoto = await prisma.userPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPhotos
     * const userPhotos = await prisma.userPhoto.findMany()
     * 
     * // Get first 10 UserPhotos
     * const userPhotos = await prisma.userPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPhotoWithIdOnly = await prisma.userPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPhotoFindManyArgs>(args?: SelectSubset<T, UserPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPhoto.
     * @param {UserPhotoCreateArgs} args - Arguments to create a UserPhoto.
     * @example
     * // Create one UserPhoto
     * const UserPhoto = await prisma.userPhoto.create({
     *   data: {
     *     // ... data to create a UserPhoto
     *   }
     * })
     * 
     */
    create<T extends UserPhotoCreateArgs>(args: SelectSubset<T, UserPhotoCreateArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPhotos.
     * @param {UserPhotoCreateManyArgs} args - Arguments to create many UserPhotos.
     * @example
     * // Create many UserPhotos
     * const userPhoto = await prisma.userPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPhotoCreateManyArgs>(args?: SelectSubset<T, UserPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserPhoto.
     * @param {UserPhotoDeleteArgs} args - Arguments to delete one UserPhoto.
     * @example
     * // Delete one UserPhoto
     * const UserPhoto = await prisma.userPhoto.delete({
     *   where: {
     *     // ... filter to delete one UserPhoto
     *   }
     * })
     * 
     */
    delete<T extends UserPhotoDeleteArgs>(args: SelectSubset<T, UserPhotoDeleteArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPhoto.
     * @param {UserPhotoUpdateArgs} args - Arguments to update one UserPhoto.
     * @example
     * // Update one UserPhoto
     * const userPhoto = await prisma.userPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPhotoUpdateArgs>(args: SelectSubset<T, UserPhotoUpdateArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPhotos.
     * @param {UserPhotoDeleteManyArgs} args - Arguments to filter UserPhotos to delete.
     * @example
     * // Delete a few UserPhotos
     * const { count } = await prisma.userPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPhotoDeleteManyArgs>(args?: SelectSubset<T, UserPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPhotos
     * const userPhoto = await prisma.userPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPhotoUpdateManyArgs>(args: SelectSubset<T, UserPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPhoto.
     * @param {UserPhotoUpsertArgs} args - Arguments to update or create a UserPhoto.
     * @example
     * // Update or create a UserPhoto
     * const userPhoto = await prisma.userPhoto.upsert({
     *   create: {
     *     // ... data to create a UserPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPhoto we want to update
     *   }
     * })
     */
    upsert<T extends UserPhotoUpsertArgs>(args: SelectSubset<T, UserPhotoUpsertArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPhotos that matches the filter.
     * @param {UserPhotoFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userPhoto = await prisma.userPhoto.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserPhotoFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserPhoto.
     * @param {UserPhotoAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userPhoto = await prisma.userPhoto.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserPhotoAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoCountArgs} args - Arguments to filter UserPhotos to count.
     * @example
     * // Count the number of UserPhotos
     * const count = await prisma.userPhoto.count({
     *   where: {
     *     // ... the filter for the UserPhotos we want to count
     *   }
     * })
    **/
    count<T extends UserPhotoCountArgs>(
      args?: Subset<T, UserPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPhotoAggregateArgs>(args: Subset<T, UserPhotoAggregateArgs>): Prisma.PrismaPromise<GetUserPhotoAggregateType<T>>

    /**
     * Group by UserPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPhotoGroupByArgs['orderBy'] }
        : { orderBy?: UserPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPhoto model
   */
  readonly fields: UserPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contestUpload<T extends UserPhoto$contestUploadArgs<ExtArgs> = {}>(args?: Subset<T, UserPhoto$contestUploadArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends UserPhoto$likesArgs<ExtArgs> = {}>(args?: Subset<T, UserPhoto$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPhoto model
   */
  interface UserPhotoFieldRefs {
    readonly id: FieldRef<"UserPhoto", 'String'>
    readonly url: FieldRef<"UserPhoto", 'String'>
    readonly userId: FieldRef<"UserPhoto", 'String'>
    readonly views: FieldRef<"UserPhoto", 'Int'>
    readonly labels: FieldRef<"UserPhoto", 'String[]'>
    readonly title: FieldRef<"UserPhoto", 'String'>
    readonly description: FieldRef<"UserPhoto", 'String'>
    readonly adult: FieldRef<"UserPhoto", 'Boolean'>
    readonly createdAt: FieldRef<"UserPhoto", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPhoto findUnique
   */
  export type UserPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * Filter, which UserPhoto to fetch.
     */
    where: UserPhotoWhereUniqueInput
  }

  /**
   * UserPhoto findUniqueOrThrow
   */
  export type UserPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * Filter, which UserPhoto to fetch.
     */
    where: UserPhotoWhereUniqueInput
  }

  /**
   * UserPhoto findFirst
   */
  export type UserPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * Filter, which UserPhoto to fetch.
     */
    where?: UserPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhotos to fetch.
     */
    orderBy?: UserPhotoOrderByWithRelationInput | UserPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPhotos.
     */
    cursor?: UserPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPhotos.
     */
    distinct?: UserPhotoScalarFieldEnum | UserPhotoScalarFieldEnum[]
  }

  /**
   * UserPhoto findFirstOrThrow
   */
  export type UserPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * Filter, which UserPhoto to fetch.
     */
    where?: UserPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhotos to fetch.
     */
    orderBy?: UserPhotoOrderByWithRelationInput | UserPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPhotos.
     */
    cursor?: UserPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPhotos.
     */
    distinct?: UserPhotoScalarFieldEnum | UserPhotoScalarFieldEnum[]
  }

  /**
   * UserPhoto findMany
   */
  export type UserPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * Filter, which UserPhotos to fetch.
     */
    where?: UserPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhotos to fetch.
     */
    orderBy?: UserPhotoOrderByWithRelationInput | UserPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPhotos.
     */
    cursor?: UserPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhotos.
     */
    skip?: number
    distinct?: UserPhotoScalarFieldEnum | UserPhotoScalarFieldEnum[]
  }

  /**
   * UserPhoto create
   */
  export type UserPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPhoto.
     */
    data: XOR<UserPhotoCreateInput, UserPhotoUncheckedCreateInput>
  }

  /**
   * UserPhoto createMany
   */
  export type UserPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPhotos.
     */
    data: UserPhotoCreateManyInput | UserPhotoCreateManyInput[]
  }

  /**
   * UserPhoto update
   */
  export type UserPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPhoto.
     */
    data: XOR<UserPhotoUpdateInput, UserPhotoUncheckedUpdateInput>
    /**
     * Choose, which UserPhoto to update.
     */
    where: UserPhotoWhereUniqueInput
  }

  /**
   * UserPhoto updateMany
   */
  export type UserPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPhotos.
     */
    data: XOR<UserPhotoUpdateManyMutationInput, UserPhotoUncheckedUpdateManyInput>
    /**
     * Filter which UserPhotos to update
     */
    where?: UserPhotoWhereInput
    /**
     * Limit how many UserPhotos to update.
     */
    limit?: number
  }

  /**
   * UserPhoto upsert
   */
  export type UserPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPhoto to update in case it exists.
     */
    where: UserPhotoWhereUniqueInput
    /**
     * In case the UserPhoto found by the `where` argument doesn't exist, create a new UserPhoto with this data.
     */
    create: XOR<UserPhotoCreateInput, UserPhotoUncheckedCreateInput>
    /**
     * In case the UserPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPhotoUpdateInput, UserPhotoUncheckedUpdateInput>
  }

  /**
   * UserPhoto delete
   */
  export type UserPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * Filter which UserPhoto to delete.
     */
    where: UserPhotoWhereUniqueInput
  }

  /**
   * UserPhoto deleteMany
   */
  export type UserPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPhotos to delete
     */
    where?: UserPhotoWhereInput
    /**
     * Limit how many UserPhotos to delete.
     */
    limit?: number
  }

  /**
   * UserPhoto findRaw
   */
  export type UserPhotoFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserPhoto aggregateRaw
   */
  export type UserPhotoAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserPhoto.contestUpload
   */
  export type UserPhoto$contestUploadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    where?: ContestPhotoWhereInput
    orderBy?: ContestPhotoOrderByWithRelationInput | ContestPhotoOrderByWithRelationInput[]
    cursor?: ContestPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestPhotoScalarFieldEnum | ContestPhotoScalarFieldEnum[]
  }

  /**
   * UserPhoto.likes
   */
  export type UserPhoto$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * UserPhoto without action
   */
  export type UserPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
  }


  /**
   * Model Like
   */

  export type AggregateLike = {
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  export type LikeMinAggregateOutputType = {
    id: string | null
    providerId: string | null
    photoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LikeMaxAggregateOutputType = {
    id: string | null
    providerId: string | null
    photoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LikeCountAggregateOutputType = {
    id: number
    providerId: number
    photoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LikeMinAggregateInputType = {
    id?: true
    providerId?: true
    photoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LikeMaxAggregateInputType = {
    id?: true
    providerId?: true
    photoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LikeCountAggregateInputType = {
    id?: true
    providerId?: true
    photoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Like to aggregate.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Likes
    **/
    _count?: true | LikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikeMaxAggregateInputType
  }

  export type GetLikeAggregateType<T extends LikeAggregateArgs> = {
        [P in keyof T & keyof AggregateLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLike[P]>
      : GetScalarType<T[P], AggregateLike[P]>
  }




  export type LikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithAggregationInput | LikeOrderByWithAggregationInput[]
    by: LikeScalarFieldEnum[] | LikeScalarFieldEnum
    having?: LikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikeCountAggregateInputType | true
    _min?: LikeMinAggregateInputType
    _max?: LikeMaxAggregateInputType
  }

  export type LikeGroupByOutputType = {
    id: string
    providerId: string
    photoId: string
    createdAt: Date
    updatedAt: Date
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  type GetLikeGroupByPayload<T extends LikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikeGroupByOutputType[P]>
            : GetScalarType<T[P], LikeGroupByOutputType[P]>
        }
      >
    >


  export type LikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    photoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | UserDefaultArgs<ExtArgs>
    photo?: boolean | UserPhotoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>



  export type LikeSelectScalar = {
    id?: boolean
    providerId?: boolean
    photoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "photoId" | "createdAt" | "updatedAt", ExtArgs["result"]["like"]>
  export type LikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | UserDefaultArgs<ExtArgs>
    photo?: boolean | UserPhotoDefaultArgs<ExtArgs>
  }

  export type $LikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Like"
    objects: {
      provider: Prisma.$UserPayload<ExtArgs>
      photo: Prisma.$UserPhotoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerId: string
      photoId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["like"]>
    composites: {}
  }

  type LikeGetPayload<S extends boolean | null | undefined | LikeDefaultArgs> = $Result.GetResult<Prisma.$LikePayload, S>

  type LikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LikeCountAggregateInputType | true
    }

  export interface LikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Like'], meta: { name: 'Like' } }
    /**
     * Find zero or one Like that matches the filter.
     * @param {LikeFindUniqueArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikeFindUniqueArgs>(args: SelectSubset<T, LikeFindUniqueArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Like that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LikeFindUniqueOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikeFindUniqueOrThrowArgs>(args: SelectSubset<T, LikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Like that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikeFindFirstArgs>(args?: SelectSubset<T, LikeFindFirstArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Like that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikeFindFirstOrThrowArgs>(args?: SelectSubset<T, LikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Likes
     * const likes = await prisma.like.findMany()
     * 
     * // Get first 10 Likes
     * const likes = await prisma.like.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likeWithIdOnly = await prisma.like.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LikeFindManyArgs>(args?: SelectSubset<T, LikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Like.
     * @param {LikeCreateArgs} args - Arguments to create a Like.
     * @example
     * // Create one Like
     * const Like = await prisma.like.create({
     *   data: {
     *     // ... data to create a Like
     *   }
     * })
     * 
     */
    create<T extends LikeCreateArgs>(args: SelectSubset<T, LikeCreateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Likes.
     * @param {LikeCreateManyArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikeCreateManyArgs>(args?: SelectSubset<T, LikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Like.
     * @param {LikeDeleteArgs} args - Arguments to delete one Like.
     * @example
     * // Delete one Like
     * const Like = await prisma.like.delete({
     *   where: {
     *     // ... filter to delete one Like
     *   }
     * })
     * 
     */
    delete<T extends LikeDeleteArgs>(args: SelectSubset<T, LikeDeleteArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Like.
     * @param {LikeUpdateArgs} args - Arguments to update one Like.
     * @example
     * // Update one Like
     * const like = await prisma.like.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikeUpdateArgs>(args: SelectSubset<T, LikeUpdateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Likes.
     * @param {LikeDeleteManyArgs} args - Arguments to filter Likes to delete.
     * @example
     * // Delete a few Likes
     * const { count } = await prisma.like.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikeDeleteManyArgs>(args?: SelectSubset<T, LikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikeUpdateManyArgs>(args: SelectSubset<T, LikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Like.
     * @param {LikeUpsertArgs} args - Arguments to update or create a Like.
     * @example
     * // Update or create a Like
     * const like = await prisma.like.upsert({
     *   create: {
     *     // ... data to create a Like
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Like we want to update
     *   }
     * })
     */
    upsert<T extends LikeUpsertArgs>(args: SelectSubset<T, LikeUpsertArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Likes that matches the filter.
     * @param {LikeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const like = await prisma.like.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: LikeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Like.
     * @param {LikeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const like = await prisma.like.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LikeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCountArgs} args - Arguments to filter Likes to count.
     * @example
     * // Count the number of Likes
     * const count = await prisma.like.count({
     *   where: {
     *     // ... the filter for the Likes we want to count
     *   }
     * })
    **/
    count<T extends LikeCountArgs>(
      args?: Subset<T, LikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikeAggregateArgs>(args: Subset<T, LikeAggregateArgs>): Prisma.PrismaPromise<GetLikeAggregateType<T>>

    /**
     * Group by Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikeGroupByArgs['orderBy'] }
        : { orderBy?: LikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Like model
   */
  readonly fields: LikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Like.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    photo<T extends UserPhotoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserPhotoDefaultArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Like model
   */
  interface LikeFieldRefs {
    readonly id: FieldRef<"Like", 'String'>
    readonly providerId: FieldRef<"Like", 'String'>
    readonly photoId: FieldRef<"Like", 'String'>
    readonly createdAt: FieldRef<"Like", 'DateTime'>
    readonly updatedAt: FieldRef<"Like", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Like findUnique
   */
  export type LikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findUniqueOrThrow
   */
  export type LikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findFirst
   */
  export type LikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findFirstOrThrow
   */
  export type LikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findMany
   */
  export type LikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like create
   */
  export type LikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to create a Like.
     */
    data: XOR<LikeCreateInput, LikeUncheckedCreateInput>
  }

  /**
   * Like createMany
   */
  export type LikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
  }

  /**
   * Like update
   */
  export type LikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to update a Like.
     */
    data: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
    /**
     * Choose, which Like to update.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like updateMany
   */
  export type LikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
    /**
     * Limit how many Likes to update.
     */
    limit?: number
  }

  /**
   * Like upsert
   */
  export type LikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The filter to search for the Like to update in case it exists.
     */
    where: LikeWhereUniqueInput
    /**
     * In case the Like found by the `where` argument doesn't exist, create a new Like with this data.
     */
    create: XOR<LikeCreateInput, LikeUncheckedCreateInput>
    /**
     * In case the Like was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
  }

  /**
   * Like delete
   */
  export type LikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter which Like to delete.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like deleteMany
   */
  export type LikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Likes to delete
     */
    where?: LikeWhereInput
    /**
     * Limit how many Likes to delete.
     */
    limit?: number
  }

  /**
   * Like findRaw
   */
  export type LikeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Like aggregateRaw
   */
  export type LikeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Like without action
   */
  export type LikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
  }


  /**
   * Model Otp
   */

  export type AggregateOtp = {
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  export type OtpMinAggregateOutputType = {
    id: string | null
    code: string | null
    expires_in: Date | null
    userId: string | null
    otpStatus: $Enums.OtpStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
  }

  export type OtpMaxAggregateOutputType = {
    id: string | null
    code: string | null
    expires_in: Date | null
    userId: string | null
    otpStatus: $Enums.OtpStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
  }

  export type OtpCountAggregateOutputType = {
    id: number
    code: number
    expires_in: number
    userId: number
    otpStatus: number
    createdAt: number
    updatedAt: number
    expiresAt: number
    _all: number
  }


  export type OtpMinAggregateInputType = {
    id?: true
    code?: true
    expires_in?: true
    userId?: true
    otpStatus?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
  }

  export type OtpMaxAggregateInputType = {
    id?: true
    code?: true
    expires_in?: true
    userId?: true
    otpStatus?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
  }

  export type OtpCountAggregateInputType = {
    id?: true
    code?: true
    expires_in?: true
    userId?: true
    otpStatus?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    _all?: true
  }

  export type OtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otp to aggregate.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Otps
    **/
    _count?: true | OtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpMaxAggregateInputType
  }

  export type GetOtpAggregateType<T extends OtpAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp[P]>
      : GetScalarType<T[P], AggregateOtp[P]>
  }




  export type OtpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
    orderBy?: OtpOrderByWithAggregationInput | OtpOrderByWithAggregationInput[]
    by: OtpScalarFieldEnum[] | OtpScalarFieldEnum
    having?: OtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCountAggregateInputType | true
    _min?: OtpMinAggregateInputType
    _max?: OtpMaxAggregateInputType
  }

  export type OtpGroupByOutputType = {
    id: string
    code: string
    expires_in: Date
    userId: string
    otpStatus: $Enums.OtpStatus
    createdAt: Date
    updatedAt: Date
    expiresAt: Date
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  type GetOtpGroupByPayload<T extends OtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpGroupByOutputType[P]>
            : GetScalarType<T[P], OtpGroupByOutputType[P]>
        }
      >
    >


  export type OtpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    expires_in?: boolean
    userId?: boolean
    otpStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["otp"]>



  export type OtpSelectScalar = {
    id?: boolean
    code?: boolean
    expires_in?: boolean
    userId?: boolean
    otpStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
  }

  export type OtpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "expires_in" | "userId" | "otpStatus" | "createdAt" | "updatedAt" | "expiresAt", ExtArgs["result"]["otp"]>
  export type OtpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OtpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Otp"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      expires_in: Date
      userId: string
      otpStatus: $Enums.OtpStatus
      createdAt: Date
      updatedAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["otp"]>
    composites: {}
  }

  type OtpGetPayload<S extends boolean | null | undefined | OtpDefaultArgs> = $Result.GetResult<Prisma.$OtpPayload, S>

  type OtpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OtpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OtpCountAggregateInputType | true
    }

  export interface OtpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Otp'], meta: { name: 'Otp' } }
    /**
     * Find zero or one Otp that matches the filter.
     * @param {OtpFindUniqueArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtpFindUniqueArgs>(args: SelectSubset<T, OtpFindUniqueArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Otp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OtpFindUniqueOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtpFindUniqueOrThrowArgs>(args: SelectSubset<T, OtpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtpFindFirstArgs>(args?: SelectSubset<T, OtpFindFirstArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtpFindFirstOrThrowArgs>(args?: SelectSubset<T, OtpFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otp.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpWithIdOnly = await prisma.otp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtpFindManyArgs>(args?: SelectSubset<T, OtpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Otp.
     * @param {OtpCreateArgs} args - Arguments to create a Otp.
     * @example
     * // Create one Otp
     * const Otp = await prisma.otp.create({
     *   data: {
     *     // ... data to create a Otp
     *   }
     * })
     * 
     */
    create<T extends OtpCreateArgs>(args: SelectSubset<T, OtpCreateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Otps.
     * @param {OtpCreateManyArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtpCreateManyArgs>(args?: SelectSubset<T, OtpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Otp.
     * @param {OtpDeleteArgs} args - Arguments to delete one Otp.
     * @example
     * // Delete one Otp
     * const Otp = await prisma.otp.delete({
     *   where: {
     *     // ... filter to delete one Otp
     *   }
     * })
     * 
     */
    delete<T extends OtpDeleteArgs>(args: SelectSubset<T, OtpDeleteArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Otp.
     * @param {OtpUpdateArgs} args - Arguments to update one Otp.
     * @example
     * // Update one Otp
     * const otp = await prisma.otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtpUpdateArgs>(args: SelectSubset<T, OtpUpdateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Otps.
     * @param {OtpDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtpDeleteManyArgs>(args?: SelectSubset<T, OtpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtpUpdateManyArgs>(args: SelectSubset<T, OtpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Otp.
     * @param {OtpUpsertArgs} args - Arguments to update or create a Otp.
     * @example
     * // Update or create a Otp
     * const otp = await prisma.otp.upsert({
     *   create: {
     *     // ... data to create a Otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp we want to update
     *   }
     * })
     */
    upsert<T extends OtpUpsertArgs>(args: SelectSubset<T, OtpUpsertArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Otps that matches the filter.
     * @param {OtpFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const otp = await prisma.otp.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: OtpFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Otp.
     * @param {OtpAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const otp = await prisma.otp.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: OtpAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otp.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends OtpCountArgs>(
      args?: Subset<T, OtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAggregateArgs>(args: Subset<T, OtpAggregateArgs>): Prisma.PrismaPromise<GetOtpAggregateType<T>>

    /**
     * Group by Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpGroupByArgs['orderBy'] }
        : { orderBy?: OtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Otp model
   */
  readonly fields: OtpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Otp model
   */
  interface OtpFieldRefs {
    readonly id: FieldRef<"Otp", 'String'>
    readonly code: FieldRef<"Otp", 'String'>
    readonly expires_in: FieldRef<"Otp", 'DateTime'>
    readonly userId: FieldRef<"Otp", 'String'>
    readonly otpStatus: FieldRef<"Otp", 'OtpStatus'>
    readonly createdAt: FieldRef<"Otp", 'DateTime'>
    readonly updatedAt: FieldRef<"Otp", 'DateTime'>
    readonly expiresAt: FieldRef<"Otp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Otp findUnique
   */
  export type OtpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findUniqueOrThrow
   */
  export type OtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findFirst
   */
  export type OtpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findFirstOrThrow
   */
  export type OtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findMany
   */
  export type OtpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otps to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp create
   */
  export type OtpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The data needed to create a Otp.
     */
    data: XOR<OtpCreateInput, OtpUncheckedCreateInput>
  }

  /**
   * Otp createMany
   */
  export type OtpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Otps.
     */
    data: OtpCreateManyInput | OtpCreateManyInput[]
  }

  /**
   * Otp update
   */
  export type OtpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The data needed to update a Otp.
     */
    data: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
    /**
     * Choose, which Otp to update.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp updateMany
   */
  export type OtpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to update.
     */
    limit?: number
  }

  /**
   * Otp upsert
   */
  export type OtpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The filter to search for the Otp to update in case it exists.
     */
    where: OtpWhereUniqueInput
    /**
     * In case the Otp found by the `where` argument doesn't exist, create a new Otp with this data.
     */
    create: XOR<OtpCreateInput, OtpUncheckedCreateInput>
    /**
     * In case the Otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
  }

  /**
   * Otp delete
   */
  export type OtpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter which Otp to delete.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp deleteMany
   */
  export type OtpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otps to delete
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to delete.
     */
    limit?: number
  }

  /**
   * Otp findRaw
   */
  export type OtpFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Otp aggregateRaw
   */
  export type OtpAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Otp without action
   */
  export type OtpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    text: string | null
    providerId: string | null
    receiverId: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    text: string | null
    providerId: string | null
    receiverId: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    text: number
    providerId: number
    receiverId: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    text?: true
    providerId?: true
    receiverId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    text?: true
    providerId?: true
    receiverId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    text?: true
    providerId?: true
    receiverId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    text: string
    providerId: string
    receiverId: string
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    providerId?: boolean
    receiverId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | ContestPhotoDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    CommentReplies?: boolean | Comment$CommentRepliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>



  export type CommentSelectScalar = {
    id?: boolean
    text?: boolean
    providerId?: boolean
    receiverId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "text" | "providerId" | "receiverId" | "parentId" | "createdAt" | "updatedAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | ContestPhotoDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    CommentReplies?: boolean | Comment$CommentRepliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      provider: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$ContestPhotoPayload<ExtArgs>
      parent: Prisma.$CommentPayload<ExtArgs> | null
      CommentReplies: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      providerId: string
      receiverId: string
      parentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * @param {CommentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const comment = await prisma.comment.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CommentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Comment.
     * @param {CommentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const comment = await prisma.comment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CommentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receiver<T extends ContestPhotoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestPhotoDefaultArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends Comment$parentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    CommentReplies<T extends Comment$CommentRepliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$CommentRepliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly text: FieldRef<"Comment", 'String'>
    readonly providerId: FieldRef<"Comment", 'String'>
    readonly receiverId: FieldRef<"Comment", 'String'>
    readonly parentId: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment findRaw
   */
  export type CommentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Comment aggregateRaw
   */
  export type CommentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Comment.parent
   */
  export type Comment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.CommentReplies
   */
  export type Comment$CommentRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Follow
   */

  export type AggregateFollow = {
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  export type FollowMinAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FollowMaxAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FollowCountAggregateOutputType = {
    id: number
    followerId: number
    followingId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FollowMinAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FollowMaxAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FollowCountAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follow to aggregate.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Follows
    **/
    _count?: true | FollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowMaxAggregateInputType
  }

  export type GetFollowAggregateType<T extends FollowAggregateArgs> = {
        [P in keyof T & keyof AggregateFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollow[P]>
      : GetScalarType<T[P], AggregateFollow[P]>
  }




  export type FollowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithAggregationInput | FollowOrderByWithAggregationInput[]
    by: FollowScalarFieldEnum[] | FollowScalarFieldEnum
    having?: FollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowCountAggregateInputType | true
    _min?: FollowMinAggregateInputType
    _max?: FollowMaxAggregateInputType
  }

  export type FollowGroupByOutputType = {
    id: string
    followerId: string
    followingId: string
    createdAt: Date
    updatedAt: Date
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  type GetFollowGroupByPayload<T extends FollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowGroupByOutputType[P]>
            : GetScalarType<T[P], FollowGroupByOutputType[P]>
        }
      >
    >


  export type FollowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>



  export type FollowSelectScalar = {
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FollowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "followerId" | "followingId" | "createdAt" | "updatedAt", ExtArgs["result"]["follow"]>
  export type FollowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FollowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Follow"
    objects: {
      follower: Prisma.$UserPayload<ExtArgs>
      following: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      followerId: string
      followingId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["follow"]>
    composites: {}
  }

  type FollowGetPayload<S extends boolean | null | undefined | FollowDefaultArgs> = $Result.GetResult<Prisma.$FollowPayload, S>

  type FollowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FollowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowCountAggregateInputType | true
    }

  export interface FollowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Follow'], meta: { name: 'Follow' } }
    /**
     * Find zero or one Follow that matches the filter.
     * @param {FollowFindUniqueArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowFindUniqueArgs>(args: SelectSubset<T, FollowFindUniqueArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Follow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowFindUniqueOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowFindFirstArgs>(args?: SelectSubset<T, FollowFindFirstArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follow.findMany()
     * 
     * // Get first 10 Follows
     * const follows = await prisma.follow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followWithIdOnly = await prisma.follow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowFindManyArgs>(args?: SelectSubset<T, FollowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Follow.
     * @param {FollowCreateArgs} args - Arguments to create a Follow.
     * @example
     * // Create one Follow
     * const Follow = await prisma.follow.create({
     *   data: {
     *     // ... data to create a Follow
     *   }
     * })
     * 
     */
    create<T extends FollowCreateArgs>(args: SelectSubset<T, FollowCreateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Follows.
     * @param {FollowCreateManyArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowCreateManyArgs>(args?: SelectSubset<T, FollowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Follow.
     * @param {FollowDeleteArgs} args - Arguments to delete one Follow.
     * @example
     * // Delete one Follow
     * const Follow = await prisma.follow.delete({
     *   where: {
     *     // ... filter to delete one Follow
     *   }
     * })
     * 
     */
    delete<T extends FollowDeleteArgs>(args: SelectSubset<T, FollowDeleteArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Follow.
     * @param {FollowUpdateArgs} args - Arguments to update one Follow.
     * @example
     * // Update one Follow
     * const follow = await prisma.follow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowUpdateArgs>(args: SelectSubset<T, FollowUpdateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Follows.
     * @param {FollowDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowDeleteManyArgs>(args?: SelectSubset<T, FollowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowUpdateManyArgs>(args: SelectSubset<T, FollowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Follow.
     * @param {FollowUpsertArgs} args - Arguments to update or create a Follow.
     * @example
     * // Update or create a Follow
     * const follow = await prisma.follow.upsert({
     *   create: {
     *     // ... data to create a Follow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follow we want to update
     *   }
     * })
     */
    upsert<T extends FollowUpsertArgs>(args: SelectSubset<T, FollowUpsertArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Follows that matches the filter.
     * @param {FollowFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const follow = await prisma.follow.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FollowFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Follow.
     * @param {FollowAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const follow = await prisma.follow.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FollowAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follow.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
    **/
    count<T extends FollowCountArgs>(
      args?: Subset<T, FollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowAggregateArgs>(args: Subset<T, FollowAggregateArgs>): Prisma.PrismaPromise<GetFollowAggregateType<T>>

    /**
     * Group by Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowGroupByArgs['orderBy'] }
        : { orderBy?: FollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Follow model
   */
  readonly fields: FollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Follow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    follower<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    following<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Follow model
   */
  interface FollowFieldRefs {
    readonly id: FieldRef<"Follow", 'String'>
    readonly followerId: FieldRef<"Follow", 'String'>
    readonly followingId: FieldRef<"Follow", 'String'>
    readonly createdAt: FieldRef<"Follow", 'DateTime'>
    readonly updatedAt: FieldRef<"Follow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Follow findUnique
   */
  export type FollowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findUniqueOrThrow
   */
  export type FollowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findFirst
   */
  export type FollowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findFirstOrThrow
   */
  export type FollowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findMany
   */
  export type FollowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow create
   */
  export type FollowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to create a Follow.
     */
    data: XOR<FollowCreateInput, FollowUncheckedCreateInput>
  }

  /**
   * Follow createMany
   */
  export type FollowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
  }

  /**
   * Follow update
   */
  export type FollowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to update a Follow.
     */
    data: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
    /**
     * Choose, which Follow to update.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow updateMany
   */
  export type FollowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to update.
     */
    limit?: number
  }

  /**
   * Follow upsert
   */
  export type FollowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The filter to search for the Follow to update in case it exists.
     */
    where: FollowWhereUniqueInput
    /**
     * In case the Follow found by the `where` argument doesn't exist, create a new Follow with this data.
     */
    create: XOR<FollowCreateInput, FollowUncheckedCreateInput>
    /**
     * In case the Follow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
  }

  /**
   * Follow delete
   */
  export type FollowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter which Follow to delete.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow deleteMany
   */
  export type FollowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follows to delete
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to delete.
     */
    limit?: number
  }

  /**
   * Follow findRaw
   */
  export type FollowFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Follow aggregateRaw
   */
  export type FollowAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Follow without action
   */
  export type FollowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
  }


  /**
   * Model Vote
   */

  export type AggregateVote = {
    _count: VoteCountAggregateOutputType | null
    _min: VoteMinAggregateOutputType | null
    _max: VoteMaxAggregateOutputType | null
  }

  export type VoteMinAggregateOutputType = {
    id: string | null
    providerId: string | null
    photoId: string | null
    contestId: string | null
    type: $Enums.VoteType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoteMaxAggregateOutputType = {
    id: string | null
    providerId: string | null
    photoId: string | null
    contestId: string | null
    type: $Enums.VoteType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoteCountAggregateOutputType = {
    id: number
    providerId: number
    photoId: number
    contestId: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VoteMinAggregateInputType = {
    id?: true
    providerId?: true
    photoId?: true
    contestId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoteMaxAggregateInputType = {
    id?: true
    providerId?: true
    photoId?: true
    contestId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoteCountAggregateInputType = {
    id?: true
    providerId?: true
    photoId?: true
    contestId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vote to aggregate.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Votes
    **/
    _count?: true | VoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoteMaxAggregateInputType
  }

  export type GetVoteAggregateType<T extends VoteAggregateArgs> = {
        [P in keyof T & keyof AggregateVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVote[P]>
      : GetScalarType<T[P], AggregateVote[P]>
  }




  export type VoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithAggregationInput | VoteOrderByWithAggregationInput[]
    by: VoteScalarFieldEnum[] | VoteScalarFieldEnum
    having?: VoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoteCountAggregateInputType | true
    _min?: VoteMinAggregateInputType
    _max?: VoteMaxAggregateInputType
  }

  export type VoteGroupByOutputType = {
    id: string
    providerId: string
    photoId: string
    contestId: string
    type: $Enums.VoteType
    createdAt: Date
    updatedAt: Date
    _count: VoteCountAggregateOutputType | null
    _min: VoteMinAggregateOutputType | null
    _max: VoteMaxAggregateOutputType | null
  }

  type GetVoteGroupByPayload<T extends VoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoteGroupByOutputType[P]>
            : GetScalarType<T[P], VoteGroupByOutputType[P]>
        }
      >
    >


  export type VoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    photoId?: boolean
    contestId?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | UserDefaultArgs<ExtArgs>
    photo?: boolean | ContestPhotoDefaultArgs<ExtArgs>
    contest?: boolean | ContestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>



  export type VoteSelectScalar = {
    id?: boolean
    providerId?: boolean
    photoId?: boolean
    contestId?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "photoId" | "contestId" | "type" | "createdAt" | "updatedAt", ExtArgs["result"]["vote"]>
  export type VoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | UserDefaultArgs<ExtArgs>
    photo?: boolean | ContestPhotoDefaultArgs<ExtArgs>
    contest?: boolean | ContestDefaultArgs<ExtArgs>
  }

  export type $VotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vote"
    objects: {
      provider: Prisma.$UserPayload<ExtArgs>
      photo: Prisma.$ContestPhotoPayload<ExtArgs>
      contest: Prisma.$ContestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerId: string
      photoId: string
      contestId: string
      type: $Enums.VoteType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vote"]>
    composites: {}
  }

  type VoteGetPayload<S extends boolean | null | undefined | VoteDefaultArgs> = $Result.GetResult<Prisma.$VotePayload, S>

  type VoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoteCountAggregateInputType | true
    }

  export interface VoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vote'], meta: { name: 'Vote' } }
    /**
     * Find zero or one Vote that matches the filter.
     * @param {VoteFindUniqueArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoteFindUniqueArgs>(args: SelectSubset<T, VoteFindUniqueArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoteFindUniqueOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoteFindUniqueOrThrowArgs>(args: SelectSubset<T, VoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoteFindFirstArgs>(args?: SelectSubset<T, VoteFindFirstArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoteFindFirstOrThrowArgs>(args?: SelectSubset<T, VoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Votes
     * const votes = await prisma.vote.findMany()
     * 
     * // Get first 10 Votes
     * const votes = await prisma.vote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voteWithIdOnly = await prisma.vote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoteFindManyArgs>(args?: SelectSubset<T, VoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vote.
     * @param {VoteCreateArgs} args - Arguments to create a Vote.
     * @example
     * // Create one Vote
     * const Vote = await prisma.vote.create({
     *   data: {
     *     // ... data to create a Vote
     *   }
     * })
     * 
     */
    create<T extends VoteCreateArgs>(args: SelectSubset<T, VoteCreateArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Votes.
     * @param {VoteCreateManyArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const vote = await prisma.vote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoteCreateManyArgs>(args?: SelectSubset<T, VoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vote.
     * @param {VoteDeleteArgs} args - Arguments to delete one Vote.
     * @example
     * // Delete one Vote
     * const Vote = await prisma.vote.delete({
     *   where: {
     *     // ... filter to delete one Vote
     *   }
     * })
     * 
     */
    delete<T extends VoteDeleteArgs>(args: SelectSubset<T, VoteDeleteArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vote.
     * @param {VoteUpdateArgs} args - Arguments to update one Vote.
     * @example
     * // Update one Vote
     * const vote = await prisma.vote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoteUpdateArgs>(args: SelectSubset<T, VoteUpdateArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Votes.
     * @param {VoteDeleteManyArgs} args - Arguments to filter Votes to delete.
     * @example
     * // Delete a few Votes
     * const { count } = await prisma.vote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoteDeleteManyArgs>(args?: SelectSubset<T, VoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Votes
     * const vote = await prisma.vote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoteUpdateManyArgs>(args: SelectSubset<T, VoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vote.
     * @param {VoteUpsertArgs} args - Arguments to update or create a Vote.
     * @example
     * // Update or create a Vote
     * const vote = await prisma.vote.upsert({
     *   create: {
     *     // ... data to create a Vote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vote we want to update
     *   }
     * })
     */
    upsert<T extends VoteUpsertArgs>(args: SelectSubset<T, VoteUpsertArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Votes that matches the filter.
     * @param {VoteFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const vote = await prisma.vote.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: VoteFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Vote.
     * @param {VoteAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const vote = await prisma.vote.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: VoteAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteCountArgs} args - Arguments to filter Votes to count.
     * @example
     * // Count the number of Votes
     * const count = await prisma.vote.count({
     *   where: {
     *     // ... the filter for the Votes we want to count
     *   }
     * })
    **/
    count<T extends VoteCountArgs>(
      args?: Subset<T, VoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoteAggregateArgs>(args: Subset<T, VoteAggregateArgs>): Prisma.PrismaPromise<GetVoteAggregateType<T>>

    /**
     * Group by Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoteGroupByArgs['orderBy'] }
        : { orderBy?: VoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vote model
   */
  readonly fields: VoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    photo<T extends ContestPhotoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestPhotoDefaultArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contest<T extends ContestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestDefaultArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vote model
   */
  interface VoteFieldRefs {
    readonly id: FieldRef<"Vote", 'String'>
    readonly providerId: FieldRef<"Vote", 'String'>
    readonly photoId: FieldRef<"Vote", 'String'>
    readonly contestId: FieldRef<"Vote", 'String'>
    readonly type: FieldRef<"Vote", 'VoteType'>
    readonly createdAt: FieldRef<"Vote", 'DateTime'>
    readonly updatedAt: FieldRef<"Vote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vote findUnique
   */
  export type VoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote findUniqueOrThrow
   */
  export type VoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote findFirst
   */
  export type VoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Votes.
     */
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote findFirstOrThrow
   */
  export type VoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Votes.
     */
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote findMany
   */
  export type VoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Votes to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote create
   */
  export type VoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Vote.
     */
    data: XOR<VoteCreateInput, VoteUncheckedCreateInput>
  }

  /**
   * Vote createMany
   */
  export type VoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Votes.
     */
    data: VoteCreateManyInput | VoteCreateManyInput[]
  }

  /**
   * Vote update
   */
  export type VoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Vote.
     */
    data: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>
    /**
     * Choose, which Vote to update.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote updateMany
   */
  export type VoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Votes.
     */
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyInput>
    /**
     * Filter which Votes to update
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to update.
     */
    limit?: number
  }

  /**
   * Vote upsert
   */
  export type VoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Vote to update in case it exists.
     */
    where: VoteWhereUniqueInput
    /**
     * In case the Vote found by the `where` argument doesn't exist, create a new Vote with this data.
     */
    create: XOR<VoteCreateInput, VoteUncheckedCreateInput>
    /**
     * In case the Vote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>
  }

  /**
   * Vote delete
   */
  export type VoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter which Vote to delete.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote deleteMany
   */
  export type VoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Votes to delete
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to delete.
     */
    limit?: number
  }

  /**
   * Vote findRaw
   */
  export type VoteFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Vote aggregateRaw
   */
  export type VoteAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Vote without action
   */
  export type VoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
  }


  /**
   * Model UserLevel
   */

  export type AggregateUserLevel = {
    _count: UserLevelCountAggregateOutputType | null
    _min: UserLevelMinAggregateOutputType | null
    _max: UserLevelMaxAggregateOutputType | null
  }

  export type UserLevelMinAggregateOutputType = {
    id: string | null
    userId: string | null
    levelId: string | null
  }

  export type UserLevelMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    levelId: string | null
  }

  export type UserLevelCountAggregateOutputType = {
    id: number
    userId: number
    levelId: number
    _all: number
  }


  export type UserLevelMinAggregateInputType = {
    id?: true
    userId?: true
    levelId?: true
  }

  export type UserLevelMaxAggregateInputType = {
    id?: true
    userId?: true
    levelId?: true
  }

  export type UserLevelCountAggregateInputType = {
    id?: true
    userId?: true
    levelId?: true
    _all?: true
  }

  export type UserLevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLevel to aggregate.
     */
    where?: UserLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLevels to fetch.
     */
    orderBy?: UserLevelOrderByWithRelationInput | UserLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLevels
    **/
    _count?: true | UserLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLevelMaxAggregateInputType
  }

  export type GetUserLevelAggregateType<T extends UserLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLevel[P]>
      : GetScalarType<T[P], AggregateUserLevel[P]>
  }




  export type UserLevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLevelWhereInput
    orderBy?: UserLevelOrderByWithAggregationInput | UserLevelOrderByWithAggregationInput[]
    by: UserLevelScalarFieldEnum[] | UserLevelScalarFieldEnum
    having?: UserLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLevelCountAggregateInputType | true
    _min?: UserLevelMinAggregateInputType
    _max?: UserLevelMaxAggregateInputType
  }

  export type UserLevelGroupByOutputType = {
    id: string
    userId: string
    levelId: string
    _count: UserLevelCountAggregateOutputType | null
    _min: UserLevelMinAggregateOutputType | null
    _max: UserLevelMaxAggregateOutputType | null
  }

  type GetUserLevelGroupByPayload<T extends UserLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLevelGroupByOutputType[P]>
            : GetScalarType<T[P], UserLevelGroupByOutputType[P]>
        }
      >
    >


  export type UserLevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    levelId?: boolean
  }, ExtArgs["result"]["userLevel"]>



  export type UserLevelSelectScalar = {
    id?: boolean
    userId?: boolean
    levelId?: boolean
  }

  export type UserLevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "levelId", ExtArgs["result"]["userLevel"]>

  export type $UserLevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLevel"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      levelId: string
    }, ExtArgs["result"]["userLevel"]>
    composites: {}
  }

  type UserLevelGetPayload<S extends boolean | null | undefined | UserLevelDefaultArgs> = $Result.GetResult<Prisma.$UserLevelPayload, S>

  type UserLevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLevelCountAggregateInputType | true
    }

  export interface UserLevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLevel'], meta: { name: 'UserLevel' } }
    /**
     * Find zero or one UserLevel that matches the filter.
     * @param {UserLevelFindUniqueArgs} args - Arguments to find a UserLevel
     * @example
     * // Get one UserLevel
     * const userLevel = await prisma.userLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLevelFindUniqueArgs>(args: SelectSubset<T, UserLevelFindUniqueArgs<ExtArgs>>): Prisma__UserLevelClient<$Result.GetResult<Prisma.$UserLevelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLevel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLevelFindUniqueOrThrowArgs} args - Arguments to find a UserLevel
     * @example
     * // Get one UserLevel
     * const userLevel = await prisma.userLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLevelFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLevelClient<$Result.GetResult<Prisma.$UserLevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLevelFindFirstArgs} args - Arguments to find a UserLevel
     * @example
     * // Get one UserLevel
     * const userLevel = await prisma.userLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLevelFindFirstArgs>(args?: SelectSubset<T, UserLevelFindFirstArgs<ExtArgs>>): Prisma__UserLevelClient<$Result.GetResult<Prisma.$UserLevelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLevel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLevelFindFirstOrThrowArgs} args - Arguments to find a UserLevel
     * @example
     * // Get one UserLevel
     * const userLevel = await prisma.userLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLevelFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLevelClient<$Result.GetResult<Prisma.$UserLevelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLevels
     * const userLevels = await prisma.userLevel.findMany()
     * 
     * // Get first 10 UserLevels
     * const userLevels = await prisma.userLevel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userLevelWithIdOnly = await prisma.userLevel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserLevelFindManyArgs>(args?: SelectSubset<T, UserLevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLevel.
     * @param {UserLevelCreateArgs} args - Arguments to create a UserLevel.
     * @example
     * // Create one UserLevel
     * const UserLevel = await prisma.userLevel.create({
     *   data: {
     *     // ... data to create a UserLevel
     *   }
     * })
     * 
     */
    create<T extends UserLevelCreateArgs>(args: SelectSubset<T, UserLevelCreateArgs<ExtArgs>>): Prisma__UserLevelClient<$Result.GetResult<Prisma.$UserLevelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLevels.
     * @param {UserLevelCreateManyArgs} args - Arguments to create many UserLevels.
     * @example
     * // Create many UserLevels
     * const userLevel = await prisma.userLevel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLevelCreateManyArgs>(args?: SelectSubset<T, UserLevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserLevel.
     * @param {UserLevelDeleteArgs} args - Arguments to delete one UserLevel.
     * @example
     * // Delete one UserLevel
     * const UserLevel = await prisma.userLevel.delete({
     *   where: {
     *     // ... filter to delete one UserLevel
     *   }
     * })
     * 
     */
    delete<T extends UserLevelDeleteArgs>(args: SelectSubset<T, UserLevelDeleteArgs<ExtArgs>>): Prisma__UserLevelClient<$Result.GetResult<Prisma.$UserLevelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLevel.
     * @param {UserLevelUpdateArgs} args - Arguments to update one UserLevel.
     * @example
     * // Update one UserLevel
     * const userLevel = await prisma.userLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLevelUpdateArgs>(args: SelectSubset<T, UserLevelUpdateArgs<ExtArgs>>): Prisma__UserLevelClient<$Result.GetResult<Prisma.$UserLevelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLevels.
     * @param {UserLevelDeleteManyArgs} args - Arguments to filter UserLevels to delete.
     * @example
     * // Delete a few UserLevels
     * const { count } = await prisma.userLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLevelDeleteManyArgs>(args?: SelectSubset<T, UserLevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLevels
     * const userLevel = await prisma.userLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLevelUpdateManyArgs>(args: SelectSubset<T, UserLevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserLevel.
     * @param {UserLevelUpsertArgs} args - Arguments to update or create a UserLevel.
     * @example
     * // Update or create a UserLevel
     * const userLevel = await prisma.userLevel.upsert({
     *   create: {
     *     // ... data to create a UserLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLevel we want to update
     *   }
     * })
     */
    upsert<T extends UserLevelUpsertArgs>(args: SelectSubset<T, UserLevelUpsertArgs<ExtArgs>>): Prisma__UserLevelClient<$Result.GetResult<Prisma.$UserLevelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLevels that matches the filter.
     * @param {UserLevelFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userLevel = await prisma.userLevel.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserLevelFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserLevel.
     * @param {UserLevelAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userLevel = await prisma.userLevel.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserLevelAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLevelCountArgs} args - Arguments to filter UserLevels to count.
     * @example
     * // Count the number of UserLevels
     * const count = await prisma.userLevel.count({
     *   where: {
     *     // ... the filter for the UserLevels we want to count
     *   }
     * })
    **/
    count<T extends UserLevelCountArgs>(
      args?: Subset<T, UserLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLevelAggregateArgs>(args: Subset<T, UserLevelAggregateArgs>): Prisma.PrismaPromise<GetUserLevelAggregateType<T>>

    /**
     * Group by UserLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLevelGroupByArgs['orderBy'] }
        : { orderBy?: UserLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLevel model
   */
  readonly fields: UserLevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLevel model
   */
  interface UserLevelFieldRefs {
    readonly id: FieldRef<"UserLevel", 'String'>
    readonly userId: FieldRef<"UserLevel", 'String'>
    readonly levelId: FieldRef<"UserLevel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserLevel findUnique
   */
  export type UserLevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLevel
     */
    select?: UserLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLevel
     */
    omit?: UserLevelOmit<ExtArgs> | null
    /**
     * Filter, which UserLevel to fetch.
     */
    where: UserLevelWhereUniqueInput
  }

  /**
   * UserLevel findUniqueOrThrow
   */
  export type UserLevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLevel
     */
    select?: UserLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLevel
     */
    omit?: UserLevelOmit<ExtArgs> | null
    /**
     * Filter, which UserLevel to fetch.
     */
    where: UserLevelWhereUniqueInput
  }

  /**
   * UserLevel findFirst
   */
  export type UserLevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLevel
     */
    select?: UserLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLevel
     */
    omit?: UserLevelOmit<ExtArgs> | null
    /**
     * Filter, which UserLevel to fetch.
     */
    where?: UserLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLevels to fetch.
     */
    orderBy?: UserLevelOrderByWithRelationInput | UserLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLevels.
     */
    cursor?: UserLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLevels.
     */
    distinct?: UserLevelScalarFieldEnum | UserLevelScalarFieldEnum[]
  }

  /**
   * UserLevel findFirstOrThrow
   */
  export type UserLevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLevel
     */
    select?: UserLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLevel
     */
    omit?: UserLevelOmit<ExtArgs> | null
    /**
     * Filter, which UserLevel to fetch.
     */
    where?: UserLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLevels to fetch.
     */
    orderBy?: UserLevelOrderByWithRelationInput | UserLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLevels.
     */
    cursor?: UserLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLevels.
     */
    distinct?: UserLevelScalarFieldEnum | UserLevelScalarFieldEnum[]
  }

  /**
   * UserLevel findMany
   */
  export type UserLevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLevel
     */
    select?: UserLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLevel
     */
    omit?: UserLevelOmit<ExtArgs> | null
    /**
     * Filter, which UserLevels to fetch.
     */
    where?: UserLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLevels to fetch.
     */
    orderBy?: UserLevelOrderByWithRelationInput | UserLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLevels.
     */
    cursor?: UserLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLevels.
     */
    skip?: number
    distinct?: UserLevelScalarFieldEnum | UserLevelScalarFieldEnum[]
  }

  /**
   * UserLevel create
   */
  export type UserLevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLevel
     */
    select?: UserLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLevel
     */
    omit?: UserLevelOmit<ExtArgs> | null
    /**
     * The data needed to create a UserLevel.
     */
    data: XOR<UserLevelCreateInput, UserLevelUncheckedCreateInput>
  }

  /**
   * UserLevel createMany
   */
  export type UserLevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLevels.
     */
    data: UserLevelCreateManyInput | UserLevelCreateManyInput[]
  }

  /**
   * UserLevel update
   */
  export type UserLevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLevel
     */
    select?: UserLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLevel
     */
    omit?: UserLevelOmit<ExtArgs> | null
    /**
     * The data needed to update a UserLevel.
     */
    data: XOR<UserLevelUpdateInput, UserLevelUncheckedUpdateInput>
    /**
     * Choose, which UserLevel to update.
     */
    where: UserLevelWhereUniqueInput
  }

  /**
   * UserLevel updateMany
   */
  export type UserLevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLevels.
     */
    data: XOR<UserLevelUpdateManyMutationInput, UserLevelUncheckedUpdateManyInput>
    /**
     * Filter which UserLevels to update
     */
    where?: UserLevelWhereInput
    /**
     * Limit how many UserLevels to update.
     */
    limit?: number
  }

  /**
   * UserLevel upsert
   */
  export type UserLevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLevel
     */
    select?: UserLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLevel
     */
    omit?: UserLevelOmit<ExtArgs> | null
    /**
     * The filter to search for the UserLevel to update in case it exists.
     */
    where: UserLevelWhereUniqueInput
    /**
     * In case the UserLevel found by the `where` argument doesn't exist, create a new UserLevel with this data.
     */
    create: XOR<UserLevelCreateInput, UserLevelUncheckedCreateInput>
    /**
     * In case the UserLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLevelUpdateInput, UserLevelUncheckedUpdateInput>
  }

  /**
   * UserLevel delete
   */
  export type UserLevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLevel
     */
    select?: UserLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLevel
     */
    omit?: UserLevelOmit<ExtArgs> | null
    /**
     * Filter which UserLevel to delete.
     */
    where: UserLevelWhereUniqueInput
  }

  /**
   * UserLevel deleteMany
   */
  export type UserLevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLevels to delete
     */
    where?: UserLevelWhereInput
    /**
     * Limit how many UserLevels to delete.
     */
    limit?: number
  }

  /**
   * UserLevel findRaw
   */
  export type UserLevelFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserLevel aggregateRaw
   */
  export type UserLevelAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserLevel without action
   */
  export type UserLevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLevel
     */
    select?: UserLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLevel
     */
    omit?: UserLevelOmit<ExtArgs> | null
  }


  /**
   * Model Level
   */

  export type AggregateLevel = {
    _count: LevelCountAggregateOutputType | null
    _avg: LevelAvgAggregateOutputType | null
    _sum: LevelSumAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  export type LevelAvgAggregateOutputType = {
    level: number | null
  }

  export type LevelSumAggregateOutputType = {
    level: number | null
  }

  export type LevelMinAggregateOutputType = {
    id: string | null
    level: number | null
    levelName: $Enums.LevelName | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LevelMaxAggregateOutputType = {
    id: string | null
    level: number | null
    levelName: $Enums.LevelName | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LevelCountAggregateOutputType = {
    id: number
    level: number
    levelName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LevelAvgAggregateInputType = {
    level?: true
  }

  export type LevelSumAggregateInputType = {
    level?: true
  }

  export type LevelMinAggregateInputType = {
    id?: true
    level?: true
    levelName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LevelMaxAggregateInputType = {
    id?: true
    level?: true
    levelName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LevelCountAggregateInputType = {
    id?: true
    level?: true
    levelName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Level to aggregate.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Levels
    **/
    _count?: true | LevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LevelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LevelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LevelMaxAggregateInputType
  }

  export type GetLevelAggregateType<T extends LevelAggregateArgs> = {
        [P in keyof T & keyof AggregateLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevel[P]>
      : GetScalarType<T[P], AggregateLevel[P]>
  }




  export type LevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelWhereInput
    orderBy?: LevelOrderByWithAggregationInput | LevelOrderByWithAggregationInput[]
    by: LevelScalarFieldEnum[] | LevelScalarFieldEnum
    having?: LevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LevelCountAggregateInputType | true
    _avg?: LevelAvgAggregateInputType
    _sum?: LevelSumAggregateInputType
    _min?: LevelMinAggregateInputType
    _max?: LevelMaxAggregateInputType
  }

  export type LevelGroupByOutputType = {
    id: string
    level: number
    levelName: $Enums.LevelName
    createdAt: Date
    updatedAt: Date
    _count: LevelCountAggregateOutputType | null
    _avg: LevelAvgAggregateOutputType | null
    _sum: LevelSumAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  type GetLevelGroupByPayload<T extends LevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LevelGroupByOutputType[P]>
            : GetScalarType<T[P], LevelGroupByOutputType[P]>
        }
      >
    >


  export type LevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    levelName?: boolean
    requirements?: boolean | LevelRequirementDefaultArgs<ExtArgs>
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["level"]>



  export type LevelSelectScalar = {
    id?: boolean
    level?: boolean
    levelName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "level" | "levelName" | "requirements" | "createdAt" | "updatedAt", ExtArgs["result"]["level"]>
  export type LevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Level"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      level: number
      levelName: $Enums.LevelName
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["level"]>
    composites: {
      requirements: Prisma.$LevelRequirementPayload[]
    }
  }

  type LevelGetPayload<S extends boolean | null | undefined | LevelDefaultArgs> = $Result.GetResult<Prisma.$LevelPayload, S>

  type LevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LevelCountAggregateInputType | true
    }

  export interface LevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Level'], meta: { name: 'Level' } }
    /**
     * Find zero or one Level that matches the filter.
     * @param {LevelFindUniqueArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LevelFindUniqueArgs>(args: SelectSubset<T, LevelFindUniqueArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Level that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LevelFindUniqueOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LevelFindUniqueOrThrowArgs>(args: SelectSubset<T, LevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Level that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindFirstArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LevelFindFirstArgs>(args?: SelectSubset<T, LevelFindFirstArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Level that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindFirstOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LevelFindFirstOrThrowArgs>(args?: SelectSubset<T, LevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Levels
     * const levels = await prisma.level.findMany()
     * 
     * // Get first 10 Levels
     * const levels = await prisma.level.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const levelWithIdOnly = await prisma.level.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LevelFindManyArgs>(args?: SelectSubset<T, LevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Level.
     * @param {LevelCreateArgs} args - Arguments to create a Level.
     * @example
     * // Create one Level
     * const Level = await prisma.level.create({
     *   data: {
     *     // ... data to create a Level
     *   }
     * })
     * 
     */
    create<T extends LevelCreateArgs>(args: SelectSubset<T, LevelCreateArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Levels.
     * @param {LevelCreateManyArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const level = await prisma.level.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LevelCreateManyArgs>(args?: SelectSubset<T, LevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Level.
     * @param {LevelDeleteArgs} args - Arguments to delete one Level.
     * @example
     * // Delete one Level
     * const Level = await prisma.level.delete({
     *   where: {
     *     // ... filter to delete one Level
     *   }
     * })
     * 
     */
    delete<T extends LevelDeleteArgs>(args: SelectSubset<T, LevelDeleteArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Level.
     * @param {LevelUpdateArgs} args - Arguments to update one Level.
     * @example
     * // Update one Level
     * const level = await prisma.level.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LevelUpdateArgs>(args: SelectSubset<T, LevelUpdateArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Levels.
     * @param {LevelDeleteManyArgs} args - Arguments to filter Levels to delete.
     * @example
     * // Delete a few Levels
     * const { count } = await prisma.level.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LevelDeleteManyArgs>(args?: SelectSubset<T, LevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Levels
     * const level = await prisma.level.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LevelUpdateManyArgs>(args: SelectSubset<T, LevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Level.
     * @param {LevelUpsertArgs} args - Arguments to update or create a Level.
     * @example
     * // Update or create a Level
     * const level = await prisma.level.upsert({
     *   create: {
     *     // ... data to create a Level
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Level we want to update
     *   }
     * })
     */
    upsert<T extends LevelUpsertArgs>(args: SelectSubset<T, LevelUpsertArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Levels that matches the filter.
     * @param {LevelFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const level = await prisma.level.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: LevelFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Level.
     * @param {LevelAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const level = await prisma.level.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LevelAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelCountArgs} args - Arguments to filter Levels to count.
     * @example
     * // Count the number of Levels
     * const count = await prisma.level.count({
     *   where: {
     *     // ... the filter for the Levels we want to count
     *   }
     * })
    **/
    count<T extends LevelCountArgs>(
      args?: Subset<T, LevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LevelAggregateArgs>(args: Subset<T, LevelAggregateArgs>): Prisma.PrismaPromise<GetLevelAggregateType<T>>

    /**
     * Group by Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LevelGroupByArgs['orderBy'] }
        : { orderBy?: LevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Level model
   */
  readonly fields: LevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Level.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Level model
   */
  interface LevelFieldRefs {
    readonly id: FieldRef<"Level", 'String'>
    readonly level: FieldRef<"Level", 'Int'>
    readonly levelName: FieldRef<"Level", 'LevelName'>
    readonly createdAt: FieldRef<"Level", 'DateTime'>
    readonly updatedAt: FieldRef<"Level", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Level findUnique
   */
  export type LevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level findUniqueOrThrow
   */
  export type LevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level findFirst
   */
  export type LevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Levels.
     */
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level findFirstOrThrow
   */
  export type LevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Levels.
     */
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level findMany
   */
  export type LevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Levels to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level create
   */
  export type LevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The data needed to create a Level.
     */
    data: XOR<LevelCreateInput, LevelUncheckedCreateInput>
  }

  /**
   * Level createMany
   */
  export type LevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Levels.
     */
    data: LevelCreateManyInput | LevelCreateManyInput[]
  }

  /**
   * Level update
   */
  export type LevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The data needed to update a Level.
     */
    data: XOR<LevelUpdateInput, LevelUncheckedUpdateInput>
    /**
     * Choose, which Level to update.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level updateMany
   */
  export type LevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Levels.
     */
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyInput>
    /**
     * Filter which Levels to update
     */
    where?: LevelWhereInput
    /**
     * Limit how many Levels to update.
     */
    limit?: number
  }

  /**
   * Level upsert
   */
  export type LevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The filter to search for the Level to update in case it exists.
     */
    where: LevelWhereUniqueInput
    /**
     * In case the Level found by the `where` argument doesn't exist, create a new Level with this data.
     */
    create: XOR<LevelCreateInput, LevelUncheckedCreateInput>
    /**
     * In case the Level was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LevelUpdateInput, LevelUncheckedUpdateInput>
  }

  /**
   * Level delete
   */
  export type LevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter which Level to delete.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level deleteMany
   */
  export type LevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Levels to delete
     */
    where?: LevelWhereInput
    /**
     * Limit how many Levels to delete.
     */
    limit?: number
  }

  /**
   * Level findRaw
   */
  export type LevelFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Level aggregateRaw
   */
  export type LevelAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Level without action
   */
  export type LevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const ContestScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    banner: 'banner',
    status: 'status',
    mode: 'mode',
    maxUploads: 'maxUploads',
    isMoneyContest: 'isMoneyContest',
    maxPrize: 'maxPrize',
    minPrize: 'minPrize',
    level_requirements: 'level_requirements',
    startDate: 'startDate',
    endDate: 'endDate',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContestScalarFieldEnum = (typeof ContestScalarFieldEnum)[keyof typeof ContestScalarFieldEnum]


  export const RecurringContestScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    banner: 'banner',
    maxUploads: 'maxUploads',
    isMoneyContest: 'isMoneyContest',
    maxPrize: 'maxPrize',
    minPrize: 'minPrize',
    level_requirements: 'level_requirements',
    startDate: 'startDate',
    endDate: 'endDate',
    creatorId: 'creatorId',
    rules: 'rules',
    prizes: 'prizes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecurringContestScalarFieldEnum = (typeof RecurringContestScalarFieldEnum)[keyof typeof RecurringContestScalarFieldEnum]


  export const ContestRuleScalarFieldEnum: {
    id: 'id',
    icon: 'icon',
    name: 'name',
    description: 'description',
    contestId: 'contestId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContestRuleScalarFieldEnum = (typeof ContestRuleScalarFieldEnum)[keyof typeof ContestRuleScalarFieldEnum]


  export const ContestPhotoScalarFieldEnum: {
    id: 'id',
    title: 'title',
    contestId: 'contestId',
    participantId: 'participantId',
    photoId: 'photoId',
    rank: 'rank',
    promoted: 'promoted',
    promotionExpiresAt: 'promotionExpiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContestPhotoScalarFieldEnum = (typeof ContestPhotoScalarFieldEnum)[keyof typeof ContestPhotoScalarFieldEnum]


  export const ContestWinnerScalarFieldEnum: {
    id: 'id',
    participantId: 'participantId',
    contestId: 'contestId',
    contestPhotoId: 'contestPhotoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContestWinnerScalarFieldEnum = (typeof ContestWinnerScalarFieldEnum)[keyof typeof ContestWinnerScalarFieldEnum]


  export const ContestParticipantScalarFieldEnum: {
    id: 'id',
    status: 'status',
    contestId: 'contestId',
    userId: 'userId',
    memberId: 'memberId',
    level: 'level',
    rank: 'rank',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContestParticipantScalarFieldEnum = (typeof ContestParticipantScalarFieldEnum)[keyof typeof ContestParticipantScalarFieldEnum]


  export const ContestPrizeScalarFieldEnum: {
    id: 'id',
    category: 'category',
    trades: 'trades',
    charges: 'charges',
    keys: 'keys',
    contestId: 'contestId'
  };

  export type ContestPrizeScalarFieldEnum = (typeof ContestPrizeScalarFieldEnum)[keyof typeof ContestPrizeScalarFieldEnum]


  export const ContestAchievementScalarFieldEnum: {
    id: 'id',
    category: 'category',
    photoId: 'photoId',
    participantId: 'participantId',
    contestId: 'contestId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContestAchievementScalarFieldEnum = (typeof ContestAchievementScalarFieldEnum)[keyof typeof ContestAchievementScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    message: 'message',
    isSent: 'isSent',
    isRead: 'isRead',
    receiverId: 'receiverId',
    createdAt: 'createdAt',
    updatedAT: 'updatedAT'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    status: 'status',
    productId: 'productId',
    userId: 'userId',
    stripe_intent_id: 'stripe_intent_id',
    amount: 'amount',
    currency: 'currency',
    method: 'method',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const SitePolicyScalarFieldEnum: {
    id: 'id',
    type: 'type',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SitePolicyScalarFieldEnum = (typeof SitePolicyScalarFieldEnum)[keyof typeof SitePolicyScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    senderId: 'senderId',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    productType: 'productType',
    title: 'title',
    quantity: 'quantity',
    amount: 'amount',
    icon: 'icon',
    description: 'description',
    image: 'image'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const PriceScalarFieldEnum: {
    id: 'id',
    product_id: 'product_id',
    name: 'name',
    amount: 'amount',
    quantity: 'quantity',
    price_id: 'price_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PriceScalarFieldEnum = (typeof PriceScalarFieldEnum)[keyof typeof PriceScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    level: 'level',
    language: 'language',
    country: 'country',
    description: 'description',
    accessibility: 'accessibility',
    score: 'score',
    win: 'win',
    lost: 'lost',
    badge: 'badge',
    min_requirement: 'min_requirement',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    status: 'status',
    level: 'level',
    teamId: 'teamId',
    memberId: 'memberId',
    contestId: 'contestId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const TeamParticipationScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    contestId: 'contestId'
  };

  export type TeamParticipationScalarFieldEnum = (typeof TeamParticipationScalarFieldEnum)[keyof typeof TeamParticipationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    cover: 'cover',
    avatar: 'avatar',
    socialId: 'socialId',
    socialProvider: 'socialProvider',
    firstName: 'firstName',
    lastName: 'lastName',
    fullName: 'fullName',
    username: 'username',
    phone: 'phone',
    email: 'email',
    location: 'location',
    password: 'password',
    role: 'role',
    accessToken: 'accessToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserStoreScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    promotes: 'promotes',
    trades: 'trades',
    charges: 'charges',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserStoreScalarFieldEnum = (typeof UserStoreScalarFieldEnum)[keyof typeof UserStoreScalarFieldEnum]


  export const UserPhotoScalarFieldEnum: {
    id: 'id',
    url: 'url',
    userId: 'userId',
    views: 'views',
    labels: 'labels',
    title: 'title',
    description: 'description',
    adult: 'adult',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPhotoScalarFieldEnum = (typeof UserPhotoScalarFieldEnum)[keyof typeof UserPhotoScalarFieldEnum]


  export const LikeScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    photoId: 'photoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LikeScalarFieldEnum = (typeof LikeScalarFieldEnum)[keyof typeof LikeScalarFieldEnum]


  export const OtpScalarFieldEnum: {
    id: 'id',
    code: 'code',
    expires_in: 'expires_in',
    userId: 'userId',
    otpStatus: 'otpStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expiresAt: 'expiresAt'
  };

  export type OtpScalarFieldEnum = (typeof OtpScalarFieldEnum)[keyof typeof OtpScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    text: 'text',
    providerId: 'providerId',
    receiverId: 'receiverId',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const FollowScalarFieldEnum: {
    id: 'id',
    followerId: 'followerId',
    followingId: 'followingId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FollowScalarFieldEnum = (typeof FollowScalarFieldEnum)[keyof typeof FollowScalarFieldEnum]


  export const VoteScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    photoId: 'photoId',
    contestId: 'contestId',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VoteScalarFieldEnum = (typeof VoteScalarFieldEnum)[keyof typeof VoteScalarFieldEnum]


  export const UserLevelScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    levelId: 'levelId'
  };

  export type UserLevelScalarFieldEnum = (typeof UserLevelScalarFieldEnum)[keyof typeof UserLevelScalarFieldEnum]


  export const LevelScalarFieldEnum: {
    id: 'id',
    level: 'level',
    levelName: 'levelName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LevelScalarFieldEnum = (typeof LevelScalarFieldEnum)[keyof typeof LevelScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'ContestStatus'
   */
  export type EnumContestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContestStatus'>
    


  /**
   * Reference to a field of type 'ContestStatus[]'
   */
  export type ListEnumContestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContestStatus[]'>
    


  /**
   * Reference to a field of type 'ContestMode'
   */
  export type EnumContestModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContestMode'>
    


  /**
   * Reference to a field of type 'ContestMode[]'
   */
  export type ListEnumContestModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContestMode[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'ContestParticipantStatus'
   */
  export type EnumContestParticipantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContestParticipantStatus'>
    


  /**
   * Reference to a field of type 'ContestParticipantStatus[]'
   */
  export type ListEnumContestParticipantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContestParticipantStatus[]'>
    


  /**
   * Reference to a field of type 'YCLevel'
   */
  export type EnumYCLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'YCLevel'>
    


  /**
   * Reference to a field of type 'YCLevel[]'
   */
  export type ListEnumYCLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'YCLevel[]'>
    


  /**
   * Reference to a field of type 'PrizeType'
   */
  export type EnumPrizeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrizeType'>
    


  /**
   * Reference to a field of type 'PrizeType[]'
   */
  export type ListEnumPrizeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrizeType[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'SitePolicyType'
   */
  export type EnumSitePolicyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SitePolicyType'>
    


  /**
   * Reference to a field of type 'SitePolicyType[]'
   */
  export type ListEnumSitePolicyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SitePolicyType[]'>
    


  /**
   * Reference to a field of type 'ProductType'
   */
  export type EnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType'>
    


  /**
   * Reference to a field of type 'ProductType[]'
   */
  export type ListEnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType[]'>
    


  /**
   * Reference to a field of type 'TeamAccessibility'
   */
  export type EnumTeamAccessibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamAccessibility'>
    


  /**
   * Reference to a field of type 'TeamAccessibility[]'
   */
  export type ListEnumTeamAccessibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamAccessibility[]'>
    


  /**
   * Reference to a field of type 'TeamMemberStatus'
   */
  export type EnumTeamMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamMemberStatus'>
    


  /**
   * Reference to a field of type 'TeamMemberStatus[]'
   */
  export type ListEnumTeamMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamMemberStatus[]'>
    


  /**
   * Reference to a field of type 'MemberLevel'
   */
  export type EnumMemberLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberLevel'>
    


  /**
   * Reference to a field of type 'MemberLevel[]'
   */
  export type ListEnumMemberLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberLevel[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'OtpStatus'
   */
  export type EnumOtpStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OtpStatus'>
    


  /**
   * Reference to a field of type 'OtpStatus[]'
   */
  export type ListEnumOtpStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OtpStatus[]'>
    


  /**
   * Reference to a field of type 'VoteType'
   */
  export type EnumVoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoteType'>
    


  /**
   * Reference to a field of type 'VoteType[]'
   */
  export type ListEnumVoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoteType[]'>
    


  /**
   * Reference to a field of type 'LevelName'
   */
  export type EnumLevelNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LevelName'>
    


  /**
   * Reference to a field of type 'LevelName[]'
   */
  export type ListEnumLevelNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LevelName[]'>
    


  /**
   * Reference to a field of type 'RecurringType'
   */
  export type EnumRecurringTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurringType'>
    


  /**
   * Reference to a field of type 'RecurringType[]'
   */
  export type ListEnumRecurringTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurringType[]'>
    
  /**
   * Deep Input Types
   */


  export type ContestWhereInput = {
    AND?: ContestWhereInput | ContestWhereInput[]
    OR?: ContestWhereInput[]
    NOT?: ContestWhereInput | ContestWhereInput[]
    id?: StringFilter<"Contest"> | string
    title?: StringFilter<"Contest"> | string
    description?: StringFilter<"Contest"> | string
    banner?: StringNullableFilter<"Contest"> | string | null
    status?: EnumContestStatusFilter<"Contest"> | $Enums.ContestStatus
    mode?: EnumContestModeFilter<"Contest"> | $Enums.ContestMode
    maxUploads?: IntFilter<"Contest"> | number
    isMoneyContest?: BoolFilter<"Contest"> | boolean
    maxPrize?: IntNullableFilter<"Contest"> | number | null
    minPrize?: IntNullableFilter<"Contest"> | number | null
    level_requirements?: IntNullableListFilter<"Contest">
    startDate?: DateTimeFilter<"Contest"> | Date | string
    endDate?: DateTimeFilter<"Contest"> | Date | string
    creatorId?: StringFilter<"Contest"> | string
    createdAt?: DateTimeFilter<"Contest"> | Date | string
    updatedAt?: DateTimeFilter<"Contest"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    participants?: ContestParticipantListRelationFilter
    teamParticipations?: TeamParticipationListRelationFilter
    votes?: VoteListRelationFilter
    contestRules?: ContestRuleListRelationFilter
    contestPrizes?: ContestPrizeListRelationFilter
    achievements?: ContestAchievementListRelationFilter
  }

  export type ContestOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    status?: SortOrder
    mode?: SortOrder
    maxUploads?: SortOrder
    isMoneyContest?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    level_requirements?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    participants?: ContestParticipantOrderByRelationAggregateInput
    teamParticipations?: TeamParticipationOrderByRelationAggregateInput
    votes?: VoteOrderByRelationAggregateInput
    contestRules?: ContestRuleOrderByRelationAggregateInput
    contestPrizes?: ContestPrizeOrderByRelationAggregateInput
    achievements?: ContestAchievementOrderByRelationAggregateInput
  }

  export type ContestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContestWhereInput | ContestWhereInput[]
    OR?: ContestWhereInput[]
    NOT?: ContestWhereInput | ContestWhereInput[]
    title?: StringFilter<"Contest"> | string
    description?: StringFilter<"Contest"> | string
    banner?: StringNullableFilter<"Contest"> | string | null
    status?: EnumContestStatusFilter<"Contest"> | $Enums.ContestStatus
    mode?: EnumContestModeFilter<"Contest"> | $Enums.ContestMode
    maxUploads?: IntFilter<"Contest"> | number
    isMoneyContest?: BoolFilter<"Contest"> | boolean
    maxPrize?: IntNullableFilter<"Contest"> | number | null
    minPrize?: IntNullableFilter<"Contest"> | number | null
    level_requirements?: IntNullableListFilter<"Contest">
    startDate?: DateTimeFilter<"Contest"> | Date | string
    endDate?: DateTimeFilter<"Contest"> | Date | string
    creatorId?: StringFilter<"Contest"> | string
    createdAt?: DateTimeFilter<"Contest"> | Date | string
    updatedAt?: DateTimeFilter<"Contest"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    participants?: ContestParticipantListRelationFilter
    teamParticipations?: TeamParticipationListRelationFilter
    votes?: VoteListRelationFilter
    contestRules?: ContestRuleListRelationFilter
    contestPrizes?: ContestPrizeListRelationFilter
    achievements?: ContestAchievementListRelationFilter
  }, "id">

  export type ContestOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    status?: SortOrder
    mode?: SortOrder
    maxUploads?: SortOrder
    isMoneyContest?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    level_requirements?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContestCountOrderByAggregateInput
    _avg?: ContestAvgOrderByAggregateInput
    _max?: ContestMaxOrderByAggregateInput
    _min?: ContestMinOrderByAggregateInput
    _sum?: ContestSumOrderByAggregateInput
  }

  export type ContestScalarWhereWithAggregatesInput = {
    AND?: ContestScalarWhereWithAggregatesInput | ContestScalarWhereWithAggregatesInput[]
    OR?: ContestScalarWhereWithAggregatesInput[]
    NOT?: ContestScalarWhereWithAggregatesInput | ContestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contest"> | string
    title?: StringWithAggregatesFilter<"Contest"> | string
    description?: StringWithAggregatesFilter<"Contest"> | string
    banner?: StringNullableWithAggregatesFilter<"Contest"> | string | null
    status?: EnumContestStatusWithAggregatesFilter<"Contest"> | $Enums.ContestStatus
    mode?: EnumContestModeWithAggregatesFilter<"Contest"> | $Enums.ContestMode
    maxUploads?: IntWithAggregatesFilter<"Contest"> | number
    isMoneyContest?: BoolWithAggregatesFilter<"Contest"> | boolean
    maxPrize?: IntNullableWithAggregatesFilter<"Contest"> | number | null
    minPrize?: IntNullableWithAggregatesFilter<"Contest"> | number | null
    level_requirements?: IntNullableListFilter<"Contest">
    startDate?: DateTimeWithAggregatesFilter<"Contest"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Contest"> | Date | string
    creatorId?: StringWithAggregatesFilter<"Contest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Contest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contest"> | Date | string
  }

  export type RecurringContestWhereInput = {
    AND?: RecurringContestWhereInput | RecurringContestWhereInput[]
    OR?: RecurringContestWhereInput[]
    NOT?: RecurringContestWhereInput | RecurringContestWhereInput[]
    id?: StringFilter<"RecurringContest"> | string
    title?: StringFilter<"RecurringContest"> | string
    description?: StringFilter<"RecurringContest"> | string
    banner?: StringNullableFilter<"RecurringContest"> | string | null
    maxUploads?: IntFilter<"RecurringContest"> | number
    isMoneyContest?: BoolFilter<"RecurringContest"> | boolean
    maxPrize?: IntNullableFilter<"RecurringContest"> | number | null
    minPrize?: IntNullableFilter<"RecurringContest"> | number | null
    level_requirements?: IntNullableListFilter<"RecurringContest">
    startDate?: DateTimeFilter<"RecurringContest"> | Date | string
    endDate?: DateTimeFilter<"RecurringContest"> | Date | string
    creatorId?: StringFilter<"RecurringContest"> | string
    recurring?: XOR<RecurringDataCompositeFilter, RecurringDataObjectEqualityInput>
    rules?: JsonFilter<"RecurringContest">
    prizes?: JsonFilter<"RecurringContest">
    createdAt?: DateTimeFilter<"RecurringContest"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringContest"> | Date | string
  }

  export type RecurringContestOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    maxUploads?: SortOrder
    isMoneyContest?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    level_requirements?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    creatorId?: SortOrder
    recurring?: RecurringDataOrderByInput
    rules?: SortOrder
    prizes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringContestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecurringContestWhereInput | RecurringContestWhereInput[]
    OR?: RecurringContestWhereInput[]
    NOT?: RecurringContestWhereInput | RecurringContestWhereInput[]
    title?: StringFilter<"RecurringContest"> | string
    description?: StringFilter<"RecurringContest"> | string
    banner?: StringNullableFilter<"RecurringContest"> | string | null
    maxUploads?: IntFilter<"RecurringContest"> | number
    isMoneyContest?: BoolFilter<"RecurringContest"> | boolean
    maxPrize?: IntNullableFilter<"RecurringContest"> | number | null
    minPrize?: IntNullableFilter<"RecurringContest"> | number | null
    level_requirements?: IntNullableListFilter<"RecurringContest">
    startDate?: DateTimeFilter<"RecurringContest"> | Date | string
    endDate?: DateTimeFilter<"RecurringContest"> | Date | string
    creatorId?: StringFilter<"RecurringContest"> | string
    recurring?: XOR<RecurringDataCompositeFilter, RecurringDataObjectEqualityInput>
    rules?: JsonFilter<"RecurringContest">
    prizes?: JsonFilter<"RecurringContest">
    createdAt?: DateTimeFilter<"RecurringContest"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringContest"> | Date | string
  }, "id">

  export type RecurringContestOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    maxUploads?: SortOrder
    isMoneyContest?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    level_requirements?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    creatorId?: SortOrder
    rules?: SortOrder
    prizes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecurringContestCountOrderByAggregateInput
    _avg?: RecurringContestAvgOrderByAggregateInput
    _max?: RecurringContestMaxOrderByAggregateInput
    _min?: RecurringContestMinOrderByAggregateInput
    _sum?: RecurringContestSumOrderByAggregateInput
  }

  export type RecurringContestScalarWhereWithAggregatesInput = {
    AND?: RecurringContestScalarWhereWithAggregatesInput | RecurringContestScalarWhereWithAggregatesInput[]
    OR?: RecurringContestScalarWhereWithAggregatesInput[]
    NOT?: RecurringContestScalarWhereWithAggregatesInput | RecurringContestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecurringContest"> | string
    title?: StringWithAggregatesFilter<"RecurringContest"> | string
    description?: StringWithAggregatesFilter<"RecurringContest"> | string
    banner?: StringNullableWithAggregatesFilter<"RecurringContest"> | string | null
    maxUploads?: IntWithAggregatesFilter<"RecurringContest"> | number
    isMoneyContest?: BoolWithAggregatesFilter<"RecurringContest"> | boolean
    maxPrize?: IntNullableWithAggregatesFilter<"RecurringContest"> | number | null
    minPrize?: IntNullableWithAggregatesFilter<"RecurringContest"> | number | null
    level_requirements?: IntNullableListFilter<"RecurringContest">
    startDate?: DateTimeWithAggregatesFilter<"RecurringContest"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"RecurringContest"> | Date | string
    creatorId?: StringWithAggregatesFilter<"RecurringContest"> | string
    rules?: JsonWithAggregatesFilter<"RecurringContest">
    prizes?: JsonWithAggregatesFilter<"RecurringContest">
    createdAt?: DateTimeWithAggregatesFilter<"RecurringContest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RecurringContest"> | Date | string
  }

  export type ContestRuleWhereInput = {
    AND?: ContestRuleWhereInput | ContestRuleWhereInput[]
    OR?: ContestRuleWhereInput[]
    NOT?: ContestRuleWhereInput | ContestRuleWhereInput[]
    id?: StringFilter<"ContestRule"> | string
    icon?: StringNullableFilter<"ContestRule"> | string | null
    name?: StringFilter<"ContestRule"> | string
    description?: StringFilter<"ContestRule"> | string
    contestId?: StringFilter<"ContestRule"> | string
    createdAt?: DateTimeFilter<"ContestRule"> | Date | string
    updatedAt?: DateTimeFilter<"ContestRule"> | Date | string
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
  }

  export type ContestRuleOrderByWithRelationInput = {
    id?: SortOrder
    icon?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contest?: ContestOrderByWithRelationInput
  }

  export type ContestRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContestRuleWhereInput | ContestRuleWhereInput[]
    OR?: ContestRuleWhereInput[]
    NOT?: ContestRuleWhereInput | ContestRuleWhereInput[]
    icon?: StringNullableFilter<"ContestRule"> | string | null
    name?: StringFilter<"ContestRule"> | string
    description?: StringFilter<"ContestRule"> | string
    contestId?: StringFilter<"ContestRule"> | string
    createdAt?: DateTimeFilter<"ContestRule"> | Date | string
    updatedAt?: DateTimeFilter<"ContestRule"> | Date | string
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
  }, "id">

  export type ContestRuleOrderByWithAggregationInput = {
    id?: SortOrder
    icon?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContestRuleCountOrderByAggregateInput
    _max?: ContestRuleMaxOrderByAggregateInput
    _min?: ContestRuleMinOrderByAggregateInput
  }

  export type ContestRuleScalarWhereWithAggregatesInput = {
    AND?: ContestRuleScalarWhereWithAggregatesInput | ContestRuleScalarWhereWithAggregatesInput[]
    OR?: ContestRuleScalarWhereWithAggregatesInput[]
    NOT?: ContestRuleScalarWhereWithAggregatesInput | ContestRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContestRule"> | string
    icon?: StringNullableWithAggregatesFilter<"ContestRule"> | string | null
    name?: StringWithAggregatesFilter<"ContestRule"> | string
    description?: StringWithAggregatesFilter<"ContestRule"> | string
    contestId?: StringWithAggregatesFilter<"ContestRule"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContestRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContestRule"> | Date | string
  }

  export type ContestPhotoWhereInput = {
    AND?: ContestPhotoWhereInput | ContestPhotoWhereInput[]
    OR?: ContestPhotoWhereInput[]
    NOT?: ContestPhotoWhereInput | ContestPhotoWhereInput[]
    id?: StringFilter<"ContestPhoto"> | string
    title?: StringNullableFilter<"ContestPhoto"> | string | null
    contestId?: StringFilter<"ContestPhoto"> | string
    participantId?: StringFilter<"ContestPhoto"> | string
    photoId?: StringFilter<"ContestPhoto"> | string
    rank?: IntNullableFilter<"ContestPhoto"> | number | null
    promoted?: BoolFilter<"ContestPhoto"> | boolean
    promotionExpiresAt?: DateTimeNullableFilter<"ContestPhoto"> | Date | string | null
    createdAt?: DateTimeFilter<"ContestPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"ContestPhoto"> | Date | string
    participant?: XOR<ContestParticipantScalarRelationFilter, ContestParticipantWhereInput>
    votes?: VoteListRelationFilter
    photo?: XOR<UserPhotoScalarRelationFilter, UserPhotoWhereInput>
    comments?: CommentListRelationFilter
    achievements?: ContestAchievementListRelationFilter
    ContestWinner?: ContestWinnerListRelationFilter
  }

  export type ContestPhotoOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    contestId?: SortOrder
    participantId?: SortOrder
    photoId?: SortOrder
    rank?: SortOrder
    promoted?: SortOrder
    promotionExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    participant?: ContestParticipantOrderByWithRelationInput
    votes?: VoteOrderByRelationAggregateInput
    photo?: UserPhotoOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    achievements?: ContestAchievementOrderByRelationAggregateInput
    ContestWinner?: ContestWinnerOrderByRelationAggregateInput
  }

  export type ContestPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContestPhotoWhereInput | ContestPhotoWhereInput[]
    OR?: ContestPhotoWhereInput[]
    NOT?: ContestPhotoWhereInput | ContestPhotoWhereInput[]
    title?: StringNullableFilter<"ContestPhoto"> | string | null
    contestId?: StringFilter<"ContestPhoto"> | string
    participantId?: StringFilter<"ContestPhoto"> | string
    photoId?: StringFilter<"ContestPhoto"> | string
    rank?: IntNullableFilter<"ContestPhoto"> | number | null
    promoted?: BoolFilter<"ContestPhoto"> | boolean
    promotionExpiresAt?: DateTimeNullableFilter<"ContestPhoto"> | Date | string | null
    createdAt?: DateTimeFilter<"ContestPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"ContestPhoto"> | Date | string
    participant?: XOR<ContestParticipantScalarRelationFilter, ContestParticipantWhereInput>
    votes?: VoteListRelationFilter
    photo?: XOR<UserPhotoScalarRelationFilter, UserPhotoWhereInput>
    comments?: CommentListRelationFilter
    achievements?: ContestAchievementListRelationFilter
    ContestWinner?: ContestWinnerListRelationFilter
  }, "id">

  export type ContestPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    contestId?: SortOrder
    participantId?: SortOrder
    photoId?: SortOrder
    rank?: SortOrder
    promoted?: SortOrder
    promotionExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContestPhotoCountOrderByAggregateInput
    _avg?: ContestPhotoAvgOrderByAggregateInput
    _max?: ContestPhotoMaxOrderByAggregateInput
    _min?: ContestPhotoMinOrderByAggregateInput
    _sum?: ContestPhotoSumOrderByAggregateInput
  }

  export type ContestPhotoScalarWhereWithAggregatesInput = {
    AND?: ContestPhotoScalarWhereWithAggregatesInput | ContestPhotoScalarWhereWithAggregatesInput[]
    OR?: ContestPhotoScalarWhereWithAggregatesInput[]
    NOT?: ContestPhotoScalarWhereWithAggregatesInput | ContestPhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContestPhoto"> | string
    title?: StringNullableWithAggregatesFilter<"ContestPhoto"> | string | null
    contestId?: StringWithAggregatesFilter<"ContestPhoto"> | string
    participantId?: StringWithAggregatesFilter<"ContestPhoto"> | string
    photoId?: StringWithAggregatesFilter<"ContestPhoto"> | string
    rank?: IntNullableWithAggregatesFilter<"ContestPhoto"> | number | null
    promoted?: BoolWithAggregatesFilter<"ContestPhoto"> | boolean
    promotionExpiresAt?: DateTimeNullableWithAggregatesFilter<"ContestPhoto"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContestPhoto"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContestPhoto"> | Date | string
  }

  export type ContestWinnerWhereInput = {
    AND?: ContestWinnerWhereInput | ContestWinnerWhereInput[]
    OR?: ContestWinnerWhereInput[]
    NOT?: ContestWinnerWhereInput | ContestWinnerWhereInput[]
    id?: StringFilter<"ContestWinner"> | string
    participantId?: StringFilter<"ContestWinner"> | string
    contestId?: StringFilter<"ContestWinner"> | string
    contestPhotoId?: StringFilter<"ContestWinner"> | string
    createdAt?: DateTimeFilter<"ContestWinner"> | Date | string
    updatedAt?: DateTimeFilter<"ContestWinner"> | Date | string
    participant?: XOR<ContestParticipantScalarRelationFilter, ContestParticipantWhereInput>
    photo?: XOR<ContestPhotoScalarRelationFilter, ContestPhotoWhereInput>
  }

  export type ContestWinnerOrderByWithRelationInput = {
    id?: SortOrder
    participantId?: SortOrder
    contestId?: SortOrder
    contestPhotoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    participant?: ContestParticipantOrderByWithRelationInput
    photo?: ContestPhotoOrderByWithRelationInput
  }

  export type ContestWinnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContestWinnerWhereInput | ContestWinnerWhereInput[]
    OR?: ContestWinnerWhereInput[]
    NOT?: ContestWinnerWhereInput | ContestWinnerWhereInput[]
    participantId?: StringFilter<"ContestWinner"> | string
    contestId?: StringFilter<"ContestWinner"> | string
    contestPhotoId?: StringFilter<"ContestWinner"> | string
    createdAt?: DateTimeFilter<"ContestWinner"> | Date | string
    updatedAt?: DateTimeFilter<"ContestWinner"> | Date | string
    participant?: XOR<ContestParticipantScalarRelationFilter, ContestParticipantWhereInput>
    photo?: XOR<ContestPhotoScalarRelationFilter, ContestPhotoWhereInput>
  }, "id">

  export type ContestWinnerOrderByWithAggregationInput = {
    id?: SortOrder
    participantId?: SortOrder
    contestId?: SortOrder
    contestPhotoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContestWinnerCountOrderByAggregateInput
    _max?: ContestWinnerMaxOrderByAggregateInput
    _min?: ContestWinnerMinOrderByAggregateInput
  }

  export type ContestWinnerScalarWhereWithAggregatesInput = {
    AND?: ContestWinnerScalarWhereWithAggregatesInput | ContestWinnerScalarWhereWithAggregatesInput[]
    OR?: ContestWinnerScalarWhereWithAggregatesInput[]
    NOT?: ContestWinnerScalarWhereWithAggregatesInput | ContestWinnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContestWinner"> | string
    participantId?: StringWithAggregatesFilter<"ContestWinner"> | string
    contestId?: StringWithAggregatesFilter<"ContestWinner"> | string
    contestPhotoId?: StringWithAggregatesFilter<"ContestWinner"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContestWinner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContestWinner"> | Date | string
  }

  export type ContestParticipantWhereInput = {
    AND?: ContestParticipantWhereInput | ContestParticipantWhereInput[]
    OR?: ContestParticipantWhereInput[]
    NOT?: ContestParticipantWhereInput | ContestParticipantWhereInput[]
    id?: StringFilter<"ContestParticipant"> | string
    status?: EnumContestParticipantStatusFilter<"ContestParticipant"> | $Enums.ContestParticipantStatus
    contestId?: StringFilter<"ContestParticipant"> | string
    userId?: StringFilter<"ContestParticipant"> | string
    memberId?: StringNullableFilter<"ContestParticipant"> | string | null
    level?: EnumYCLevelFilter<"ContestParticipant"> | $Enums.YCLevel
    rank?: IntNullableFilter<"ContestParticipant"> | number | null
    createdAt?: DateTimeFilter<"ContestParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"ContestParticipant"> | Date | string
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    member?: XOR<TeamMemberNullableScalarRelationFilter, TeamMemberWhereInput> | null
    photos?: ContestPhotoListRelationFilter
    ContestWinner?: ContestWinnerListRelationFilter
    contestAchievement?: ContestAchievementListRelationFilter
  }

  export type ContestParticipantOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    contestId?: SortOrder
    userId?: SortOrder
    memberId?: SortOrder
    level?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contest?: ContestOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    member?: TeamMemberOrderByWithRelationInput
    photos?: ContestPhotoOrderByRelationAggregateInput
    ContestWinner?: ContestWinnerOrderByRelationAggregateInput
    contestAchievement?: ContestAchievementOrderByRelationAggregateInput
  }

  export type ContestParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contestId_userId?: ContestParticipantContestIdUserIdCompoundUniqueInput
    AND?: ContestParticipantWhereInput | ContestParticipantWhereInput[]
    OR?: ContestParticipantWhereInput[]
    NOT?: ContestParticipantWhereInput | ContestParticipantWhereInput[]
    status?: EnumContestParticipantStatusFilter<"ContestParticipant"> | $Enums.ContestParticipantStatus
    contestId?: StringFilter<"ContestParticipant"> | string
    userId?: StringFilter<"ContestParticipant"> | string
    memberId?: StringNullableFilter<"ContestParticipant"> | string | null
    level?: EnumYCLevelFilter<"ContestParticipant"> | $Enums.YCLevel
    rank?: IntNullableFilter<"ContestParticipant"> | number | null
    createdAt?: DateTimeFilter<"ContestParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"ContestParticipant"> | Date | string
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    member?: XOR<TeamMemberNullableScalarRelationFilter, TeamMemberWhereInput> | null
    photos?: ContestPhotoListRelationFilter
    ContestWinner?: ContestWinnerListRelationFilter
    contestAchievement?: ContestAchievementListRelationFilter
  }, "id" | "contestId_userId">

  export type ContestParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    contestId?: SortOrder
    userId?: SortOrder
    memberId?: SortOrder
    level?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContestParticipantCountOrderByAggregateInput
    _avg?: ContestParticipantAvgOrderByAggregateInput
    _max?: ContestParticipantMaxOrderByAggregateInput
    _min?: ContestParticipantMinOrderByAggregateInput
    _sum?: ContestParticipantSumOrderByAggregateInput
  }

  export type ContestParticipantScalarWhereWithAggregatesInput = {
    AND?: ContestParticipantScalarWhereWithAggregatesInput | ContestParticipantScalarWhereWithAggregatesInput[]
    OR?: ContestParticipantScalarWhereWithAggregatesInput[]
    NOT?: ContestParticipantScalarWhereWithAggregatesInput | ContestParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContestParticipant"> | string
    status?: EnumContestParticipantStatusWithAggregatesFilter<"ContestParticipant"> | $Enums.ContestParticipantStatus
    contestId?: StringWithAggregatesFilter<"ContestParticipant"> | string
    userId?: StringWithAggregatesFilter<"ContestParticipant"> | string
    memberId?: StringNullableWithAggregatesFilter<"ContestParticipant"> | string | null
    level?: EnumYCLevelWithAggregatesFilter<"ContestParticipant"> | $Enums.YCLevel
    rank?: IntNullableWithAggregatesFilter<"ContestParticipant"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ContestParticipant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContestParticipant"> | Date | string
  }

  export type ContestPrizeWhereInput = {
    AND?: ContestPrizeWhereInput | ContestPrizeWhereInput[]
    OR?: ContestPrizeWhereInput[]
    NOT?: ContestPrizeWhereInput | ContestPrizeWhereInput[]
    id?: StringFilter<"ContestPrize"> | string
    category?: EnumPrizeTypeFilter<"ContestPrize"> | $Enums.PrizeType
    trades?: IntFilter<"ContestPrize"> | number
    charges?: IntFilter<"ContestPrize"> | number
    keys?: IntFilter<"ContestPrize"> | number
    contestId?: StringFilter<"ContestPrize"> | string
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
  }

  export type ContestPrizeOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    trades?: SortOrder
    charges?: SortOrder
    keys?: SortOrder
    contestId?: SortOrder
    contest?: ContestOrderByWithRelationInput
  }

  export type ContestPrizeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContestPrizeWhereInput | ContestPrizeWhereInput[]
    OR?: ContestPrizeWhereInput[]
    NOT?: ContestPrizeWhereInput | ContestPrizeWhereInput[]
    category?: EnumPrizeTypeFilter<"ContestPrize"> | $Enums.PrizeType
    trades?: IntFilter<"ContestPrize"> | number
    charges?: IntFilter<"ContestPrize"> | number
    keys?: IntFilter<"ContestPrize"> | number
    contestId?: StringFilter<"ContestPrize"> | string
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
  }, "id">

  export type ContestPrizeOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    trades?: SortOrder
    charges?: SortOrder
    keys?: SortOrder
    contestId?: SortOrder
    _count?: ContestPrizeCountOrderByAggregateInput
    _avg?: ContestPrizeAvgOrderByAggregateInput
    _max?: ContestPrizeMaxOrderByAggregateInput
    _min?: ContestPrizeMinOrderByAggregateInput
    _sum?: ContestPrizeSumOrderByAggregateInput
  }

  export type ContestPrizeScalarWhereWithAggregatesInput = {
    AND?: ContestPrizeScalarWhereWithAggregatesInput | ContestPrizeScalarWhereWithAggregatesInput[]
    OR?: ContestPrizeScalarWhereWithAggregatesInput[]
    NOT?: ContestPrizeScalarWhereWithAggregatesInput | ContestPrizeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContestPrize"> | string
    category?: EnumPrizeTypeWithAggregatesFilter<"ContestPrize"> | $Enums.PrizeType
    trades?: IntWithAggregatesFilter<"ContestPrize"> | number
    charges?: IntWithAggregatesFilter<"ContestPrize"> | number
    keys?: IntWithAggregatesFilter<"ContestPrize"> | number
    contestId?: StringWithAggregatesFilter<"ContestPrize"> | string
  }

  export type ContestAchievementWhereInput = {
    AND?: ContestAchievementWhereInput | ContestAchievementWhereInput[]
    OR?: ContestAchievementWhereInput[]
    NOT?: ContestAchievementWhereInput | ContestAchievementWhereInput[]
    id?: StringFilter<"ContestAchievement"> | string
    category?: EnumPrizeTypeFilter<"ContestAchievement"> | $Enums.PrizeType
    photoId?: StringNullableFilter<"ContestAchievement"> | string | null
    participantId?: StringNullableFilter<"ContestAchievement"> | string | null
    contestId?: StringFilter<"ContestAchievement"> | string
    createdAt?: DateTimeFilter<"ContestAchievement"> | Date | string
    updatedAt?: DateTimeFilter<"ContestAchievement"> | Date | string
    photo?: XOR<ContestPhotoNullableScalarRelationFilter, ContestPhotoWhereInput> | null
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
    participant?: XOR<ContestParticipantNullableScalarRelationFilter, ContestParticipantWhereInput> | null
  }

  export type ContestAchievementOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    photoId?: SortOrder
    participantId?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    photo?: ContestPhotoOrderByWithRelationInput
    contest?: ContestOrderByWithRelationInput
    participant?: ContestParticipantOrderByWithRelationInput
  }

  export type ContestAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContestAchievementWhereInput | ContestAchievementWhereInput[]
    OR?: ContestAchievementWhereInput[]
    NOT?: ContestAchievementWhereInput | ContestAchievementWhereInput[]
    category?: EnumPrizeTypeFilter<"ContestAchievement"> | $Enums.PrizeType
    photoId?: StringNullableFilter<"ContestAchievement"> | string | null
    participantId?: StringNullableFilter<"ContestAchievement"> | string | null
    contestId?: StringFilter<"ContestAchievement"> | string
    createdAt?: DateTimeFilter<"ContestAchievement"> | Date | string
    updatedAt?: DateTimeFilter<"ContestAchievement"> | Date | string
    photo?: XOR<ContestPhotoNullableScalarRelationFilter, ContestPhotoWhereInput> | null
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
    participant?: XOR<ContestParticipantNullableScalarRelationFilter, ContestParticipantWhereInput> | null
  }, "id">

  export type ContestAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    photoId?: SortOrder
    participantId?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContestAchievementCountOrderByAggregateInput
    _max?: ContestAchievementMaxOrderByAggregateInput
    _min?: ContestAchievementMinOrderByAggregateInput
  }

  export type ContestAchievementScalarWhereWithAggregatesInput = {
    AND?: ContestAchievementScalarWhereWithAggregatesInput | ContestAchievementScalarWhereWithAggregatesInput[]
    OR?: ContestAchievementScalarWhereWithAggregatesInput[]
    NOT?: ContestAchievementScalarWhereWithAggregatesInput | ContestAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContestAchievement"> | string
    category?: EnumPrizeTypeWithAggregatesFilter<"ContestAchievement"> | $Enums.PrizeType
    photoId?: StringNullableWithAggregatesFilter<"ContestAchievement"> | string | null
    participantId?: StringNullableWithAggregatesFilter<"ContestAchievement"> | string | null
    contestId?: StringWithAggregatesFilter<"ContestAchievement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContestAchievement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContestAchievement"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isSent?: BoolFilter<"Notification"> | boolean
    isRead?: BoolFilter<"Notification"> | boolean
    receiverId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAT?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isSent?: SortOrder
    isRead?: SortOrder
    receiverId?: SortOrder
    createdAt?: SortOrder
    updatedAT?: SortOrder
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isSent?: BoolFilter<"Notification"> | boolean
    isRead?: BoolFilter<"Notification"> | boolean
    receiverId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAT?: DateTimeFilter<"Notification"> | Date | string
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isSent?: SortOrder
    isRead?: SortOrder
    receiverId?: SortOrder
    createdAt?: SortOrder
    updatedAT?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    isSent?: BoolWithAggregatesFilter<"Notification"> | boolean
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    receiverId?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAT?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    productId?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    stripe_intent_id?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    method?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    stripe_intent_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    productId?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    stripe_intent_id?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    method?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    stripe_intent_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    productId?: StringWithAggregatesFilter<"Payment"> | string
    userId?: StringWithAggregatesFilter<"Payment"> | string
    stripe_intent_id?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    method?: StringWithAggregatesFilter<"Payment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type SitePolicyWhereInput = {
    AND?: SitePolicyWhereInput | SitePolicyWhereInput[]
    OR?: SitePolicyWhereInput[]
    NOT?: SitePolicyWhereInput | SitePolicyWhereInput[]
    id?: StringFilter<"SitePolicy"> | string
    type?: EnumSitePolicyTypeFilter<"SitePolicy"> | $Enums.SitePolicyType
    content?: StringFilter<"SitePolicy"> | string
    createdAt?: DateTimeFilter<"SitePolicy"> | Date | string
    updatedAt?: DateTimeFilter<"SitePolicy"> | Date | string
  }

  export type SitePolicyOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SitePolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SitePolicyWhereInput | SitePolicyWhereInput[]
    OR?: SitePolicyWhereInput[]
    NOT?: SitePolicyWhereInput | SitePolicyWhereInput[]
    type?: EnumSitePolicyTypeFilter<"SitePolicy"> | $Enums.SitePolicyType
    content?: StringFilter<"SitePolicy"> | string
    createdAt?: DateTimeFilter<"SitePolicy"> | Date | string
    updatedAt?: DateTimeFilter<"SitePolicy"> | Date | string
  }, "id">

  export type SitePolicyOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SitePolicyCountOrderByAggregateInput
    _max?: SitePolicyMaxOrderByAggregateInput
    _min?: SitePolicyMinOrderByAggregateInput
  }

  export type SitePolicyScalarWhereWithAggregatesInput = {
    AND?: SitePolicyScalarWhereWithAggregatesInput | SitePolicyScalarWhereWithAggregatesInput[]
    OR?: SitePolicyScalarWhereWithAggregatesInput[]
    NOT?: SitePolicyScalarWhereWithAggregatesInput | SitePolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SitePolicy"> | string
    type?: EnumSitePolicyTypeWithAggregatesFilter<"SitePolicy"> | $Enums.SitePolicyType
    content?: StringWithAggregatesFilter<"SitePolicy"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SitePolicy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SitePolicy"> | Date | string
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: StringFilter<"Room"> | string
    teamId?: StringFilter<"Room"> | string
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teamId?: string
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
  }, "id" | "teamId">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    _count?: RoomCountOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Room"> | string
    teamId?: StringWithAggregatesFilter<"Room"> | string
  }

  export type ChatWhereInput = {
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    id?: StringFilter<"Chat"> | string
    teamId?: StringFilter<"Chat"> | string
    senderId?: StringFilter<"Chat"> | string
    message?: StringFilter<"Chat"> | string
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ChatOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type ChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    teamId?: StringFilter<"Chat"> | string
    senderId?: StringFilter<"Chat"> | string
    message?: StringFilter<"Chat"> | string
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ChatOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChatCountOrderByAggregateInput
    _max?: ChatMaxOrderByAggregateInput
    _min?: ChatMinOrderByAggregateInput
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    OR?: ChatScalarWhereWithAggregatesInput[]
    NOT?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chat"> | string
    teamId?: StringWithAggregatesFilter<"Chat"> | string
    senderId?: StringWithAggregatesFilter<"Chat"> | string
    message?: StringWithAggregatesFilter<"Chat"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    productType?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    title?: StringFilter<"Product"> | string
    quantity?: IntFilter<"Product"> | number
    amount?: FloatFilter<"Product"> | number
    icon?: StringNullableFilter<"Product"> | string | null
    description?: StringNullableFilter<"Product"> | string | null
    image?: StringNullableFilter<"Product"> | string | null
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    productType?: SortOrder
    title?: SortOrder
    quantity?: SortOrder
    amount?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    image?: SortOrder
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    productType?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    title?: StringFilter<"Product"> | string
    quantity?: IntFilter<"Product"> | number
    amount?: FloatFilter<"Product"> | number
    icon?: StringNullableFilter<"Product"> | string | null
    description?: StringNullableFilter<"Product"> | string | null
    image?: StringNullableFilter<"Product"> | string | null
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    productType?: SortOrder
    title?: SortOrder
    quantity?: SortOrder
    amount?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    image?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    productType?: EnumProductTypeWithAggregatesFilter<"Product"> | $Enums.ProductType
    title?: StringWithAggregatesFilter<"Product"> | string
    quantity?: IntWithAggregatesFilter<"Product"> | number
    amount?: FloatWithAggregatesFilter<"Product"> | number
    icon?: StringNullableWithAggregatesFilter<"Product"> | string | null
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    image?: StringNullableWithAggregatesFilter<"Product"> | string | null
  }

  export type PriceWhereInput = {
    AND?: PriceWhereInput | PriceWhereInput[]
    OR?: PriceWhereInput[]
    NOT?: PriceWhereInput | PriceWhereInput[]
    id?: StringFilter<"Price"> | string
    product_id?: StringFilter<"Price"> | string
    name?: StringFilter<"Price"> | string
    amount?: FloatFilter<"Price"> | number
    quantity?: IntFilter<"Price"> | number
    price_id?: StringFilter<"Price"> | string
    createdAt?: DateTimeFilter<"Price"> | Date | string
    updatedAt?: DateTimeFilter<"Price"> | Date | string
  }

  export type PriceOrderByWithRelationInput = {
    id?: SortOrder
    product_id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    quantity?: SortOrder
    price_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PriceWhereInput | PriceWhereInput[]
    OR?: PriceWhereInput[]
    NOT?: PriceWhereInput | PriceWhereInput[]
    product_id?: StringFilter<"Price"> | string
    name?: StringFilter<"Price"> | string
    amount?: FloatFilter<"Price"> | number
    quantity?: IntFilter<"Price"> | number
    price_id?: StringFilter<"Price"> | string
    createdAt?: DateTimeFilter<"Price"> | Date | string
    updatedAt?: DateTimeFilter<"Price"> | Date | string
  }, "id">

  export type PriceOrderByWithAggregationInput = {
    id?: SortOrder
    product_id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    quantity?: SortOrder
    price_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PriceCountOrderByAggregateInput
    _avg?: PriceAvgOrderByAggregateInput
    _max?: PriceMaxOrderByAggregateInput
    _min?: PriceMinOrderByAggregateInput
    _sum?: PriceSumOrderByAggregateInput
  }

  export type PriceScalarWhereWithAggregatesInput = {
    AND?: PriceScalarWhereWithAggregatesInput | PriceScalarWhereWithAggregatesInput[]
    OR?: PriceScalarWhereWithAggregatesInput[]
    NOT?: PriceScalarWhereWithAggregatesInput | PriceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Price"> | string
    product_id?: StringWithAggregatesFilter<"Price"> | string
    name?: StringWithAggregatesFilter<"Price"> | string
    amount?: FloatWithAggregatesFilter<"Price"> | number
    quantity?: IntWithAggregatesFilter<"Price"> | number
    price_id?: StringWithAggregatesFilter<"Price"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Price"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Price"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    level?: StringFilter<"Team"> | string
    language?: StringFilter<"Team"> | string
    country?: StringFilter<"Team"> | string
    description?: StringFilter<"Team"> | string
    accessibility?: EnumTeamAccessibilityFilter<"Team"> | $Enums.TeamAccessibility
    score?: IntFilter<"Team"> | number
    win?: IntFilter<"Team"> | number
    lost?: IntFilter<"Team"> | number
    badge?: StringFilter<"Team"> | string
    min_requirement?: IntFilter<"Team"> | number
    creatorId?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: TeamMemberListRelationFilter
    chat?: ChatListRelationFilter
    participations?: TeamParticipationListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    language?: SortOrder
    country?: SortOrder
    description?: SortOrder
    accessibility?: SortOrder
    score?: SortOrder
    win?: SortOrder
    lost?: SortOrder
    badge?: SortOrder
    min_requirement?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    members?: TeamMemberOrderByRelationAggregateInput
    chat?: ChatOrderByRelationAggregateInput
    participations?: TeamParticipationOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    level?: StringFilter<"Team"> | string
    language?: StringFilter<"Team"> | string
    country?: StringFilter<"Team"> | string
    description?: StringFilter<"Team"> | string
    accessibility?: EnumTeamAccessibilityFilter<"Team"> | $Enums.TeamAccessibility
    score?: IntFilter<"Team"> | number
    win?: IntFilter<"Team"> | number
    lost?: IntFilter<"Team"> | number
    badge?: StringFilter<"Team"> | string
    min_requirement?: IntFilter<"Team"> | number
    creatorId?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: TeamMemberListRelationFilter
    chat?: ChatListRelationFilter
    participations?: TeamParticipationListRelationFilter
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    language?: SortOrder
    country?: SortOrder
    description?: SortOrder
    accessibility?: SortOrder
    score?: SortOrder
    win?: SortOrder
    lost?: SortOrder
    badge?: SortOrder
    min_requirement?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _avg?: TeamAvgOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
    _sum?: TeamSumOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    level?: StringWithAggregatesFilter<"Team"> | string
    language?: StringWithAggregatesFilter<"Team"> | string
    country?: StringWithAggregatesFilter<"Team"> | string
    description?: StringWithAggregatesFilter<"Team"> | string
    accessibility?: EnumTeamAccessibilityWithAggregatesFilter<"Team"> | $Enums.TeamAccessibility
    score?: IntWithAggregatesFilter<"Team"> | number
    win?: IntWithAggregatesFilter<"Team"> | number
    lost?: IntWithAggregatesFilter<"Team"> | number
    badge?: StringWithAggregatesFilter<"Team"> | string
    min_requirement?: IntWithAggregatesFilter<"Team"> | number
    creatorId?: StringWithAggregatesFilter<"Team"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    status?: EnumTeamMemberStatusFilter<"TeamMember"> | $Enums.TeamMemberStatus
    level?: EnumMemberLevelFilter<"TeamMember"> | $Enums.MemberLevel
    teamId?: StringFilter<"TeamMember"> | string
    memberId?: StringFilter<"TeamMember"> | string
    contestId?: StringFilter<"TeamMember"> | string
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"TeamMember"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    member?: XOR<UserScalarRelationFilter, UserWhereInput>
    contestParticipant?: ContestParticipantListRelationFilter
  }

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    level?: SortOrder
    teamId?: SortOrder
    memberId?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    member?: UserOrderByWithRelationInput
    contestParticipant?: ContestParticipantOrderByRelationAggregateInput
  }

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    memberId?: string
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    status?: EnumTeamMemberStatusFilter<"TeamMember"> | $Enums.TeamMemberStatus
    level?: EnumMemberLevelFilter<"TeamMember"> | $Enums.MemberLevel
    teamId?: StringFilter<"TeamMember"> | string
    contestId?: StringFilter<"TeamMember"> | string
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"TeamMember"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    member?: XOR<UserScalarRelationFilter, UserWhereInput>
    contestParticipant?: ContestParticipantListRelationFilter
  }, "id" | "memberId">

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    level?: SortOrder
    teamId?: SortOrder
    memberId?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    OR?: TeamMemberScalarWhereWithAggregatesInput[]
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamMember"> | string
    status?: EnumTeamMemberStatusWithAggregatesFilter<"TeamMember"> | $Enums.TeamMemberStatus
    level?: EnumMemberLevelWithAggregatesFilter<"TeamMember"> | $Enums.MemberLevel
    teamId?: StringWithAggregatesFilter<"TeamMember"> | string
    memberId?: StringWithAggregatesFilter<"TeamMember"> | string
    contestId?: StringWithAggregatesFilter<"TeamMember"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
  }

  export type TeamParticipationWhereInput = {
    AND?: TeamParticipationWhereInput | TeamParticipationWhereInput[]
    OR?: TeamParticipationWhereInput[]
    NOT?: TeamParticipationWhereInput | TeamParticipationWhereInput[]
    id?: StringFilter<"TeamParticipation"> | string
    teamId?: StringFilter<"TeamParticipation"> | string
    contestId?: StringFilter<"TeamParticipation"> | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
  }

  export type TeamParticipationOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    contestId?: SortOrder
    team?: TeamOrderByWithRelationInput
    contest?: ContestOrderByWithRelationInput
  }

  export type TeamParticipationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teamId_contestId?: TeamParticipationTeamIdContestIdCompoundUniqueInput
    AND?: TeamParticipationWhereInput | TeamParticipationWhereInput[]
    OR?: TeamParticipationWhereInput[]
    NOT?: TeamParticipationWhereInput | TeamParticipationWhereInput[]
    teamId?: StringFilter<"TeamParticipation"> | string
    contestId?: StringFilter<"TeamParticipation"> | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
  }, "id" | "teamId_contestId">

  export type TeamParticipationOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    contestId?: SortOrder
    _count?: TeamParticipationCountOrderByAggregateInput
    _max?: TeamParticipationMaxOrderByAggregateInput
    _min?: TeamParticipationMinOrderByAggregateInput
  }

  export type TeamParticipationScalarWhereWithAggregatesInput = {
    AND?: TeamParticipationScalarWhereWithAggregatesInput | TeamParticipationScalarWhereWithAggregatesInput[]
    OR?: TeamParticipationScalarWhereWithAggregatesInput[]
    NOT?: TeamParticipationScalarWhereWithAggregatesInput | TeamParticipationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamParticipation"> | string
    teamId?: StringWithAggregatesFilter<"TeamParticipation"> | string
    contestId?: StringWithAggregatesFilter<"TeamParticipation"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    cover?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    socialId?: StringNullableFilter<"User"> | string | null
    socialProvider?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    fullName?: StringNullableFilter<"User"> | string | null
    username?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    location?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    accessToken?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    otps?: XOR<OtpNullableScalarRelationFilter, OtpWhereInput> | null
    store?: XOR<UserStoreNullableScalarRelationFilter, UserStoreWhereInput> | null
    createdTeam?: TeamListRelationFilter
    joinedTeam?: XOR<TeamMemberNullableScalarRelationFilter, TeamMemberWhereInput> | null
    createdContests?: ContestListRelationFilter
    commentProvides?: CommentListRelationFilter
    followers?: FollowListRelationFilter
    followings?: FollowListRelationFilter
    votes?: VoteListRelationFilter
    likes?: LikeListRelationFilter
    userPhotos?: UserPhotoListRelationFilter
    ContestParticipant?: ContestParticipantListRelationFilter
    chat?: ChatListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    cover?: SortOrder
    avatar?: SortOrder
    socialId?: SortOrder
    socialProvider?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    location?: SortOrder
    password?: SortOrder
    role?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    otps?: OtpOrderByWithRelationInput
    store?: UserStoreOrderByWithRelationInput
    createdTeam?: TeamOrderByRelationAggregateInput
    joinedTeam?: TeamMemberOrderByWithRelationInput
    createdContests?: ContestOrderByRelationAggregateInput
    commentProvides?: CommentOrderByRelationAggregateInput
    followers?: FollowOrderByRelationAggregateInput
    followings?: FollowOrderByRelationAggregateInput
    votes?: VoteOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
    userPhotos?: UserPhotoOrderByRelationAggregateInput
    ContestParticipant?: ContestParticipantOrderByRelationAggregateInput
    chat?: ChatOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    cover?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    socialId?: StringNullableFilter<"User"> | string | null
    socialProvider?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    fullName?: StringNullableFilter<"User"> | string | null
    username?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    location?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    accessToken?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    otps?: XOR<OtpNullableScalarRelationFilter, OtpWhereInput> | null
    store?: XOR<UserStoreNullableScalarRelationFilter, UserStoreWhereInput> | null
    createdTeam?: TeamListRelationFilter
    joinedTeam?: XOR<TeamMemberNullableScalarRelationFilter, TeamMemberWhereInput> | null
    createdContests?: ContestListRelationFilter
    commentProvides?: CommentListRelationFilter
    followers?: FollowListRelationFilter
    followings?: FollowListRelationFilter
    votes?: VoteListRelationFilter
    likes?: LikeListRelationFilter
    userPhotos?: UserPhotoListRelationFilter
    ContestParticipant?: ContestParticipantListRelationFilter
    chat?: ChatListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    cover?: SortOrder
    avatar?: SortOrder
    socialId?: SortOrder
    socialProvider?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    location?: SortOrder
    password?: SortOrder
    role?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    cover?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    socialId?: StringNullableWithAggregatesFilter<"User"> | string | null
    socialProvider?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    fullName?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    location?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    accessToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserStoreWhereInput = {
    AND?: UserStoreWhereInput | UserStoreWhereInput[]
    OR?: UserStoreWhereInput[]
    NOT?: UserStoreWhereInput | UserStoreWhereInput[]
    id?: StringFilter<"UserStore"> | string
    userId?: StringFilter<"UserStore"> | string
    promotes?: IntFilter<"UserStore"> | number
    trades?: IntFilter<"UserStore"> | number
    charges?: IntFilter<"UserStore"> | number
    createdAt?: DateTimeFilter<"UserStore"> | Date | string
    updatedAt?: DateTimeFilter<"UserStore"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type UserStoreOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    promotes?: SortOrder
    trades?: SortOrder
    charges?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserStoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserStoreWhereInput | UserStoreWhereInput[]
    OR?: UserStoreWhereInput[]
    NOT?: UserStoreWhereInput | UserStoreWhereInput[]
    promotes?: IntFilter<"UserStore"> | number
    trades?: IntFilter<"UserStore"> | number
    charges?: IntFilter<"UserStore"> | number
    createdAt?: DateTimeFilter<"UserStore"> | Date | string
    updatedAt?: DateTimeFilter<"UserStore"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "userId">

  export type UserStoreOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    promotes?: SortOrder
    trades?: SortOrder
    charges?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserStoreCountOrderByAggregateInput
    _avg?: UserStoreAvgOrderByAggregateInput
    _max?: UserStoreMaxOrderByAggregateInput
    _min?: UserStoreMinOrderByAggregateInput
    _sum?: UserStoreSumOrderByAggregateInput
  }

  export type UserStoreScalarWhereWithAggregatesInput = {
    AND?: UserStoreScalarWhereWithAggregatesInput | UserStoreScalarWhereWithAggregatesInput[]
    OR?: UserStoreScalarWhereWithAggregatesInput[]
    NOT?: UserStoreScalarWhereWithAggregatesInput | UserStoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserStore"> | string
    userId?: StringWithAggregatesFilter<"UserStore"> | string
    promotes?: IntWithAggregatesFilter<"UserStore"> | number
    trades?: IntWithAggregatesFilter<"UserStore"> | number
    charges?: IntWithAggregatesFilter<"UserStore"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserStore"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserStore"> | Date | string
  }

  export type UserPhotoWhereInput = {
    AND?: UserPhotoWhereInput | UserPhotoWhereInput[]
    OR?: UserPhotoWhereInput[]
    NOT?: UserPhotoWhereInput | UserPhotoWhereInput[]
    id?: StringFilter<"UserPhoto"> | string
    url?: StringFilter<"UserPhoto"> | string
    userId?: StringFilter<"UserPhoto"> | string
    states?: XOR<PhotoStatsNullableCompositeFilter, PhotoStatsObjectEqualityInput> | null
    views?: IntFilter<"UserPhoto"> | number
    labels?: StringNullableListFilter<"UserPhoto">
    title?: StringNullableFilter<"UserPhoto"> | string | null
    description?: StringNullableFilter<"UserPhoto"> | string | null
    adult?: BoolFilter<"UserPhoto"> | boolean
    createdAt?: DateTimeFilter<"UserPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"UserPhoto"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    contestUpload?: ContestPhotoListRelationFilter
    likes?: LikeListRelationFilter
  }

  export type UserPhotoOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    userId?: SortOrder
    states?: PhotoStatsOrderByInput
    views?: SortOrder
    labels?: SortOrder
    title?: SortOrder
    description?: SortOrder
    adult?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    contestUpload?: ContestPhotoOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
  }

  export type UserPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserPhotoWhereInput | UserPhotoWhereInput[]
    OR?: UserPhotoWhereInput[]
    NOT?: UserPhotoWhereInput | UserPhotoWhereInput[]
    url?: StringFilter<"UserPhoto"> | string
    userId?: StringFilter<"UserPhoto"> | string
    states?: XOR<PhotoStatsNullableCompositeFilter, PhotoStatsObjectEqualityInput> | null
    views?: IntFilter<"UserPhoto"> | number
    labels?: StringNullableListFilter<"UserPhoto">
    title?: StringNullableFilter<"UserPhoto"> | string | null
    description?: StringNullableFilter<"UserPhoto"> | string | null
    adult?: BoolFilter<"UserPhoto"> | boolean
    createdAt?: DateTimeFilter<"UserPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"UserPhoto"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    contestUpload?: ContestPhotoListRelationFilter
    likes?: LikeListRelationFilter
  }, "id">

  export type UserPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    userId?: SortOrder
    views?: SortOrder
    labels?: SortOrder
    title?: SortOrder
    description?: SortOrder
    adult?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPhotoCountOrderByAggregateInput
    _avg?: UserPhotoAvgOrderByAggregateInput
    _max?: UserPhotoMaxOrderByAggregateInput
    _min?: UserPhotoMinOrderByAggregateInput
    _sum?: UserPhotoSumOrderByAggregateInput
  }

  export type UserPhotoScalarWhereWithAggregatesInput = {
    AND?: UserPhotoScalarWhereWithAggregatesInput | UserPhotoScalarWhereWithAggregatesInput[]
    OR?: UserPhotoScalarWhereWithAggregatesInput[]
    NOT?: UserPhotoScalarWhereWithAggregatesInput | UserPhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPhoto"> | string
    url?: StringWithAggregatesFilter<"UserPhoto"> | string
    userId?: StringWithAggregatesFilter<"UserPhoto"> | string
    views?: IntWithAggregatesFilter<"UserPhoto"> | number
    labels?: StringNullableListFilter<"UserPhoto">
    title?: StringNullableWithAggregatesFilter<"UserPhoto"> | string | null
    description?: StringNullableWithAggregatesFilter<"UserPhoto"> | string | null
    adult?: BoolWithAggregatesFilter<"UserPhoto"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserPhoto"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPhoto"> | Date | string
  }

  export type LikeWhereInput = {
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    id?: StringFilter<"Like"> | string
    providerId?: StringFilter<"Like"> | string
    photoId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    updatedAt?: DateTimeFilter<"Like"> | Date | string
    provider?: XOR<UserScalarRelationFilter, UserWhereInput>
    photo?: XOR<UserPhotoScalarRelationFilter, UserPhotoWhereInput>
  }

  export type LikeOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: UserOrderByWithRelationInput
    photo?: UserPhotoOrderByWithRelationInput
  }

  export type LikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    photoId_providerId?: LikePhotoIdProviderIdCompoundUniqueInput
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    providerId?: StringFilter<"Like"> | string
    photoId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    updatedAt?: DateTimeFilter<"Like"> | Date | string
    provider?: XOR<UserScalarRelationFilter, UserWhereInput>
    photo?: XOR<UserPhotoScalarRelationFilter, UserPhotoWhereInput>
  }, "id" | "photoId_providerId">

  export type LikeOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LikeCountOrderByAggregateInput
    _max?: LikeMaxOrderByAggregateInput
    _min?: LikeMinOrderByAggregateInput
  }

  export type LikeScalarWhereWithAggregatesInput = {
    AND?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    OR?: LikeScalarWhereWithAggregatesInput[]
    NOT?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Like"> | string
    providerId?: StringWithAggregatesFilter<"Like"> | string
    photoId?: StringWithAggregatesFilter<"Like"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Like"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Like"> | Date | string
  }

  export type OtpWhereInput = {
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    id?: StringFilter<"Otp"> | string
    code?: StringFilter<"Otp"> | string
    expires_in?: DateTimeFilter<"Otp"> | Date | string
    userId?: StringFilter<"Otp"> | string
    otpStatus?: EnumOtpStatusFilter<"Otp"> | $Enums.OtpStatus
    createdAt?: DateTimeFilter<"Otp"> | Date | string
    updatedAt?: DateTimeFilter<"Otp"> | Date | string
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OtpOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    expires_in?: SortOrder
    userId?: SortOrder
    otpStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OtpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    code?: StringFilter<"Otp"> | string
    expires_in?: DateTimeFilter<"Otp"> | Date | string
    otpStatus?: EnumOtpStatusFilter<"Otp"> | $Enums.OtpStatus
    createdAt?: DateTimeFilter<"Otp"> | Date | string
    updatedAt?: DateTimeFilter<"Otp"> | Date | string
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type OtpOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    expires_in?: SortOrder
    userId?: SortOrder
    otpStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    _count?: OtpCountOrderByAggregateInput
    _max?: OtpMaxOrderByAggregateInput
    _min?: OtpMinOrderByAggregateInput
  }

  export type OtpScalarWhereWithAggregatesInput = {
    AND?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    OR?: OtpScalarWhereWithAggregatesInput[]
    NOT?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Otp"> | string
    code?: StringWithAggregatesFilter<"Otp"> | string
    expires_in?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
    userId?: StringWithAggregatesFilter<"Otp"> | string
    otpStatus?: EnumOtpStatusWithAggregatesFilter<"Otp"> | $Enums.OtpStatus
    createdAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    text?: StringFilter<"Comment"> | string
    providerId?: StringFilter<"Comment"> | string
    receiverId?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    provider?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<ContestPhotoScalarRelationFilter, ContestPhotoWhereInput>
    parent?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    CommentReplies?: CommentListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    providerId?: SortOrder
    receiverId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: UserOrderByWithRelationInput
    receiver?: ContestPhotoOrderByWithRelationInput
    parent?: CommentOrderByWithRelationInput
    CommentReplies?: CommentOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    text?: StringFilter<"Comment"> | string
    providerId?: StringFilter<"Comment"> | string
    receiverId?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    provider?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<ContestPhotoScalarRelationFilter, ContestPhotoWhereInput>
    parent?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    CommentReplies?: CommentListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    providerId?: SortOrder
    receiverId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    text?: StringWithAggregatesFilter<"Comment"> | string
    providerId?: StringWithAggregatesFilter<"Comment"> | string
    receiverId?: StringWithAggregatesFilter<"Comment"> | string
    parentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type FollowWhereInput = {
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    id?: StringFilter<"Follow"> | string
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    updatedAt?: DateTimeFilter<"Follow"> | Date | string
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    following?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FollowOrderByWithRelationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    follower?: UserOrderByWithRelationInput
    following?: UserOrderByWithRelationInput
  }

  export type FollowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    followerId_followingId?: FollowFollowerIdFollowingIdCompoundUniqueInput
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    updatedAt?: DateTimeFilter<"Follow"> | Date | string
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    following?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "followerId_followingId">

  export type FollowOrderByWithAggregationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FollowCountOrderByAggregateInput
    _max?: FollowMaxOrderByAggregateInput
    _min?: FollowMinOrderByAggregateInput
  }

  export type FollowScalarWhereWithAggregatesInput = {
    AND?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    OR?: FollowScalarWhereWithAggregatesInput[]
    NOT?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Follow"> | string
    followerId?: StringWithAggregatesFilter<"Follow"> | string
    followingId?: StringWithAggregatesFilter<"Follow"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Follow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Follow"> | Date | string
  }

  export type VoteWhereInput = {
    AND?: VoteWhereInput | VoteWhereInput[]
    OR?: VoteWhereInput[]
    NOT?: VoteWhereInput | VoteWhereInput[]
    id?: StringFilter<"Vote"> | string
    providerId?: StringFilter<"Vote"> | string
    photoId?: StringFilter<"Vote"> | string
    contestId?: StringFilter<"Vote"> | string
    type?: EnumVoteTypeFilter<"Vote"> | $Enums.VoteType
    createdAt?: DateTimeFilter<"Vote"> | Date | string
    updatedAt?: DateTimeFilter<"Vote"> | Date | string
    provider?: XOR<UserScalarRelationFilter, UserWhereInput>
    photo?: XOR<ContestPhotoScalarRelationFilter, ContestPhotoWhereInput>
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
  }

  export type VoteOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    photoId?: SortOrder
    contestId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: UserOrderByWithRelationInput
    photo?: ContestPhotoOrderByWithRelationInput
    contest?: ContestOrderByWithRelationInput
  }

  export type VoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VoteWhereInput | VoteWhereInput[]
    OR?: VoteWhereInput[]
    NOT?: VoteWhereInput | VoteWhereInput[]
    providerId?: StringFilter<"Vote"> | string
    photoId?: StringFilter<"Vote"> | string
    contestId?: StringFilter<"Vote"> | string
    type?: EnumVoteTypeFilter<"Vote"> | $Enums.VoteType
    createdAt?: DateTimeFilter<"Vote"> | Date | string
    updatedAt?: DateTimeFilter<"Vote"> | Date | string
    provider?: XOR<UserScalarRelationFilter, UserWhereInput>
    photo?: XOR<ContestPhotoScalarRelationFilter, ContestPhotoWhereInput>
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
  }, "id">

  export type VoteOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    photoId?: SortOrder
    contestId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VoteCountOrderByAggregateInput
    _max?: VoteMaxOrderByAggregateInput
    _min?: VoteMinOrderByAggregateInput
  }

  export type VoteScalarWhereWithAggregatesInput = {
    AND?: VoteScalarWhereWithAggregatesInput | VoteScalarWhereWithAggregatesInput[]
    OR?: VoteScalarWhereWithAggregatesInput[]
    NOT?: VoteScalarWhereWithAggregatesInput | VoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vote"> | string
    providerId?: StringWithAggregatesFilter<"Vote"> | string
    photoId?: StringWithAggregatesFilter<"Vote"> | string
    contestId?: StringWithAggregatesFilter<"Vote"> | string
    type?: EnumVoteTypeWithAggregatesFilter<"Vote"> | $Enums.VoteType
    createdAt?: DateTimeWithAggregatesFilter<"Vote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vote"> | Date | string
  }

  export type UserLevelWhereInput = {
    AND?: UserLevelWhereInput | UserLevelWhereInput[]
    OR?: UserLevelWhereInput[]
    NOT?: UserLevelWhereInput | UserLevelWhereInput[]
    id?: StringFilter<"UserLevel"> | string
    userId?: StringFilter<"UserLevel"> | string
    levelId?: StringFilter<"UserLevel"> | string
  }

  export type UserLevelOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    levelId?: SortOrder
  }

  export type UserLevelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserLevelWhereInput | UserLevelWhereInput[]
    OR?: UserLevelWhereInput[]
    NOT?: UserLevelWhereInput | UserLevelWhereInput[]
    userId?: StringFilter<"UserLevel"> | string
    levelId?: StringFilter<"UserLevel"> | string
  }, "id">

  export type UserLevelOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    levelId?: SortOrder
    _count?: UserLevelCountOrderByAggregateInput
    _max?: UserLevelMaxOrderByAggregateInput
    _min?: UserLevelMinOrderByAggregateInput
  }

  export type UserLevelScalarWhereWithAggregatesInput = {
    AND?: UserLevelScalarWhereWithAggregatesInput | UserLevelScalarWhereWithAggregatesInput[]
    OR?: UserLevelScalarWhereWithAggregatesInput[]
    NOT?: UserLevelScalarWhereWithAggregatesInput | UserLevelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserLevel"> | string
    userId?: StringWithAggregatesFilter<"UserLevel"> | string
    levelId?: StringWithAggregatesFilter<"UserLevel"> | string
  }

  export type LevelWhereInput = {
    AND?: LevelWhereInput | LevelWhereInput[]
    OR?: LevelWhereInput[]
    NOT?: LevelWhereInput | LevelWhereInput[]
    id?: StringFilter<"Level"> | string
    level?: IntFilter<"Level"> | number
    levelName?: EnumLevelNameFilter<"Level"> | $Enums.LevelName
    requirements?: LevelRequirementCompositeListFilter | LevelRequirementObjectEqualityInput[]
    createdAt?: DateTimeFilter<"Level"> | Date | string
    updatedAt?: DateTimeFilter<"Level"> | Date | string
  }

  export type LevelOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrder
    levelName?: SortOrder
    requirements?: LevelRequirementOrderByCompositeAggregateInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LevelWhereInput | LevelWhereInput[]
    OR?: LevelWhereInput[]
    NOT?: LevelWhereInput | LevelWhereInput[]
    level?: IntFilter<"Level"> | number
    levelName?: EnumLevelNameFilter<"Level"> | $Enums.LevelName
    requirements?: LevelRequirementCompositeListFilter | LevelRequirementObjectEqualityInput[]
    createdAt?: DateTimeFilter<"Level"> | Date | string
    updatedAt?: DateTimeFilter<"Level"> | Date | string
  }, "id">

  export type LevelOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrder
    levelName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LevelCountOrderByAggregateInput
    _avg?: LevelAvgOrderByAggregateInput
    _max?: LevelMaxOrderByAggregateInput
    _min?: LevelMinOrderByAggregateInput
    _sum?: LevelSumOrderByAggregateInput
  }

  export type LevelScalarWhereWithAggregatesInput = {
    AND?: LevelScalarWhereWithAggregatesInput | LevelScalarWhereWithAggregatesInput[]
    OR?: LevelScalarWhereWithAggregatesInput[]
    NOT?: LevelScalarWhereWithAggregatesInput | LevelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Level"> | string
    level?: IntWithAggregatesFilter<"Level"> | number
    levelName?: EnumLevelNameWithAggregatesFilter<"Level"> | $Enums.LevelName
    createdAt?: DateTimeWithAggregatesFilter<"Level"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Level"> | Date | string
  }

  export type ContestCreateInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    mode?: $Enums.ContestMode
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: ContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedContestsInput
    participants?: ContestParticipantCreateNestedManyWithoutContestInput
    teamParticipations?: TeamParticipationCreateNestedManyWithoutContestInput
    votes?: VoteCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeCreateNestedManyWithoutContestInput
    achievements?: ContestAchievementCreateNestedManyWithoutContestInput
  }

  export type ContestUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    mode?: $Enums.ContestMode
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: ContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ContestParticipantUncheckedCreateNestedManyWithoutContestInput
    teamParticipations?: TeamParticipationUncheckedCreateNestedManyWithoutContestInput
    votes?: VoteUncheckedCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleUncheckedCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeUncheckedCreateNestedManyWithoutContestInput
    achievements?: ContestAchievementUncheckedCreateNestedManyWithoutContestInput
  }

  export type ContestUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    mode?: EnumContestModeFieldUpdateOperationsInput | $Enums.ContestMode
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: ContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedContestsNestedInput
    participants?: ContestParticipantUpdateManyWithoutContestNestedInput
    teamParticipations?: TeamParticipationUpdateManyWithoutContestNestedInput
    votes?: VoteUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUpdateManyWithoutContestNestedInput
    achievements?: ContestAchievementUpdateManyWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    mode?: EnumContestModeFieldUpdateOperationsInput | $Enums.ContestMode
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: ContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ContestParticipantUncheckedUpdateManyWithoutContestNestedInput
    teamParticipations?: TeamParticipationUncheckedUpdateManyWithoutContestNestedInput
    votes?: VoteUncheckedUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUncheckedUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUncheckedUpdateManyWithoutContestNestedInput
    achievements?: ContestAchievementUncheckedUpdateManyWithoutContestNestedInput
  }

  export type ContestCreateManyInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    mode?: $Enums.ContestMode
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: ContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    mode?: EnumContestModeFieldUpdateOperationsInput | $Enums.ContestMode
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: ContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    mode?: EnumContestModeFieldUpdateOperationsInput | $Enums.ContestMode
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: ContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringContestCreateInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: RecurringContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    recurring: XOR<RecurringDataCreateEnvelopeInput, RecurringDataCreateInput>
    rules: InputJsonValue
    prizes: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringContestUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: RecurringContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    recurring: XOR<RecurringDataCreateEnvelopeInput, RecurringDataCreateInput>
    rules: InputJsonValue
    prizes: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringContestUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: RecurringContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    recurring?: XOR<RecurringDataUpdateEnvelopeInput, RecurringDataCreateInput>
    rules?: InputJsonValue | InputJsonValue
    prizes?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringContestUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: RecurringContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    recurring?: XOR<RecurringDataUpdateEnvelopeInput, RecurringDataCreateInput>
    rules?: InputJsonValue | InputJsonValue
    prizes?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringContestCreateManyInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: RecurringContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    recurring: XOR<RecurringDataCreateEnvelopeInput, RecurringDataCreateInput>
    rules: InputJsonValue
    prizes: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringContestUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: RecurringContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    recurring?: XOR<RecurringDataUpdateEnvelopeInput, RecurringDataCreateInput>
    rules?: InputJsonValue | InputJsonValue
    prizes?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringContestUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: RecurringContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    recurring?: XOR<RecurringDataUpdateEnvelopeInput, RecurringDataCreateInput>
    rules?: InputJsonValue | InputJsonValue
    prizes?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestRuleCreateInput = {
    id?: string
    icon?: string | null
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contest: ContestCreateNestedOneWithoutContestRulesInput
  }

  export type ContestRuleUncheckedCreateInput = {
    id?: string
    icon?: string | null
    name: string
    description: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestRuleUpdateInput = {
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contest?: ContestUpdateOneRequiredWithoutContestRulesNestedInput
  }

  export type ContestRuleUncheckedUpdateInput = {
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestRuleCreateManyInput = {
    id?: string
    icon?: string | null
    name: string
    description: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestRuleUpdateManyMutationInput = {
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestRuleUncheckedUpdateManyInput = {
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestPhotoCreateInput = {
    id?: string
    title?: string | null
    contestId: string
    rank?: number | null
    promoted?: boolean
    promotionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participant: ContestParticipantCreateNestedOneWithoutPhotosInput
    votes?: VoteCreateNestedManyWithoutPhotoInput
    photo: UserPhotoCreateNestedOneWithoutContestUploadInput
    comments?: CommentCreateNestedManyWithoutReceiverInput
    achievements?: ContestAchievementCreateNestedManyWithoutPhotoInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoUncheckedCreateInput = {
    id?: string
    title?: string | null
    contestId: string
    participantId: string
    photoId: string
    rank?: number | null
    promoted?: boolean
    promotionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutPhotoInput
    comments?: CommentUncheckedCreateNestedManyWithoutReceiverInput
    achievements?: ContestAchievementUncheckedCreateNestedManyWithoutPhotoInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    promoted?: BoolFieldUpdateOperationsInput | boolean
    promotionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ContestParticipantUpdateOneRequiredWithoutPhotosNestedInput
    votes?: VoteUpdateManyWithoutPhotoNestedInput
    photo?: UserPhotoUpdateOneRequiredWithoutContestUploadNestedInput
    comments?: CommentUpdateManyWithoutReceiverNestedInput
    achievements?: ContestAchievementUpdateManyWithoutPhotoNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutPhotoNestedInput
  }

  export type ContestPhotoUncheckedUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    promoted?: BoolFieldUpdateOperationsInput | boolean
    promotionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutPhotoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutReceiverNestedInput
    achievements?: ContestAchievementUncheckedUpdateManyWithoutPhotoNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type ContestPhotoCreateManyInput = {
    id?: string
    title?: string | null
    contestId: string
    participantId: string
    photoId: string
    rank?: number | null
    promoted?: boolean
    promotionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestPhotoUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    promoted?: BoolFieldUpdateOperationsInput | boolean
    promotionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestPhotoUncheckedUpdateManyInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    promoted?: BoolFieldUpdateOperationsInput | boolean
    promotionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestWinnerCreateInput = {
    id?: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participant: ContestParticipantCreateNestedOneWithoutContestWinnerInput
    photo: ContestPhotoCreateNestedOneWithoutContestWinnerInput
  }

  export type ContestWinnerUncheckedCreateInput = {
    id?: string
    participantId: string
    contestId: string
    contestPhotoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestWinnerUpdateInput = {
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ContestParticipantUpdateOneRequiredWithoutContestWinnerNestedInput
    photo?: ContestPhotoUpdateOneRequiredWithoutContestWinnerNestedInput
  }

  export type ContestWinnerUncheckedUpdateInput = {
    participantId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    contestPhotoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestWinnerCreateManyInput = {
    id?: string
    participantId: string
    contestId: string
    contestPhotoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestWinnerUpdateManyMutationInput = {
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestWinnerUncheckedUpdateManyInput = {
    participantId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    contestPhotoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestParticipantCreateInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    level?: $Enums.YCLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contest: ContestCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutContestParticipantInput
    member?: TeamMemberCreateNestedOneWithoutContestParticipantInput
    photos?: ContestPhotoCreateNestedManyWithoutParticipantInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantUncheckedCreateInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    contestId: string
    userId: string
    memberId?: string | null
    level?: $Enums.YCLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ContestPhotoUncheckedCreateNestedManyWithoutParticipantInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantUpdateInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    level?: EnumYCLevelFieldUpdateOperationsInput | $Enums.YCLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contest?: ContestUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutContestParticipantNestedInput
    member?: TeamMemberUpdateOneWithoutContestParticipantNestedInput
    photos?: ContestPhotoUpdateManyWithoutParticipantNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUpdateManyWithoutParticipantNestedInput
  }

  export type ContestParticipantUncheckedUpdateInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    contestId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumYCLevelFieldUpdateOperationsInput | $Enums.YCLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ContestPhotoUncheckedUpdateManyWithoutParticipantNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type ContestParticipantCreateManyInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    contestId: string
    userId: string
    memberId?: string | null
    level?: $Enums.YCLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestParticipantUpdateManyMutationInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    level?: EnumYCLevelFieldUpdateOperationsInput | $Enums.YCLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestParticipantUncheckedUpdateManyInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    contestId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumYCLevelFieldUpdateOperationsInput | $Enums.YCLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestPrizeCreateInput = {
    id?: string
    category: $Enums.PrizeType
    trades?: number
    charges?: number
    keys?: number
    contest: ContestCreateNestedOneWithoutContestPrizesInput
  }

  export type ContestPrizeUncheckedCreateInput = {
    id?: string
    category: $Enums.PrizeType
    trades?: number
    charges?: number
    keys?: number
    contestId: string
  }

  export type ContestPrizeUpdateInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    trades?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    keys?: IntFieldUpdateOperationsInput | number
    contest?: ContestUpdateOneRequiredWithoutContestPrizesNestedInput
  }

  export type ContestPrizeUncheckedUpdateInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    trades?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    keys?: IntFieldUpdateOperationsInput | number
    contestId?: StringFieldUpdateOperationsInput | string
  }

  export type ContestPrizeCreateManyInput = {
    id?: string
    category: $Enums.PrizeType
    trades?: number
    charges?: number
    keys?: number
    contestId: string
  }

  export type ContestPrizeUpdateManyMutationInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    trades?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    keys?: IntFieldUpdateOperationsInput | number
  }

  export type ContestPrizeUncheckedUpdateManyInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    trades?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    keys?: IntFieldUpdateOperationsInput | number
    contestId?: StringFieldUpdateOperationsInput | string
  }

  export type ContestAchievementCreateInput = {
    id?: string
    category: $Enums.PrizeType
    createdAt?: Date | string
    updatedAt?: Date | string
    photo?: ContestPhotoCreateNestedOneWithoutAchievementsInput
    contest: ContestCreateNestedOneWithoutAchievementsInput
    participant?: ContestParticipantCreateNestedOneWithoutContestAchievementInput
  }

  export type ContestAchievementUncheckedCreateInput = {
    id?: string
    category: $Enums.PrizeType
    photoId?: string | null
    participantId?: string | null
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestAchievementUpdateInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: ContestPhotoUpdateOneWithoutAchievementsNestedInput
    contest?: ContestUpdateOneRequiredWithoutAchievementsNestedInput
    participant?: ContestParticipantUpdateOneWithoutContestAchievementNestedInput
  }

  export type ContestAchievementUncheckedUpdateInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    photoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestAchievementCreateManyInput = {
    id?: string
    category: $Enums.PrizeType
    photoId?: string | null
    participantId?: string | null
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestAchievementUpdateManyMutationInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestAchievementUncheckedUpdateManyInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    photoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    isSent?: boolean
    isRead?: boolean
    receiverId: string
    createdAt?: Date | string
    updatedAT?: Date | string
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    title: string
    message: string
    isSent?: boolean
    isRead?: boolean
    receiverId: string
    createdAt?: Date | string
    updatedAT?: Date | string
  }

  export type NotificationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isSent?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    receiverId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAT?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isSent?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    receiverId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAT?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    title: string
    message: string
    isSent?: boolean
    isRead?: boolean
    receiverId: string
    createdAt?: Date | string
    updatedAT?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isSent?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    receiverId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAT?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isSent?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    receiverId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAT?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    status: $Enums.PaymentStatus
    productId: string
    userId: string
    stripe_intent_id?: string | null
    amount: number
    currency: string
    method: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    status: $Enums.PaymentStatus
    productId: string
    userId: string
    stripe_intent_id?: string | null
    amount: number
    currency: string
    method: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripe_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateInput = {
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripe_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    status: $Enums.PaymentStatus
    productId: string
    userId: string
    stripe_intent_id?: string | null
    amount: number
    currency: string
    method: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripe_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripe_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SitePolicyCreateInput = {
    id?: string
    type: $Enums.SitePolicyType
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SitePolicyUncheckedCreateInput = {
    id?: string
    type: $Enums.SitePolicyType
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SitePolicyUpdateInput = {
    type?: EnumSitePolicyTypeFieldUpdateOperationsInput | $Enums.SitePolicyType
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SitePolicyUncheckedUpdateInput = {
    type?: EnumSitePolicyTypeFieldUpdateOperationsInput | $Enums.SitePolicyType
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SitePolicyCreateManyInput = {
    id?: string
    type: $Enums.SitePolicyType
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SitePolicyUpdateManyMutationInput = {
    type?: EnumSitePolicyTypeFieldUpdateOperationsInput | $Enums.SitePolicyType
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SitePolicyUncheckedUpdateManyInput = {
    type?: EnumSitePolicyTypeFieldUpdateOperationsInput | $Enums.SitePolicyType
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateInput = {
    id?: string
    teamId: string
  }

  export type RoomUncheckedCreateInput = {
    id?: string
    teamId: string
  }

  export type RoomUpdateInput = {
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type RoomUncheckedUpdateInput = {
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type RoomCreateManyInput = {
    id?: string
    teamId: string
  }

  export type RoomUpdateManyMutationInput = {
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type RoomUncheckedUpdateManyInput = {
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatCreateInput = {
    id?: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutChatInput
    sender: UserCreateNestedOneWithoutChatInput
  }

  export type ChatUncheckedCreateInput = {
    id?: string
    teamId: string
    senderId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutChatNestedInput
    sender?: UserUpdateOneRequiredWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatCreateManyInput = {
    id?: string
    teamId: string
    senderId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUncheckedUpdateManyInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    productType: $Enums.ProductType
    title: string
    quantity: number
    amount: number
    icon?: string | null
    description?: string | null
    image?: string | null
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    productType: $Enums.ProductType
    title: string
    quantity: number
    amount: number
    icon?: string | null
    description?: string | null
    image?: string | null
  }

  export type ProductUpdateInput = {
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUncheckedUpdateInput = {
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateManyInput = {
    id?: string
    productType: $Enums.ProductType
    title: string
    quantity: number
    amount: number
    icon?: string | null
    description?: string | null
    image?: string | null
  }

  export type ProductUpdateManyMutationInput = {
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    productType?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PriceCreateInput = {
    id?: string
    product_id: string
    name: string
    amount: number
    quantity: number
    price_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceUncheckedCreateInput = {
    id?: string
    product_id: string
    name: string
    amount: number
    quantity: number
    price_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceUpdateInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceUncheckedUpdateInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceCreateManyInput = {
    id?: string
    product_id: string
    name: string
    amount: number
    quantity: number
    price_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceUpdateManyMutationInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceUncheckedUpdateManyInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility?: $Enums.TeamAccessibility
    score?: number
    win?: number
    lost?: number
    badge: string
    min_requirement: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedTeamInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    chat?: ChatCreateNestedManyWithoutTeamInput
    participations?: TeamParticipationCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility?: $Enums.TeamAccessibility
    score?: number
    win?: number
    lost?: number
    badge: string
    min_requirement: number
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    chat?: ChatUncheckedCreateNestedManyWithoutTeamInput
    participations?: TeamParticipationUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    score?: IntFieldUpdateOperationsInput | number
    win?: IntFieldUpdateOperationsInput | number
    lost?: IntFieldUpdateOperationsInput | number
    badge?: StringFieldUpdateOperationsInput | string
    min_requirement?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedTeamNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    chat?: ChatUpdateManyWithoutTeamNestedInput
    participations?: TeamParticipationUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    score?: IntFieldUpdateOperationsInput | number
    win?: IntFieldUpdateOperationsInput | number
    lost?: IntFieldUpdateOperationsInput | number
    badge?: StringFieldUpdateOperationsInput | string
    min_requirement?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    chat?: ChatUncheckedUpdateManyWithoutTeamNestedInput
    participations?: TeamParticipationUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility?: $Enums.TeamAccessibility
    score?: number
    win?: number
    lost?: number
    badge: string
    min_requirement: number
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    score?: IntFieldUpdateOperationsInput | number
    win?: IntFieldUpdateOperationsInput | number
    lost?: IntFieldUpdateOperationsInput | number
    badge?: StringFieldUpdateOperationsInput | string
    min_requirement?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    score?: IntFieldUpdateOperationsInput | number
    win?: IntFieldUpdateOperationsInput | number
    lost?: IntFieldUpdateOperationsInput | number
    badge?: StringFieldUpdateOperationsInput | string
    min_requirement?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateInput = {
    id?: string
    status?: $Enums.TeamMemberStatus
    level?: $Enums.MemberLevel
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
    member: UserCreateNestedOneWithoutJoinedTeamInput
    contestParticipant?: ContestParticipantCreateNestedManyWithoutMemberInput
  }

  export type TeamMemberUncheckedCreateInput = {
    id?: string
    status?: $Enums.TeamMemberStatus
    level?: $Enums.MemberLevel
    teamId: string
    memberId: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutMemberInput
  }

  export type TeamMemberUpdateInput = {
    status?: EnumTeamMemberStatusFieldUpdateOperationsInput | $Enums.TeamMemberStatus
    level?: EnumMemberLevelFieldUpdateOperationsInput | $Enums.MemberLevel
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
    member?: UserUpdateOneRequiredWithoutJoinedTeamNestedInput
    contestParticipant?: ContestParticipantUpdateManyWithoutMemberNestedInput
  }

  export type TeamMemberUncheckedUpdateInput = {
    status?: EnumTeamMemberStatusFieldUpdateOperationsInput | $Enums.TeamMemberStatus
    level?: EnumMemberLevelFieldUpdateOperationsInput | $Enums.MemberLevel
    teamId?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contestParticipant?: ContestParticipantUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type TeamMemberCreateManyInput = {
    id?: string
    status?: $Enums.TeamMemberStatus
    level?: $Enums.MemberLevel
    teamId: string
    memberId: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateManyMutationInput = {
    status?: EnumTeamMemberStatusFieldUpdateOperationsInput | $Enums.TeamMemberStatus
    level?: EnumMemberLevelFieldUpdateOperationsInput | $Enums.MemberLevel
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyInput = {
    status?: EnumTeamMemberStatusFieldUpdateOperationsInput | $Enums.TeamMemberStatus
    level?: EnumMemberLevelFieldUpdateOperationsInput | $Enums.MemberLevel
    teamId?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamParticipationCreateInput = {
    id?: string
    team: TeamCreateNestedOneWithoutParticipationsInput
    contest: ContestCreateNestedOneWithoutTeamParticipationsInput
  }

  export type TeamParticipationUncheckedCreateInput = {
    id?: string
    teamId: string
    contestId: string
  }

  export type TeamParticipationUpdateInput = {
    team?: TeamUpdateOneRequiredWithoutParticipationsNestedInput
    contest?: ContestUpdateOneRequiredWithoutTeamParticipationsNestedInput
  }

  export type TeamParticipationUncheckedUpdateInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamParticipationCreateManyInput = {
    id?: string
    teamId: string
    contestId: string
  }

  export type TeamParticipationUpdateManyMutationInput = {

  }

  export type TeamParticipationUncheckedUpdateManyInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    store?: UserStoreCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    store?: UserStoreUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserUpdateInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    store?: UserStoreUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    store?: UserStoreUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStoreCreateInput = {
    id?: string
    promotes?: number
    trades?: number
    charges?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStoreInput
  }

  export type UserStoreUncheckedCreateInput = {
    id?: string
    userId: string
    promotes?: number
    trades?: number
    charges?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserStoreUpdateInput = {
    promotes?: IntFieldUpdateOperationsInput | number
    trades?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStoreNestedInput
  }

  export type UserStoreUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    promotes?: IntFieldUpdateOperationsInput | number
    trades?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStoreCreateManyInput = {
    id?: string
    userId: string
    promotes?: number
    trades?: number
    charges?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserStoreUpdateManyMutationInput = {
    promotes?: IntFieldUpdateOperationsInput | number
    trades?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStoreUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    promotes?: IntFieldUpdateOperationsInput | number
    trades?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhotoCreateInput = {
    id?: string
    url: string
    states?: XOR<PhotoStatsNullableCreateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: number
    labels?: UserPhotoCreatelabelsInput | string[]
    title?: string | null
    description?: string | null
    adult?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserPhotosInput
    contestUpload?: ContestPhotoCreateNestedManyWithoutPhotoInput
    likes?: LikeCreateNestedManyWithoutPhotoInput
  }

  export type UserPhotoUncheckedCreateInput = {
    id?: string
    url: string
    userId: string
    states?: XOR<PhotoStatsNullableCreateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: number
    labels?: UserPhotoCreatelabelsInput | string[]
    title?: string | null
    description?: string | null
    adult?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contestUpload?: ContestPhotoUncheckedCreateNestedManyWithoutPhotoInput
    likes?: LikeUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type UserPhotoUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserPhotosNestedInput
    contestUpload?: ContestPhotoUpdateManyWithoutPhotoNestedInput
    likes?: LikeUpdateManyWithoutPhotoNestedInput
  }

  export type UserPhotoUncheckedUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contestUpload?: ContestPhotoUncheckedUpdateManyWithoutPhotoNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type UserPhotoCreateManyInput = {
    id?: string
    url: string
    userId: string
    states?: XOR<PhotoStatsNullableCreateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: number
    labels?: UserPhotoCreatelabelsInput | string[]
    title?: string | null
    description?: string | null
    adult?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPhotoUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhotoUncheckedUpdateManyInput = {
    url?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: UserCreateNestedOneWithoutLikesInput
    photo: UserPhotoCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateInput = {
    id?: string
    providerId: string
    photoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: UserUpdateOneRequiredWithoutLikesNestedInput
    photo?: UserPhotoUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateManyInput = {
    id?: string
    providerId: string
    photoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpCreateInput = {
    id?: string
    code: string
    expires_in: Date | string
    otpStatus?: $Enums.OtpStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutOtpsInput
  }

  export type OtpUncheckedCreateInput = {
    id?: string
    code: string
    expires_in: Date | string
    userId: string
    otpStatus?: $Enums.OtpStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
  }

  export type OtpUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    expires_in?: DateTimeFieldUpdateOperationsInput | Date | string
    otpStatus?: EnumOtpStatusFieldUpdateOperationsInput | $Enums.OtpStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOtpsNestedInput
  }

  export type OtpUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    expires_in?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    otpStatus?: EnumOtpStatusFieldUpdateOperationsInput | $Enums.OtpStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpCreateManyInput = {
    id?: string
    code: string
    expires_in: Date | string
    userId: string
    otpStatus?: $Enums.OtpStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
  }

  export type OtpUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    expires_in?: DateTimeFieldUpdateOperationsInput | Date | string
    otpStatus?: EnumOtpStatusFieldUpdateOperationsInput | $Enums.OtpStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    expires_in?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    otpStatus?: EnumOtpStatusFieldUpdateOperationsInput | $Enums.OtpStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: UserCreateNestedOneWithoutCommentProvidesInput
    receiver: ContestPhotoCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutCommentRepliesInput
    CommentReplies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    text: string
    providerId: string
    receiverId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CommentReplies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: UserUpdateOneRequiredWithoutCommentProvidesNestedInput
    receiver?: ContestPhotoUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutCommentRepliesNestedInput
    CommentReplies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CommentReplies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    text: string
    providerId: string
    receiverId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    text?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowersInput
    following: UserCreateNestedOneWithoutFollowingsInput
  }

  export type FollowUncheckedCreateInput = {
    id?: string
    followerId: string
    followingId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowersNestedInput
    following?: UserUpdateOneRequiredWithoutFollowingsNestedInput
  }

  export type FollowUncheckedUpdateInput = {
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowCreateManyInput = {
    id?: string
    followerId: string
    followingId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyInput = {
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteCreateInput = {
    id?: string
    type: $Enums.VoteType
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: UserCreateNestedOneWithoutVotesInput
    photo: ContestPhotoCreateNestedOneWithoutVotesInput
    contest: ContestCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateInput = {
    id?: string
    providerId: string
    photoId: string
    contestId: string
    type: $Enums.VoteType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteUpdateInput = {
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: UserUpdateOneRequiredWithoutVotesNestedInput
    photo?: ContestPhotoUpdateOneRequiredWithoutVotesNestedInput
    contest?: ContestUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteCreateManyInput = {
    id?: string
    providerId: string
    photoId: string
    contestId: string
    type: $Enums.VoteType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteUpdateManyMutationInput = {
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUncheckedUpdateManyInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLevelCreateInput = {
    id?: string
    userId: string
    levelId: string
  }

  export type UserLevelUncheckedCreateInput = {
    id?: string
    userId: string
    levelId: string
  }

  export type UserLevelUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
  }

  export type UserLevelUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
  }

  export type UserLevelCreateManyInput = {
    id?: string
    userId: string
    levelId: string
  }

  export type UserLevelUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
  }

  export type UserLevelUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    levelId?: StringFieldUpdateOperationsInput | string
  }

  export type LevelCreateInput = {
    id?: string
    level: number
    levelName: $Enums.LevelName
    requirements?: XOR<LevelRequirementListCreateEnvelopeInput, LevelRequirementCreateInput> | LevelRequirementCreateInput[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LevelUncheckedCreateInput = {
    id?: string
    level: number
    levelName: $Enums.LevelName
    requirements?: XOR<LevelRequirementListCreateEnvelopeInput, LevelRequirementCreateInput> | LevelRequirementCreateInput[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LevelUpdateInput = {
    level?: IntFieldUpdateOperationsInput | number
    levelName?: EnumLevelNameFieldUpdateOperationsInput | $Enums.LevelName
    requirements?: XOR<LevelRequirementListUpdateEnvelopeInput, LevelRequirementCreateInput> | LevelRequirementCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevelUncheckedUpdateInput = {
    level?: IntFieldUpdateOperationsInput | number
    levelName?: EnumLevelNameFieldUpdateOperationsInput | $Enums.LevelName
    requirements?: XOR<LevelRequirementListUpdateEnvelopeInput, LevelRequirementCreateInput> | LevelRequirementCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevelCreateManyInput = {
    id?: string
    level: number
    levelName: $Enums.LevelName
    requirements?: XOR<LevelRequirementListCreateEnvelopeInput, LevelRequirementCreateInput> | LevelRequirementCreateInput[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LevelUpdateManyMutationInput = {
    level?: IntFieldUpdateOperationsInput | number
    levelName?: EnumLevelNameFieldUpdateOperationsInput | $Enums.LevelName
    requirements?: XOR<LevelRequirementListUpdateEnvelopeInput, LevelRequirementCreateInput> | LevelRequirementCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevelUncheckedUpdateManyInput = {
    level?: IntFieldUpdateOperationsInput | number
    levelName?: EnumLevelNameFieldUpdateOperationsInput | $Enums.LevelName
    requirements?: XOR<LevelRequirementListUpdateEnvelopeInput, LevelRequirementCreateInput> | LevelRequirementCreateInput[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type EnumContestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestStatus | EnumContestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContestStatus[] | ListEnumContestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestStatus[] | ListEnumContestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContestStatusFilter<$PrismaModel> | $Enums.ContestStatus
  }

  export type EnumContestModeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestMode | EnumContestModeFieldRefInput<$PrismaModel>
    in?: $Enums.ContestMode[] | ListEnumContestModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestMode[] | ListEnumContestModeFieldRefInput<$PrismaModel>
    not?: NestedEnumContestModeFilter<$PrismaModel> | $Enums.ContestMode
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ContestParticipantListRelationFilter = {
    every?: ContestParticipantWhereInput
    some?: ContestParticipantWhereInput
    none?: ContestParticipantWhereInput
  }

  export type TeamParticipationListRelationFilter = {
    every?: TeamParticipationWhereInput
    some?: TeamParticipationWhereInput
    none?: TeamParticipationWhereInput
  }

  export type VoteListRelationFilter = {
    every?: VoteWhereInput
    some?: VoteWhereInput
    none?: VoteWhereInput
  }

  export type ContestRuleListRelationFilter = {
    every?: ContestRuleWhereInput
    some?: ContestRuleWhereInput
    none?: ContestRuleWhereInput
  }

  export type ContestPrizeListRelationFilter = {
    every?: ContestPrizeWhereInput
    some?: ContestPrizeWhereInput
    none?: ContestPrizeWhereInput
  }

  export type ContestAchievementListRelationFilter = {
    every?: ContestAchievementWhereInput
    some?: ContestAchievementWhereInput
    none?: ContestAchievementWhereInput
  }

  export type ContestParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamParticipationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContestRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContestPrizeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContestAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContestCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    status?: SortOrder
    mode?: SortOrder
    maxUploads?: SortOrder
    isMoneyContest?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    level_requirements?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestAvgOrderByAggregateInput = {
    maxUploads?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    level_requirements?: SortOrder
  }

  export type ContestMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    status?: SortOrder
    mode?: SortOrder
    maxUploads?: SortOrder
    isMoneyContest?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    status?: SortOrder
    mode?: SortOrder
    maxUploads?: SortOrder
    isMoneyContest?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestSumOrderByAggregateInput = {
    maxUploads?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    level_requirements?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumContestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestStatus | EnumContestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContestStatus[] | ListEnumContestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestStatus[] | ListEnumContestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContestStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContestStatusFilter<$PrismaModel>
    _max?: NestedEnumContestStatusFilter<$PrismaModel>
  }

  export type EnumContestModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestMode | EnumContestModeFieldRefInput<$PrismaModel>
    in?: $Enums.ContestMode[] | ListEnumContestModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestMode[] | ListEnumContestModeFieldRefInput<$PrismaModel>
    not?: NestedEnumContestModeWithAggregatesFilter<$PrismaModel> | $Enums.ContestMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContestModeFilter<$PrismaModel>
    _max?: NestedEnumContestModeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type RecurringDataCompositeFilter = {
    equals?: RecurringDataObjectEqualityInput
    is?: RecurringDataWhereInput
    isNot?: RecurringDataWhereInput
  }

  export type RecurringDataObjectEqualityInput = {
    recurringType: $Enums.RecurringType
    previousOccurrence?: Date | string | null
    nextOccurrence: Date | string
    duration: number
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type RecurringDataOrderByInput = {
    recurringType?: SortOrder
    previousOccurrence?: SortOrder
    nextOccurrence?: SortOrder
    duration?: SortOrder
  }

  export type RecurringContestCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    maxUploads?: SortOrder
    isMoneyContest?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    level_requirements?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    creatorId?: SortOrder
    rules?: SortOrder
    prizes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringContestAvgOrderByAggregateInput = {
    maxUploads?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    level_requirements?: SortOrder
  }

  export type RecurringContestMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    maxUploads?: SortOrder
    isMoneyContest?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringContestMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    maxUploads?: SortOrder
    isMoneyContest?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringContestSumOrderByAggregateInput = {
    maxUploads?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    level_requirements?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ContestScalarRelationFilter = {
    is?: ContestWhereInput
    isNot?: ContestWhereInput
  }

  export type ContestRuleCountOrderByAggregateInput = {
    id?: SortOrder
    icon?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    icon?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestRuleMinOrderByAggregateInput = {
    id?: SortOrder
    icon?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type ContestParticipantScalarRelationFilter = {
    is?: ContestParticipantWhereInput
    isNot?: ContestParticipantWhereInput
  }

  export type UserPhotoScalarRelationFilter = {
    is?: UserPhotoWhereInput
    isNot?: UserPhotoWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type ContestWinnerListRelationFilter = {
    every?: ContestWinnerWhereInput
    some?: ContestWinnerWhereInput
    none?: ContestWinnerWhereInput
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContestWinnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContestPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    contestId?: SortOrder
    participantId?: SortOrder
    photoId?: SortOrder
    rank?: SortOrder
    promoted?: SortOrder
    promotionExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestPhotoAvgOrderByAggregateInput = {
    rank?: SortOrder
  }

  export type ContestPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    contestId?: SortOrder
    participantId?: SortOrder
    photoId?: SortOrder
    rank?: SortOrder
    promoted?: SortOrder
    promotionExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    contestId?: SortOrder
    participantId?: SortOrder
    photoId?: SortOrder
    rank?: SortOrder
    promoted?: SortOrder
    promotionExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestPhotoSumOrderByAggregateInput = {
    rank?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type ContestPhotoScalarRelationFilter = {
    is?: ContestPhotoWhereInput
    isNot?: ContestPhotoWhereInput
  }

  export type ContestWinnerCountOrderByAggregateInput = {
    id?: SortOrder
    participantId?: SortOrder
    contestId?: SortOrder
    contestPhotoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestWinnerMaxOrderByAggregateInput = {
    id?: SortOrder
    participantId?: SortOrder
    contestId?: SortOrder
    contestPhotoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestWinnerMinOrderByAggregateInput = {
    id?: SortOrder
    participantId?: SortOrder
    contestId?: SortOrder
    contestPhotoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumContestParticipantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestParticipantStatus | EnumContestParticipantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContestParticipantStatus[] | ListEnumContestParticipantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestParticipantStatus[] | ListEnumContestParticipantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContestParticipantStatusFilter<$PrismaModel> | $Enums.ContestParticipantStatus
  }

  export type EnumYCLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.YCLevel | EnumYCLevelFieldRefInput<$PrismaModel>
    in?: $Enums.YCLevel[] | ListEnumYCLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.YCLevel[] | ListEnumYCLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumYCLevelFilter<$PrismaModel> | $Enums.YCLevel
  }

  export type TeamMemberNullableScalarRelationFilter = {
    is?: TeamMemberWhereInput | null
    isNot?: TeamMemberWhereInput | null
  }

  export type ContestPhotoListRelationFilter = {
    every?: ContestPhotoWhereInput
    some?: ContestPhotoWhereInput
    none?: ContestPhotoWhereInput
  }

  export type ContestPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContestParticipantContestIdUserIdCompoundUniqueInput = {
    contestId: string
    userId: string
  }

  export type ContestParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    contestId?: SortOrder
    userId?: SortOrder
    memberId?: SortOrder
    level?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestParticipantAvgOrderByAggregateInput = {
    rank?: SortOrder
  }

  export type ContestParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    contestId?: SortOrder
    userId?: SortOrder
    memberId?: SortOrder
    level?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    contestId?: SortOrder
    userId?: SortOrder
    memberId?: SortOrder
    level?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestParticipantSumOrderByAggregateInput = {
    rank?: SortOrder
  }

  export type EnumContestParticipantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestParticipantStatus | EnumContestParticipantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContestParticipantStatus[] | ListEnumContestParticipantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestParticipantStatus[] | ListEnumContestParticipantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContestParticipantStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContestParticipantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContestParticipantStatusFilter<$PrismaModel>
    _max?: NestedEnumContestParticipantStatusFilter<$PrismaModel>
  }

  export type EnumYCLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.YCLevel | EnumYCLevelFieldRefInput<$PrismaModel>
    in?: $Enums.YCLevel[] | ListEnumYCLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.YCLevel[] | ListEnumYCLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumYCLevelWithAggregatesFilter<$PrismaModel> | $Enums.YCLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumYCLevelFilter<$PrismaModel>
    _max?: NestedEnumYCLevelFilter<$PrismaModel>
  }

  export type EnumPrizeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PrizeType | EnumPrizeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PrizeType[] | ListEnumPrizeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrizeType[] | ListEnumPrizeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPrizeTypeFilter<$PrismaModel> | $Enums.PrizeType
  }

  export type ContestPrizeCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    trades?: SortOrder
    charges?: SortOrder
    keys?: SortOrder
    contestId?: SortOrder
  }

  export type ContestPrizeAvgOrderByAggregateInput = {
    trades?: SortOrder
    charges?: SortOrder
    keys?: SortOrder
  }

  export type ContestPrizeMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    trades?: SortOrder
    charges?: SortOrder
    keys?: SortOrder
    contestId?: SortOrder
  }

  export type ContestPrizeMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    trades?: SortOrder
    charges?: SortOrder
    keys?: SortOrder
    contestId?: SortOrder
  }

  export type ContestPrizeSumOrderByAggregateInput = {
    trades?: SortOrder
    charges?: SortOrder
    keys?: SortOrder
  }

  export type EnumPrizeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrizeType | EnumPrizeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PrizeType[] | ListEnumPrizeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrizeType[] | ListEnumPrizeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPrizeTypeWithAggregatesFilter<$PrismaModel> | $Enums.PrizeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrizeTypeFilter<$PrismaModel>
    _max?: NestedEnumPrizeTypeFilter<$PrismaModel>
  }

  export type ContestPhotoNullableScalarRelationFilter = {
    is?: ContestPhotoWhereInput | null
    isNot?: ContestPhotoWhereInput | null
  }

  export type ContestParticipantNullableScalarRelationFilter = {
    is?: ContestParticipantWhereInput | null
    isNot?: ContestParticipantWhereInput | null
  }

  export type ContestAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    photoId?: SortOrder
    participantId?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    photoId?: SortOrder
    participantId?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    photoId?: SortOrder
    participantId?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isSent?: SortOrder
    isRead?: SortOrder
    receiverId?: SortOrder
    createdAt?: SortOrder
    updatedAT?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isSent?: SortOrder
    isRead?: SortOrder
    receiverId?: SortOrder
    createdAt?: SortOrder
    updatedAT?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isSent?: SortOrder
    isRead?: SortOrder
    receiverId?: SortOrder
    createdAt?: SortOrder
    updatedAT?: SortOrder
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    stripe_intent_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    stripe_intent_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    stripe_intent_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumSitePolicyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SitePolicyType | EnumSitePolicyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SitePolicyType[] | ListEnumSitePolicyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SitePolicyType[] | ListEnumSitePolicyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSitePolicyTypeFilter<$PrismaModel> | $Enums.SitePolicyType
  }

  export type SitePolicyCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SitePolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SitePolicyMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSitePolicyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SitePolicyType | EnumSitePolicyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SitePolicyType[] | ListEnumSitePolicyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SitePolicyType[] | ListEnumSitePolicyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSitePolicyTypeWithAggregatesFilter<$PrismaModel> | $Enums.SitePolicyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSitePolicyTypeFilter<$PrismaModel>
    _max?: NestedEnumSitePolicyTypeFilter<$PrismaModel>
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
  }

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type ChatCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    productType?: SortOrder
    title?: SortOrder
    quantity?: SortOrder
    amount?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    image?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    quantity?: SortOrder
    amount?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    productType?: SortOrder
    title?: SortOrder
    quantity?: SortOrder
    amount?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    image?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    productType?: SortOrder
    title?: SortOrder
    quantity?: SortOrder
    amount?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    image?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    quantity?: SortOrder
    amount?: SortOrder
  }

  export type EnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type PriceCountOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    quantity?: SortOrder
    price_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceAvgOrderByAggregateInput = {
    amount?: SortOrder
    quantity?: SortOrder
  }

  export type PriceMaxOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    quantity?: SortOrder
    price_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceMinOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    quantity?: SortOrder
    price_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceSumOrderByAggregateInput = {
    amount?: SortOrder
    quantity?: SortOrder
  }

  export type EnumTeamAccessibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamAccessibility | EnumTeamAccessibilityFieldRefInput<$PrismaModel>
    in?: $Enums.TeamAccessibility[] | ListEnumTeamAccessibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamAccessibility[] | ListEnumTeamAccessibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamAccessibilityFilter<$PrismaModel> | $Enums.TeamAccessibility
  }

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput
    some?: TeamMemberWhereInput
    none?: TeamMemberWhereInput
  }

  export type ChatListRelationFilter = {
    every?: ChatWhereInput
    some?: ChatWhereInput
    none?: ChatWhereInput
  }

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    language?: SortOrder
    country?: SortOrder
    description?: SortOrder
    accessibility?: SortOrder
    score?: SortOrder
    win?: SortOrder
    lost?: SortOrder
    badge?: SortOrder
    min_requirement?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamAvgOrderByAggregateInput = {
    score?: SortOrder
    win?: SortOrder
    lost?: SortOrder
    min_requirement?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    language?: SortOrder
    country?: SortOrder
    description?: SortOrder
    accessibility?: SortOrder
    score?: SortOrder
    win?: SortOrder
    lost?: SortOrder
    badge?: SortOrder
    min_requirement?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    language?: SortOrder
    country?: SortOrder
    description?: SortOrder
    accessibility?: SortOrder
    score?: SortOrder
    win?: SortOrder
    lost?: SortOrder
    badge?: SortOrder
    min_requirement?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamSumOrderByAggregateInput = {
    score?: SortOrder
    win?: SortOrder
    lost?: SortOrder
    min_requirement?: SortOrder
  }

  export type EnumTeamAccessibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamAccessibility | EnumTeamAccessibilityFieldRefInput<$PrismaModel>
    in?: $Enums.TeamAccessibility[] | ListEnumTeamAccessibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamAccessibility[] | ListEnumTeamAccessibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamAccessibilityWithAggregatesFilter<$PrismaModel> | $Enums.TeamAccessibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamAccessibilityFilter<$PrismaModel>
    _max?: NestedEnumTeamAccessibilityFilter<$PrismaModel>
  }

  export type EnumTeamMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamMemberStatus | EnumTeamMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TeamMemberStatus[] | ListEnumTeamMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamMemberStatus[] | ListEnumTeamMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamMemberStatusFilter<$PrismaModel> | $Enums.TeamMemberStatus
  }

  export type EnumMemberLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberLevel | EnumMemberLevelFieldRefInput<$PrismaModel>
    in?: $Enums.MemberLevel[] | ListEnumMemberLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberLevel[] | ListEnumMemberLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberLevelFilter<$PrismaModel> | $Enums.MemberLevel
  }

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    level?: SortOrder
    teamId?: SortOrder
    memberId?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    level?: SortOrder
    teamId?: SortOrder
    memberId?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    level?: SortOrder
    teamId?: SortOrder
    memberId?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTeamMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamMemberStatus | EnumTeamMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TeamMemberStatus[] | ListEnumTeamMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamMemberStatus[] | ListEnumTeamMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.TeamMemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumTeamMemberStatusFilter<$PrismaModel>
  }

  export type EnumMemberLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberLevel | EnumMemberLevelFieldRefInput<$PrismaModel>
    in?: $Enums.MemberLevel[] | ListEnumMemberLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberLevel[] | ListEnumMemberLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberLevelWithAggregatesFilter<$PrismaModel> | $Enums.MemberLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberLevelFilter<$PrismaModel>
    _max?: NestedEnumMemberLevelFilter<$PrismaModel>
  }

  export type TeamParticipationTeamIdContestIdCompoundUniqueInput = {
    teamId: string
    contestId: string
  }

  export type TeamParticipationCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    contestId?: SortOrder
  }

  export type TeamParticipationMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    contestId?: SortOrder
  }

  export type TeamParticipationMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    contestId?: SortOrder
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type OtpNullableScalarRelationFilter = {
    is?: OtpWhereInput | null
    isNot?: OtpWhereInput | null
  }

  export type UserStoreNullableScalarRelationFilter = {
    is?: UserStoreWhereInput | null
    isNot?: UserStoreWhereInput | null
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type ContestListRelationFilter = {
    every?: ContestWhereInput
    some?: ContestWhereInput
    none?: ContestWhereInput
  }

  export type FollowListRelationFilter = {
    every?: FollowWhereInput
    some?: FollowWhereInput
    none?: FollowWhereInput
  }

  export type LikeListRelationFilter = {
    every?: LikeWhereInput
    some?: LikeWhereInput
    none?: LikeWhereInput
  }

  export type UserPhotoListRelationFilter = {
    every?: UserPhotoWhereInput
    some?: UserPhotoWhereInput
    none?: UserPhotoWhereInput
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    cover?: SortOrder
    avatar?: SortOrder
    socialId?: SortOrder
    socialProvider?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    location?: SortOrder
    password?: SortOrder
    role?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    cover?: SortOrder
    avatar?: SortOrder
    socialId?: SortOrder
    socialProvider?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    location?: SortOrder
    password?: SortOrder
    role?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    cover?: SortOrder
    avatar?: SortOrder
    socialId?: SortOrder
    socialProvider?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    location?: SortOrder
    password?: SortOrder
    role?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserStoreCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    promotes?: SortOrder
    trades?: SortOrder
    charges?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserStoreAvgOrderByAggregateInput = {
    promotes?: SortOrder
    trades?: SortOrder
    charges?: SortOrder
  }

  export type UserStoreMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    promotes?: SortOrder
    trades?: SortOrder
    charges?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserStoreMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    promotes?: SortOrder
    trades?: SortOrder
    charges?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserStoreSumOrderByAggregateInput = {
    promotes?: SortOrder
    trades?: SortOrder
    charges?: SortOrder
  }

  export type PhotoStatsNullableCompositeFilter = {
    equals?: PhotoStatsObjectEqualityInput | null
    is?: PhotoStatsWhereInput | null
    isNot?: PhotoStatsWhereInput | null
    isSet?: boolean
  }

  export type PhotoStatsObjectEqualityInput = {
    Composition: number
    Content: number
    Creativity: number
    Technique: number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type PhotoStatsOrderByInput = {
    Composition?: SortOrder
    Content?: SortOrder
    Creativity?: SortOrder
    Technique?: SortOrder
  }

  export type UserPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    userId?: SortOrder
    views?: SortOrder
    labels?: SortOrder
    title?: SortOrder
    description?: SortOrder
    adult?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPhotoAvgOrderByAggregateInput = {
    views?: SortOrder
  }

  export type UserPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    userId?: SortOrder
    views?: SortOrder
    title?: SortOrder
    description?: SortOrder
    adult?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    userId?: SortOrder
    views?: SortOrder
    title?: SortOrder
    description?: SortOrder
    adult?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPhotoSumOrderByAggregateInput = {
    views?: SortOrder
  }

  export type LikePhotoIdProviderIdCompoundUniqueInput = {
    photoId: string
    providerId: string
  }

  export type LikeCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LikeMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LikeMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumOtpStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OtpStatus | EnumOtpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OtpStatus[] | ListEnumOtpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OtpStatus[] | ListEnumOtpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOtpStatusFilter<$PrismaModel> | $Enums.OtpStatus
  }

  export type OtpCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    expires_in?: SortOrder
    userId?: SortOrder
    otpStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type OtpMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    expires_in?: SortOrder
    userId?: SortOrder
    otpStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type OtpMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    expires_in?: SortOrder
    userId?: SortOrder
    otpStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EnumOtpStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OtpStatus | EnumOtpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OtpStatus[] | ListEnumOtpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OtpStatus[] | ListEnumOtpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOtpStatusWithAggregatesFilter<$PrismaModel> | $Enums.OtpStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOtpStatusFilter<$PrismaModel>
    _max?: NestedEnumOtpStatusFilter<$PrismaModel>
  }

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    providerId?: SortOrder
    receiverId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    providerId?: SortOrder
    receiverId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    providerId?: SortOrder
    receiverId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FollowFollowerIdFollowingIdCompoundUniqueInput = {
    followerId: string
    followingId: string
  }

  export type FollowCountOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FollowMaxOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FollowMinOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumVoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteType | EnumVoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteTypeFilter<$PrismaModel> | $Enums.VoteType
  }

  export type VoteCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    photoId?: SortOrder
    contestId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoteMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    photoId?: SortOrder
    contestId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoteMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    photoId?: SortOrder
    contestId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumVoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteType | EnumVoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.VoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoteTypeFilter<$PrismaModel>
    _max?: NestedEnumVoteTypeFilter<$PrismaModel>
  }

  export type UserLevelCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    levelId?: SortOrder
  }

  export type UserLevelMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    levelId?: SortOrder
  }

  export type UserLevelMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    levelId?: SortOrder
  }

  export type EnumLevelNameFilter<$PrismaModel = never> = {
    equals?: $Enums.LevelName | EnumLevelNameFieldRefInput<$PrismaModel>
    in?: $Enums.LevelName[] | ListEnumLevelNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.LevelName[] | ListEnumLevelNameFieldRefInput<$PrismaModel>
    not?: NestedEnumLevelNameFilter<$PrismaModel> | $Enums.LevelName
  }

  export type LevelRequirementCompositeListFilter = {
    equals?: LevelRequirementObjectEqualityInput[]
    every?: LevelRequirementWhereInput
    some?: LevelRequirementWhereInput
    none?: LevelRequirementWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type LevelRequirementObjectEqualityInput = {
    title: string
    required: number
    badge: BadgeObjectEqualityInput
  }

  export type LevelRequirementOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type LevelCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    levelName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevelAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type LevelMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    levelName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevelMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    levelName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LevelSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type EnumLevelNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LevelName | EnumLevelNameFieldRefInput<$PrismaModel>
    in?: $Enums.LevelName[] | ListEnumLevelNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.LevelName[] | ListEnumLevelNameFieldRefInput<$PrismaModel>
    not?: NestedEnumLevelNameWithAggregatesFilter<$PrismaModel> | $Enums.LevelName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLevelNameFilter<$PrismaModel>
    _max?: NestedEnumLevelNameFilter<$PrismaModel>
  }

  export type ContestCreatelevel_requirementsInput = {
    set: number[]
  }

  export type UserCreateNestedOneWithoutCreatedContestsInput = {
    create?: XOR<UserCreateWithoutCreatedContestsInput, UserUncheckedCreateWithoutCreatedContestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedContestsInput
    connect?: UserWhereUniqueInput
  }

  export type ContestParticipantCreateNestedManyWithoutContestInput = {
    create?: XOR<ContestParticipantCreateWithoutContestInput, ContestParticipantUncheckedCreateWithoutContestInput> | ContestParticipantCreateWithoutContestInput[] | ContestParticipantUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutContestInput | ContestParticipantCreateOrConnectWithoutContestInput[]
    createMany?: ContestParticipantCreateManyContestInputEnvelope
    connect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
  }

  export type TeamParticipationCreateNestedManyWithoutContestInput = {
    create?: XOR<TeamParticipationCreateWithoutContestInput, TeamParticipationUncheckedCreateWithoutContestInput> | TeamParticipationCreateWithoutContestInput[] | TeamParticipationUncheckedCreateWithoutContestInput[]
    connectOrCreate?: TeamParticipationCreateOrConnectWithoutContestInput | TeamParticipationCreateOrConnectWithoutContestInput[]
    createMany?: TeamParticipationCreateManyContestInputEnvelope
    connect?: TeamParticipationWhereUniqueInput | TeamParticipationWhereUniqueInput[]
  }

  export type VoteCreateNestedManyWithoutContestInput = {
    create?: XOR<VoteCreateWithoutContestInput, VoteUncheckedCreateWithoutContestInput> | VoteCreateWithoutContestInput[] | VoteUncheckedCreateWithoutContestInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutContestInput | VoteCreateOrConnectWithoutContestInput[]
    createMany?: VoteCreateManyContestInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type ContestRuleCreateNestedManyWithoutContestInput = {
    create?: XOR<ContestRuleCreateWithoutContestInput, ContestRuleUncheckedCreateWithoutContestInput> | ContestRuleCreateWithoutContestInput[] | ContestRuleUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestRuleCreateOrConnectWithoutContestInput | ContestRuleCreateOrConnectWithoutContestInput[]
    createMany?: ContestRuleCreateManyContestInputEnvelope
    connect?: ContestRuleWhereUniqueInput | ContestRuleWhereUniqueInput[]
  }

  export type ContestPrizeCreateNestedManyWithoutContestInput = {
    create?: XOR<ContestPrizeCreateWithoutContestInput, ContestPrizeUncheckedCreateWithoutContestInput> | ContestPrizeCreateWithoutContestInput[] | ContestPrizeUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestPrizeCreateOrConnectWithoutContestInput | ContestPrizeCreateOrConnectWithoutContestInput[]
    createMany?: ContestPrizeCreateManyContestInputEnvelope
    connect?: ContestPrizeWhereUniqueInput | ContestPrizeWhereUniqueInput[]
  }

  export type ContestAchievementCreateNestedManyWithoutContestInput = {
    create?: XOR<ContestAchievementCreateWithoutContestInput, ContestAchievementUncheckedCreateWithoutContestInput> | ContestAchievementCreateWithoutContestInput[] | ContestAchievementUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestAchievementCreateOrConnectWithoutContestInput | ContestAchievementCreateOrConnectWithoutContestInput[]
    createMany?: ContestAchievementCreateManyContestInputEnvelope
    connect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
  }

  export type ContestParticipantUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<ContestParticipantCreateWithoutContestInput, ContestParticipantUncheckedCreateWithoutContestInput> | ContestParticipantCreateWithoutContestInput[] | ContestParticipantUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutContestInput | ContestParticipantCreateOrConnectWithoutContestInput[]
    createMany?: ContestParticipantCreateManyContestInputEnvelope
    connect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
  }

  export type TeamParticipationUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<TeamParticipationCreateWithoutContestInput, TeamParticipationUncheckedCreateWithoutContestInput> | TeamParticipationCreateWithoutContestInput[] | TeamParticipationUncheckedCreateWithoutContestInput[]
    connectOrCreate?: TeamParticipationCreateOrConnectWithoutContestInput | TeamParticipationCreateOrConnectWithoutContestInput[]
    createMany?: TeamParticipationCreateManyContestInputEnvelope
    connect?: TeamParticipationWhereUniqueInput | TeamParticipationWhereUniqueInput[]
  }

  export type VoteUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<VoteCreateWithoutContestInput, VoteUncheckedCreateWithoutContestInput> | VoteCreateWithoutContestInput[] | VoteUncheckedCreateWithoutContestInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutContestInput | VoteCreateOrConnectWithoutContestInput[]
    createMany?: VoteCreateManyContestInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type ContestRuleUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<ContestRuleCreateWithoutContestInput, ContestRuleUncheckedCreateWithoutContestInput> | ContestRuleCreateWithoutContestInput[] | ContestRuleUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestRuleCreateOrConnectWithoutContestInput | ContestRuleCreateOrConnectWithoutContestInput[]
    createMany?: ContestRuleCreateManyContestInputEnvelope
    connect?: ContestRuleWhereUniqueInput | ContestRuleWhereUniqueInput[]
  }

  export type ContestPrizeUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<ContestPrizeCreateWithoutContestInput, ContestPrizeUncheckedCreateWithoutContestInput> | ContestPrizeCreateWithoutContestInput[] | ContestPrizeUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestPrizeCreateOrConnectWithoutContestInput | ContestPrizeCreateOrConnectWithoutContestInput[]
    createMany?: ContestPrizeCreateManyContestInputEnvelope
    connect?: ContestPrizeWhereUniqueInput | ContestPrizeWhereUniqueInput[]
  }

  export type ContestAchievementUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<ContestAchievementCreateWithoutContestInput, ContestAchievementUncheckedCreateWithoutContestInput> | ContestAchievementCreateWithoutContestInput[] | ContestAchievementUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestAchievementCreateOrConnectWithoutContestInput | ContestAchievementCreateOrConnectWithoutContestInput[]
    createMany?: ContestAchievementCreateManyContestInputEnvelope
    connect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type EnumContestStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContestStatus
  }

  export type EnumContestModeFieldUpdateOperationsInput = {
    set?: $Enums.ContestMode
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type ContestUpdatelevel_requirementsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutCreatedContestsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedContestsInput, UserUncheckedCreateWithoutCreatedContestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedContestsInput
    upsert?: UserUpsertWithoutCreatedContestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedContestsInput, UserUpdateWithoutCreatedContestsInput>, UserUncheckedUpdateWithoutCreatedContestsInput>
  }

  export type ContestParticipantUpdateManyWithoutContestNestedInput = {
    create?: XOR<ContestParticipantCreateWithoutContestInput, ContestParticipantUncheckedCreateWithoutContestInput> | ContestParticipantCreateWithoutContestInput[] | ContestParticipantUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutContestInput | ContestParticipantCreateOrConnectWithoutContestInput[]
    upsert?: ContestParticipantUpsertWithWhereUniqueWithoutContestInput | ContestParticipantUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: ContestParticipantCreateManyContestInputEnvelope
    set?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    disconnect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    delete?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    connect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    update?: ContestParticipantUpdateWithWhereUniqueWithoutContestInput | ContestParticipantUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: ContestParticipantUpdateManyWithWhereWithoutContestInput | ContestParticipantUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: ContestParticipantScalarWhereInput | ContestParticipantScalarWhereInput[]
  }

  export type TeamParticipationUpdateManyWithoutContestNestedInput = {
    create?: XOR<TeamParticipationCreateWithoutContestInput, TeamParticipationUncheckedCreateWithoutContestInput> | TeamParticipationCreateWithoutContestInput[] | TeamParticipationUncheckedCreateWithoutContestInput[]
    connectOrCreate?: TeamParticipationCreateOrConnectWithoutContestInput | TeamParticipationCreateOrConnectWithoutContestInput[]
    upsert?: TeamParticipationUpsertWithWhereUniqueWithoutContestInput | TeamParticipationUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: TeamParticipationCreateManyContestInputEnvelope
    set?: TeamParticipationWhereUniqueInput | TeamParticipationWhereUniqueInput[]
    disconnect?: TeamParticipationWhereUniqueInput | TeamParticipationWhereUniqueInput[]
    delete?: TeamParticipationWhereUniqueInput | TeamParticipationWhereUniqueInput[]
    connect?: TeamParticipationWhereUniqueInput | TeamParticipationWhereUniqueInput[]
    update?: TeamParticipationUpdateWithWhereUniqueWithoutContestInput | TeamParticipationUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: TeamParticipationUpdateManyWithWhereWithoutContestInput | TeamParticipationUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: TeamParticipationScalarWhereInput | TeamParticipationScalarWhereInput[]
  }

  export type VoteUpdateManyWithoutContestNestedInput = {
    create?: XOR<VoteCreateWithoutContestInput, VoteUncheckedCreateWithoutContestInput> | VoteCreateWithoutContestInput[] | VoteUncheckedCreateWithoutContestInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutContestInput | VoteCreateOrConnectWithoutContestInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutContestInput | VoteUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: VoteCreateManyContestInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutContestInput | VoteUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutContestInput | VoteUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type ContestRuleUpdateManyWithoutContestNestedInput = {
    create?: XOR<ContestRuleCreateWithoutContestInput, ContestRuleUncheckedCreateWithoutContestInput> | ContestRuleCreateWithoutContestInput[] | ContestRuleUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestRuleCreateOrConnectWithoutContestInput | ContestRuleCreateOrConnectWithoutContestInput[]
    upsert?: ContestRuleUpsertWithWhereUniqueWithoutContestInput | ContestRuleUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: ContestRuleCreateManyContestInputEnvelope
    set?: ContestRuleWhereUniqueInput | ContestRuleWhereUniqueInput[]
    disconnect?: ContestRuleWhereUniqueInput | ContestRuleWhereUniqueInput[]
    delete?: ContestRuleWhereUniqueInput | ContestRuleWhereUniqueInput[]
    connect?: ContestRuleWhereUniqueInput | ContestRuleWhereUniqueInput[]
    update?: ContestRuleUpdateWithWhereUniqueWithoutContestInput | ContestRuleUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: ContestRuleUpdateManyWithWhereWithoutContestInput | ContestRuleUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: ContestRuleScalarWhereInput | ContestRuleScalarWhereInput[]
  }

  export type ContestPrizeUpdateManyWithoutContestNestedInput = {
    create?: XOR<ContestPrizeCreateWithoutContestInput, ContestPrizeUncheckedCreateWithoutContestInput> | ContestPrizeCreateWithoutContestInput[] | ContestPrizeUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestPrizeCreateOrConnectWithoutContestInput | ContestPrizeCreateOrConnectWithoutContestInput[]
    upsert?: ContestPrizeUpsertWithWhereUniqueWithoutContestInput | ContestPrizeUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: ContestPrizeCreateManyContestInputEnvelope
    set?: ContestPrizeWhereUniqueInput | ContestPrizeWhereUniqueInput[]
    disconnect?: ContestPrizeWhereUniqueInput | ContestPrizeWhereUniqueInput[]
    delete?: ContestPrizeWhereUniqueInput | ContestPrizeWhereUniqueInput[]
    connect?: ContestPrizeWhereUniqueInput | ContestPrizeWhereUniqueInput[]
    update?: ContestPrizeUpdateWithWhereUniqueWithoutContestInput | ContestPrizeUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: ContestPrizeUpdateManyWithWhereWithoutContestInput | ContestPrizeUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: ContestPrizeScalarWhereInput | ContestPrizeScalarWhereInput[]
  }

  export type ContestAchievementUpdateManyWithoutContestNestedInput = {
    create?: XOR<ContestAchievementCreateWithoutContestInput, ContestAchievementUncheckedCreateWithoutContestInput> | ContestAchievementCreateWithoutContestInput[] | ContestAchievementUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestAchievementCreateOrConnectWithoutContestInput | ContestAchievementCreateOrConnectWithoutContestInput[]
    upsert?: ContestAchievementUpsertWithWhereUniqueWithoutContestInput | ContestAchievementUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: ContestAchievementCreateManyContestInputEnvelope
    set?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    disconnect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    delete?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    connect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    update?: ContestAchievementUpdateWithWhereUniqueWithoutContestInput | ContestAchievementUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: ContestAchievementUpdateManyWithWhereWithoutContestInput | ContestAchievementUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: ContestAchievementScalarWhereInput | ContestAchievementScalarWhereInput[]
  }

  export type ContestParticipantUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<ContestParticipantCreateWithoutContestInput, ContestParticipantUncheckedCreateWithoutContestInput> | ContestParticipantCreateWithoutContestInput[] | ContestParticipantUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutContestInput | ContestParticipantCreateOrConnectWithoutContestInput[]
    upsert?: ContestParticipantUpsertWithWhereUniqueWithoutContestInput | ContestParticipantUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: ContestParticipantCreateManyContestInputEnvelope
    set?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    disconnect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    delete?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    connect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    update?: ContestParticipantUpdateWithWhereUniqueWithoutContestInput | ContestParticipantUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: ContestParticipantUpdateManyWithWhereWithoutContestInput | ContestParticipantUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: ContestParticipantScalarWhereInput | ContestParticipantScalarWhereInput[]
  }

  export type TeamParticipationUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<TeamParticipationCreateWithoutContestInput, TeamParticipationUncheckedCreateWithoutContestInput> | TeamParticipationCreateWithoutContestInput[] | TeamParticipationUncheckedCreateWithoutContestInput[]
    connectOrCreate?: TeamParticipationCreateOrConnectWithoutContestInput | TeamParticipationCreateOrConnectWithoutContestInput[]
    upsert?: TeamParticipationUpsertWithWhereUniqueWithoutContestInput | TeamParticipationUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: TeamParticipationCreateManyContestInputEnvelope
    set?: TeamParticipationWhereUniqueInput | TeamParticipationWhereUniqueInput[]
    disconnect?: TeamParticipationWhereUniqueInput | TeamParticipationWhereUniqueInput[]
    delete?: TeamParticipationWhereUniqueInput | TeamParticipationWhereUniqueInput[]
    connect?: TeamParticipationWhereUniqueInput | TeamParticipationWhereUniqueInput[]
    update?: TeamParticipationUpdateWithWhereUniqueWithoutContestInput | TeamParticipationUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: TeamParticipationUpdateManyWithWhereWithoutContestInput | TeamParticipationUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: TeamParticipationScalarWhereInput | TeamParticipationScalarWhereInput[]
  }

  export type VoteUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<VoteCreateWithoutContestInput, VoteUncheckedCreateWithoutContestInput> | VoteCreateWithoutContestInput[] | VoteUncheckedCreateWithoutContestInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutContestInput | VoteCreateOrConnectWithoutContestInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutContestInput | VoteUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: VoteCreateManyContestInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutContestInput | VoteUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutContestInput | VoteUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type ContestRuleUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<ContestRuleCreateWithoutContestInput, ContestRuleUncheckedCreateWithoutContestInput> | ContestRuleCreateWithoutContestInput[] | ContestRuleUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestRuleCreateOrConnectWithoutContestInput | ContestRuleCreateOrConnectWithoutContestInput[]
    upsert?: ContestRuleUpsertWithWhereUniqueWithoutContestInput | ContestRuleUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: ContestRuleCreateManyContestInputEnvelope
    set?: ContestRuleWhereUniqueInput | ContestRuleWhereUniqueInput[]
    disconnect?: ContestRuleWhereUniqueInput | ContestRuleWhereUniqueInput[]
    delete?: ContestRuleWhereUniqueInput | ContestRuleWhereUniqueInput[]
    connect?: ContestRuleWhereUniqueInput | ContestRuleWhereUniqueInput[]
    update?: ContestRuleUpdateWithWhereUniqueWithoutContestInput | ContestRuleUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: ContestRuleUpdateManyWithWhereWithoutContestInput | ContestRuleUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: ContestRuleScalarWhereInput | ContestRuleScalarWhereInput[]
  }

  export type ContestPrizeUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<ContestPrizeCreateWithoutContestInput, ContestPrizeUncheckedCreateWithoutContestInput> | ContestPrizeCreateWithoutContestInput[] | ContestPrizeUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestPrizeCreateOrConnectWithoutContestInput | ContestPrizeCreateOrConnectWithoutContestInput[]
    upsert?: ContestPrizeUpsertWithWhereUniqueWithoutContestInput | ContestPrizeUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: ContestPrizeCreateManyContestInputEnvelope
    set?: ContestPrizeWhereUniqueInput | ContestPrizeWhereUniqueInput[]
    disconnect?: ContestPrizeWhereUniqueInput | ContestPrizeWhereUniqueInput[]
    delete?: ContestPrizeWhereUniqueInput | ContestPrizeWhereUniqueInput[]
    connect?: ContestPrizeWhereUniqueInput | ContestPrizeWhereUniqueInput[]
    update?: ContestPrizeUpdateWithWhereUniqueWithoutContestInput | ContestPrizeUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: ContestPrizeUpdateManyWithWhereWithoutContestInput | ContestPrizeUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: ContestPrizeScalarWhereInput | ContestPrizeScalarWhereInput[]
  }

  export type ContestAchievementUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<ContestAchievementCreateWithoutContestInput, ContestAchievementUncheckedCreateWithoutContestInput> | ContestAchievementCreateWithoutContestInput[] | ContestAchievementUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestAchievementCreateOrConnectWithoutContestInput | ContestAchievementCreateOrConnectWithoutContestInput[]
    upsert?: ContestAchievementUpsertWithWhereUniqueWithoutContestInput | ContestAchievementUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: ContestAchievementCreateManyContestInputEnvelope
    set?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    disconnect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    delete?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    connect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    update?: ContestAchievementUpdateWithWhereUniqueWithoutContestInput | ContestAchievementUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: ContestAchievementUpdateManyWithWhereWithoutContestInput | ContestAchievementUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: ContestAchievementScalarWhereInput | ContestAchievementScalarWhereInput[]
  }

  export type RecurringContestCreatelevel_requirementsInput = {
    set: number[]
  }

  export type RecurringDataCreateEnvelopeInput = {
    set?: RecurringDataCreateInput
  }

  export type RecurringDataCreateInput = {
    recurringType: $Enums.RecurringType
    previousOccurrence?: Date | string | null
    nextOccurrence: Date | string
    duration?: number
  }

  export type RecurringContestUpdatelevel_requirementsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type RecurringDataUpdateEnvelopeInput = {
    set?: RecurringDataCreateInput
    update?: RecurringDataUpdateInput
  }

  export type ContestCreateNestedOneWithoutContestRulesInput = {
    create?: XOR<ContestCreateWithoutContestRulesInput, ContestUncheckedCreateWithoutContestRulesInput>
    connectOrCreate?: ContestCreateOrConnectWithoutContestRulesInput
    connect?: ContestWhereUniqueInput
  }

  export type ContestUpdateOneRequiredWithoutContestRulesNestedInput = {
    create?: XOR<ContestCreateWithoutContestRulesInput, ContestUncheckedCreateWithoutContestRulesInput>
    connectOrCreate?: ContestCreateOrConnectWithoutContestRulesInput
    upsert?: ContestUpsertWithoutContestRulesInput
    connect?: ContestWhereUniqueInput
    update?: XOR<XOR<ContestUpdateToOneWithWhereWithoutContestRulesInput, ContestUpdateWithoutContestRulesInput>, ContestUncheckedUpdateWithoutContestRulesInput>
  }

  export type ContestParticipantCreateNestedOneWithoutPhotosInput = {
    create?: XOR<ContestParticipantCreateWithoutPhotosInput, ContestParticipantUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutPhotosInput
    connect?: ContestParticipantWhereUniqueInput
  }

  export type VoteCreateNestedManyWithoutPhotoInput = {
    create?: XOR<VoteCreateWithoutPhotoInput, VoteUncheckedCreateWithoutPhotoInput> | VoteCreateWithoutPhotoInput[] | VoteUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutPhotoInput | VoteCreateOrConnectWithoutPhotoInput[]
    createMany?: VoteCreateManyPhotoInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type UserPhotoCreateNestedOneWithoutContestUploadInput = {
    create?: XOR<UserPhotoCreateWithoutContestUploadInput, UserPhotoUncheckedCreateWithoutContestUploadInput>
    connectOrCreate?: UserPhotoCreateOrConnectWithoutContestUploadInput
    connect?: UserPhotoWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutReceiverInput = {
    create?: XOR<CommentCreateWithoutReceiverInput, CommentUncheckedCreateWithoutReceiverInput> | CommentCreateWithoutReceiverInput[] | CommentUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutReceiverInput | CommentCreateOrConnectWithoutReceiverInput[]
    createMany?: CommentCreateManyReceiverInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ContestAchievementCreateNestedManyWithoutPhotoInput = {
    create?: XOR<ContestAchievementCreateWithoutPhotoInput, ContestAchievementUncheckedCreateWithoutPhotoInput> | ContestAchievementCreateWithoutPhotoInput[] | ContestAchievementUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestAchievementCreateOrConnectWithoutPhotoInput | ContestAchievementCreateOrConnectWithoutPhotoInput[]
    createMany?: ContestAchievementCreateManyPhotoInputEnvelope
    connect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
  }

  export type ContestWinnerCreateNestedManyWithoutPhotoInput = {
    create?: XOR<ContestWinnerCreateWithoutPhotoInput, ContestWinnerUncheckedCreateWithoutPhotoInput> | ContestWinnerCreateWithoutPhotoInput[] | ContestWinnerUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestWinnerCreateOrConnectWithoutPhotoInput | ContestWinnerCreateOrConnectWithoutPhotoInput[]
    createMany?: ContestWinnerCreateManyPhotoInputEnvelope
    connect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
  }

  export type VoteUncheckedCreateNestedManyWithoutPhotoInput = {
    create?: XOR<VoteCreateWithoutPhotoInput, VoteUncheckedCreateWithoutPhotoInput> | VoteCreateWithoutPhotoInput[] | VoteUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutPhotoInput | VoteCreateOrConnectWithoutPhotoInput[]
    createMany?: VoteCreateManyPhotoInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<CommentCreateWithoutReceiverInput, CommentUncheckedCreateWithoutReceiverInput> | CommentCreateWithoutReceiverInput[] | CommentUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutReceiverInput | CommentCreateOrConnectWithoutReceiverInput[]
    createMany?: CommentCreateManyReceiverInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ContestAchievementUncheckedCreateNestedManyWithoutPhotoInput = {
    create?: XOR<ContestAchievementCreateWithoutPhotoInput, ContestAchievementUncheckedCreateWithoutPhotoInput> | ContestAchievementCreateWithoutPhotoInput[] | ContestAchievementUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestAchievementCreateOrConnectWithoutPhotoInput | ContestAchievementCreateOrConnectWithoutPhotoInput[]
    createMany?: ContestAchievementCreateManyPhotoInputEnvelope
    connect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
  }

  export type ContestWinnerUncheckedCreateNestedManyWithoutPhotoInput = {
    create?: XOR<ContestWinnerCreateWithoutPhotoInput, ContestWinnerUncheckedCreateWithoutPhotoInput> | ContestWinnerCreateWithoutPhotoInput[] | ContestWinnerUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestWinnerCreateOrConnectWithoutPhotoInput | ContestWinnerCreateOrConnectWithoutPhotoInput[]
    createMany?: ContestWinnerCreateManyPhotoInputEnvelope
    connect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type ContestParticipantUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<ContestParticipantCreateWithoutPhotosInput, ContestParticipantUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutPhotosInput
    upsert?: ContestParticipantUpsertWithoutPhotosInput
    connect?: ContestParticipantWhereUniqueInput
    update?: XOR<XOR<ContestParticipantUpdateToOneWithWhereWithoutPhotosInput, ContestParticipantUpdateWithoutPhotosInput>, ContestParticipantUncheckedUpdateWithoutPhotosInput>
  }

  export type VoteUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<VoteCreateWithoutPhotoInput, VoteUncheckedCreateWithoutPhotoInput> | VoteCreateWithoutPhotoInput[] | VoteUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutPhotoInput | VoteCreateOrConnectWithoutPhotoInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutPhotoInput | VoteUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: VoteCreateManyPhotoInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutPhotoInput | VoteUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutPhotoInput | VoteUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type UserPhotoUpdateOneRequiredWithoutContestUploadNestedInput = {
    create?: XOR<UserPhotoCreateWithoutContestUploadInput, UserPhotoUncheckedCreateWithoutContestUploadInput>
    connectOrCreate?: UserPhotoCreateOrConnectWithoutContestUploadInput
    upsert?: UserPhotoUpsertWithoutContestUploadInput
    connect?: UserPhotoWhereUniqueInput
    update?: XOR<XOR<UserPhotoUpdateToOneWithWhereWithoutContestUploadInput, UserPhotoUpdateWithoutContestUploadInput>, UserPhotoUncheckedUpdateWithoutContestUploadInput>
  }

  export type CommentUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<CommentCreateWithoutReceiverInput, CommentUncheckedCreateWithoutReceiverInput> | CommentCreateWithoutReceiverInput[] | CommentUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutReceiverInput | CommentCreateOrConnectWithoutReceiverInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutReceiverInput | CommentUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: CommentCreateManyReceiverInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutReceiverInput | CommentUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutReceiverInput | CommentUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ContestAchievementUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<ContestAchievementCreateWithoutPhotoInput, ContestAchievementUncheckedCreateWithoutPhotoInput> | ContestAchievementCreateWithoutPhotoInput[] | ContestAchievementUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestAchievementCreateOrConnectWithoutPhotoInput | ContestAchievementCreateOrConnectWithoutPhotoInput[]
    upsert?: ContestAchievementUpsertWithWhereUniqueWithoutPhotoInput | ContestAchievementUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: ContestAchievementCreateManyPhotoInputEnvelope
    set?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    disconnect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    delete?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    connect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    update?: ContestAchievementUpdateWithWhereUniqueWithoutPhotoInput | ContestAchievementUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: ContestAchievementUpdateManyWithWhereWithoutPhotoInput | ContestAchievementUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: ContestAchievementScalarWhereInput | ContestAchievementScalarWhereInput[]
  }

  export type ContestWinnerUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<ContestWinnerCreateWithoutPhotoInput, ContestWinnerUncheckedCreateWithoutPhotoInput> | ContestWinnerCreateWithoutPhotoInput[] | ContestWinnerUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestWinnerCreateOrConnectWithoutPhotoInput | ContestWinnerCreateOrConnectWithoutPhotoInput[]
    upsert?: ContestWinnerUpsertWithWhereUniqueWithoutPhotoInput | ContestWinnerUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: ContestWinnerCreateManyPhotoInputEnvelope
    set?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    disconnect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    delete?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    connect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    update?: ContestWinnerUpdateWithWhereUniqueWithoutPhotoInput | ContestWinnerUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: ContestWinnerUpdateManyWithWhereWithoutPhotoInput | ContestWinnerUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: ContestWinnerScalarWhereInput | ContestWinnerScalarWhereInput[]
  }

  export type VoteUncheckedUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<VoteCreateWithoutPhotoInput, VoteUncheckedCreateWithoutPhotoInput> | VoteCreateWithoutPhotoInput[] | VoteUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutPhotoInput | VoteCreateOrConnectWithoutPhotoInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutPhotoInput | VoteUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: VoteCreateManyPhotoInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutPhotoInput | VoteUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutPhotoInput | VoteUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<CommentCreateWithoutReceiverInput, CommentUncheckedCreateWithoutReceiverInput> | CommentCreateWithoutReceiverInput[] | CommentUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutReceiverInput | CommentCreateOrConnectWithoutReceiverInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutReceiverInput | CommentUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: CommentCreateManyReceiverInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutReceiverInput | CommentUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutReceiverInput | CommentUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ContestAchievementUncheckedUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<ContestAchievementCreateWithoutPhotoInput, ContestAchievementUncheckedCreateWithoutPhotoInput> | ContestAchievementCreateWithoutPhotoInput[] | ContestAchievementUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestAchievementCreateOrConnectWithoutPhotoInput | ContestAchievementCreateOrConnectWithoutPhotoInput[]
    upsert?: ContestAchievementUpsertWithWhereUniqueWithoutPhotoInput | ContestAchievementUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: ContestAchievementCreateManyPhotoInputEnvelope
    set?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    disconnect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    delete?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    connect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    update?: ContestAchievementUpdateWithWhereUniqueWithoutPhotoInput | ContestAchievementUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: ContestAchievementUpdateManyWithWhereWithoutPhotoInput | ContestAchievementUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: ContestAchievementScalarWhereInput | ContestAchievementScalarWhereInput[]
  }

  export type ContestWinnerUncheckedUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<ContestWinnerCreateWithoutPhotoInput, ContestWinnerUncheckedCreateWithoutPhotoInput> | ContestWinnerCreateWithoutPhotoInput[] | ContestWinnerUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestWinnerCreateOrConnectWithoutPhotoInput | ContestWinnerCreateOrConnectWithoutPhotoInput[]
    upsert?: ContestWinnerUpsertWithWhereUniqueWithoutPhotoInput | ContestWinnerUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: ContestWinnerCreateManyPhotoInputEnvelope
    set?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    disconnect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    delete?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    connect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    update?: ContestWinnerUpdateWithWhereUniqueWithoutPhotoInput | ContestWinnerUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: ContestWinnerUpdateManyWithWhereWithoutPhotoInput | ContestWinnerUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: ContestWinnerScalarWhereInput | ContestWinnerScalarWhereInput[]
  }

  export type ContestParticipantCreateNestedOneWithoutContestWinnerInput = {
    create?: XOR<ContestParticipantCreateWithoutContestWinnerInput, ContestParticipantUncheckedCreateWithoutContestWinnerInput>
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutContestWinnerInput
    connect?: ContestParticipantWhereUniqueInput
  }

  export type ContestPhotoCreateNestedOneWithoutContestWinnerInput = {
    create?: XOR<ContestPhotoCreateWithoutContestWinnerInput, ContestPhotoUncheckedCreateWithoutContestWinnerInput>
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutContestWinnerInput
    connect?: ContestPhotoWhereUniqueInput
  }

  export type ContestParticipantUpdateOneRequiredWithoutContestWinnerNestedInput = {
    create?: XOR<ContestParticipantCreateWithoutContestWinnerInput, ContestParticipantUncheckedCreateWithoutContestWinnerInput>
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutContestWinnerInput
    upsert?: ContestParticipantUpsertWithoutContestWinnerInput
    connect?: ContestParticipantWhereUniqueInput
    update?: XOR<XOR<ContestParticipantUpdateToOneWithWhereWithoutContestWinnerInput, ContestParticipantUpdateWithoutContestWinnerInput>, ContestParticipantUncheckedUpdateWithoutContestWinnerInput>
  }

  export type ContestPhotoUpdateOneRequiredWithoutContestWinnerNestedInput = {
    create?: XOR<ContestPhotoCreateWithoutContestWinnerInput, ContestPhotoUncheckedCreateWithoutContestWinnerInput>
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutContestWinnerInput
    upsert?: ContestPhotoUpsertWithoutContestWinnerInput
    connect?: ContestPhotoWhereUniqueInput
    update?: XOR<XOR<ContestPhotoUpdateToOneWithWhereWithoutContestWinnerInput, ContestPhotoUpdateWithoutContestWinnerInput>, ContestPhotoUncheckedUpdateWithoutContestWinnerInput>
  }

  export type ContestCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<ContestCreateWithoutParticipantsInput, ContestUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ContestCreateOrConnectWithoutParticipantsInput
    connect?: ContestWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutContestParticipantInput = {
    create?: XOR<UserCreateWithoutContestParticipantInput, UserUncheckedCreateWithoutContestParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutContestParticipantInput
    connect?: UserWhereUniqueInput
  }

  export type TeamMemberCreateNestedOneWithoutContestParticipantInput = {
    create?: XOR<TeamMemberCreateWithoutContestParticipantInput, TeamMemberUncheckedCreateWithoutContestParticipantInput>
    connectOrCreate?: TeamMemberCreateOrConnectWithoutContestParticipantInput
    connect?: TeamMemberWhereUniqueInput
  }

  export type ContestPhotoCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ContestPhotoCreateWithoutParticipantInput, ContestPhotoUncheckedCreateWithoutParticipantInput> | ContestPhotoCreateWithoutParticipantInput[] | ContestPhotoUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutParticipantInput | ContestPhotoCreateOrConnectWithoutParticipantInput[]
    createMany?: ContestPhotoCreateManyParticipantInputEnvelope
    connect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
  }

  export type ContestWinnerCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ContestWinnerCreateWithoutParticipantInput, ContestWinnerUncheckedCreateWithoutParticipantInput> | ContestWinnerCreateWithoutParticipantInput[] | ContestWinnerUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestWinnerCreateOrConnectWithoutParticipantInput | ContestWinnerCreateOrConnectWithoutParticipantInput[]
    createMany?: ContestWinnerCreateManyParticipantInputEnvelope
    connect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
  }

  export type ContestAchievementCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ContestAchievementCreateWithoutParticipantInput, ContestAchievementUncheckedCreateWithoutParticipantInput> | ContestAchievementCreateWithoutParticipantInput[] | ContestAchievementUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestAchievementCreateOrConnectWithoutParticipantInput | ContestAchievementCreateOrConnectWithoutParticipantInput[]
    createMany?: ContestAchievementCreateManyParticipantInputEnvelope
    connect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
  }

  export type ContestPhotoUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ContestPhotoCreateWithoutParticipantInput, ContestPhotoUncheckedCreateWithoutParticipantInput> | ContestPhotoCreateWithoutParticipantInput[] | ContestPhotoUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutParticipantInput | ContestPhotoCreateOrConnectWithoutParticipantInput[]
    createMany?: ContestPhotoCreateManyParticipantInputEnvelope
    connect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
  }

  export type ContestWinnerUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ContestWinnerCreateWithoutParticipantInput, ContestWinnerUncheckedCreateWithoutParticipantInput> | ContestWinnerCreateWithoutParticipantInput[] | ContestWinnerUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestWinnerCreateOrConnectWithoutParticipantInput | ContestWinnerCreateOrConnectWithoutParticipantInput[]
    createMany?: ContestWinnerCreateManyParticipantInputEnvelope
    connect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
  }

  export type ContestAchievementUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ContestAchievementCreateWithoutParticipantInput, ContestAchievementUncheckedCreateWithoutParticipantInput> | ContestAchievementCreateWithoutParticipantInput[] | ContestAchievementUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestAchievementCreateOrConnectWithoutParticipantInput | ContestAchievementCreateOrConnectWithoutParticipantInput[]
    createMany?: ContestAchievementCreateManyParticipantInputEnvelope
    connect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
  }

  export type EnumContestParticipantStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContestParticipantStatus
  }

  export type EnumYCLevelFieldUpdateOperationsInput = {
    set?: $Enums.YCLevel
  }

  export type ContestUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<ContestCreateWithoutParticipantsInput, ContestUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ContestCreateOrConnectWithoutParticipantsInput
    upsert?: ContestUpsertWithoutParticipantsInput
    connect?: ContestWhereUniqueInput
    update?: XOR<XOR<ContestUpdateToOneWithWhereWithoutParticipantsInput, ContestUpdateWithoutParticipantsInput>, ContestUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutContestParticipantNestedInput = {
    create?: XOR<UserCreateWithoutContestParticipantInput, UserUncheckedCreateWithoutContestParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutContestParticipantInput
    upsert?: UserUpsertWithoutContestParticipantInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContestParticipantInput, UserUpdateWithoutContestParticipantInput>, UserUncheckedUpdateWithoutContestParticipantInput>
  }

  export type TeamMemberUpdateOneWithoutContestParticipantNestedInput = {
    create?: XOR<TeamMemberCreateWithoutContestParticipantInput, TeamMemberUncheckedCreateWithoutContestParticipantInput>
    connectOrCreate?: TeamMemberCreateOrConnectWithoutContestParticipantInput
    upsert?: TeamMemberUpsertWithoutContestParticipantInput
    disconnect?: boolean
    delete?: TeamMemberWhereInput | boolean
    connect?: TeamMemberWhereUniqueInput
    update?: XOR<XOR<TeamMemberUpdateToOneWithWhereWithoutContestParticipantInput, TeamMemberUpdateWithoutContestParticipantInput>, TeamMemberUncheckedUpdateWithoutContestParticipantInput>
  }

  export type ContestPhotoUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ContestPhotoCreateWithoutParticipantInput, ContestPhotoUncheckedCreateWithoutParticipantInput> | ContestPhotoCreateWithoutParticipantInput[] | ContestPhotoUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutParticipantInput | ContestPhotoCreateOrConnectWithoutParticipantInput[]
    upsert?: ContestPhotoUpsertWithWhereUniqueWithoutParticipantInput | ContestPhotoUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ContestPhotoCreateManyParticipantInputEnvelope
    set?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    disconnect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    delete?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    connect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    update?: ContestPhotoUpdateWithWhereUniqueWithoutParticipantInput | ContestPhotoUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ContestPhotoUpdateManyWithWhereWithoutParticipantInput | ContestPhotoUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ContestPhotoScalarWhereInput | ContestPhotoScalarWhereInput[]
  }

  export type ContestWinnerUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ContestWinnerCreateWithoutParticipantInput, ContestWinnerUncheckedCreateWithoutParticipantInput> | ContestWinnerCreateWithoutParticipantInput[] | ContestWinnerUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestWinnerCreateOrConnectWithoutParticipantInput | ContestWinnerCreateOrConnectWithoutParticipantInput[]
    upsert?: ContestWinnerUpsertWithWhereUniqueWithoutParticipantInput | ContestWinnerUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ContestWinnerCreateManyParticipantInputEnvelope
    set?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    disconnect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    delete?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    connect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    update?: ContestWinnerUpdateWithWhereUniqueWithoutParticipantInput | ContestWinnerUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ContestWinnerUpdateManyWithWhereWithoutParticipantInput | ContestWinnerUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ContestWinnerScalarWhereInput | ContestWinnerScalarWhereInput[]
  }

  export type ContestAchievementUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ContestAchievementCreateWithoutParticipantInput, ContestAchievementUncheckedCreateWithoutParticipantInput> | ContestAchievementCreateWithoutParticipantInput[] | ContestAchievementUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestAchievementCreateOrConnectWithoutParticipantInput | ContestAchievementCreateOrConnectWithoutParticipantInput[]
    upsert?: ContestAchievementUpsertWithWhereUniqueWithoutParticipantInput | ContestAchievementUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ContestAchievementCreateManyParticipantInputEnvelope
    set?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    disconnect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    delete?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    connect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    update?: ContestAchievementUpdateWithWhereUniqueWithoutParticipantInput | ContestAchievementUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ContestAchievementUpdateManyWithWhereWithoutParticipantInput | ContestAchievementUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ContestAchievementScalarWhereInput | ContestAchievementScalarWhereInput[]
  }

  export type ContestPhotoUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ContestPhotoCreateWithoutParticipantInput, ContestPhotoUncheckedCreateWithoutParticipantInput> | ContestPhotoCreateWithoutParticipantInput[] | ContestPhotoUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutParticipantInput | ContestPhotoCreateOrConnectWithoutParticipantInput[]
    upsert?: ContestPhotoUpsertWithWhereUniqueWithoutParticipantInput | ContestPhotoUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ContestPhotoCreateManyParticipantInputEnvelope
    set?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    disconnect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    delete?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    connect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    update?: ContestPhotoUpdateWithWhereUniqueWithoutParticipantInput | ContestPhotoUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ContestPhotoUpdateManyWithWhereWithoutParticipantInput | ContestPhotoUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ContestPhotoScalarWhereInput | ContestPhotoScalarWhereInput[]
  }

  export type ContestWinnerUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ContestWinnerCreateWithoutParticipantInput, ContestWinnerUncheckedCreateWithoutParticipantInput> | ContestWinnerCreateWithoutParticipantInput[] | ContestWinnerUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestWinnerCreateOrConnectWithoutParticipantInput | ContestWinnerCreateOrConnectWithoutParticipantInput[]
    upsert?: ContestWinnerUpsertWithWhereUniqueWithoutParticipantInput | ContestWinnerUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ContestWinnerCreateManyParticipantInputEnvelope
    set?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    disconnect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    delete?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    connect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    update?: ContestWinnerUpdateWithWhereUniqueWithoutParticipantInput | ContestWinnerUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ContestWinnerUpdateManyWithWhereWithoutParticipantInput | ContestWinnerUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ContestWinnerScalarWhereInput | ContestWinnerScalarWhereInput[]
  }

  export type ContestAchievementUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ContestAchievementCreateWithoutParticipantInput, ContestAchievementUncheckedCreateWithoutParticipantInput> | ContestAchievementCreateWithoutParticipantInput[] | ContestAchievementUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestAchievementCreateOrConnectWithoutParticipantInput | ContestAchievementCreateOrConnectWithoutParticipantInput[]
    upsert?: ContestAchievementUpsertWithWhereUniqueWithoutParticipantInput | ContestAchievementUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ContestAchievementCreateManyParticipantInputEnvelope
    set?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    disconnect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    delete?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    connect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    update?: ContestAchievementUpdateWithWhereUniqueWithoutParticipantInput | ContestAchievementUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ContestAchievementUpdateManyWithWhereWithoutParticipantInput | ContestAchievementUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ContestAchievementScalarWhereInput | ContestAchievementScalarWhereInput[]
  }

  export type ContestCreateNestedOneWithoutContestPrizesInput = {
    create?: XOR<ContestCreateWithoutContestPrizesInput, ContestUncheckedCreateWithoutContestPrizesInput>
    connectOrCreate?: ContestCreateOrConnectWithoutContestPrizesInput
    connect?: ContestWhereUniqueInput
  }

  export type EnumPrizeTypeFieldUpdateOperationsInput = {
    set?: $Enums.PrizeType
  }

  export type ContestUpdateOneRequiredWithoutContestPrizesNestedInput = {
    create?: XOR<ContestCreateWithoutContestPrizesInput, ContestUncheckedCreateWithoutContestPrizesInput>
    connectOrCreate?: ContestCreateOrConnectWithoutContestPrizesInput
    upsert?: ContestUpsertWithoutContestPrizesInput
    connect?: ContestWhereUniqueInput
    update?: XOR<XOR<ContestUpdateToOneWithWhereWithoutContestPrizesInput, ContestUpdateWithoutContestPrizesInput>, ContestUncheckedUpdateWithoutContestPrizesInput>
  }

  export type ContestPhotoCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<ContestPhotoCreateWithoutAchievementsInput, ContestPhotoUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutAchievementsInput
    connect?: ContestPhotoWhereUniqueInput
  }

  export type ContestCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<ContestCreateWithoutAchievementsInput, ContestUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: ContestCreateOrConnectWithoutAchievementsInput
    connect?: ContestWhereUniqueInput
  }

  export type ContestParticipantCreateNestedOneWithoutContestAchievementInput = {
    create?: XOR<ContestParticipantCreateWithoutContestAchievementInput, ContestParticipantUncheckedCreateWithoutContestAchievementInput>
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutContestAchievementInput
    connect?: ContestParticipantWhereUniqueInput
  }

  export type ContestPhotoUpdateOneWithoutAchievementsNestedInput = {
    create?: XOR<ContestPhotoCreateWithoutAchievementsInput, ContestPhotoUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutAchievementsInput
    upsert?: ContestPhotoUpsertWithoutAchievementsInput
    disconnect?: boolean
    delete?: ContestPhotoWhereInput | boolean
    connect?: ContestPhotoWhereUniqueInput
    update?: XOR<XOR<ContestPhotoUpdateToOneWithWhereWithoutAchievementsInput, ContestPhotoUpdateWithoutAchievementsInput>, ContestPhotoUncheckedUpdateWithoutAchievementsInput>
  }

  export type ContestUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<ContestCreateWithoutAchievementsInput, ContestUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: ContestCreateOrConnectWithoutAchievementsInput
    upsert?: ContestUpsertWithoutAchievementsInput
    connect?: ContestWhereUniqueInput
    update?: XOR<XOR<ContestUpdateToOneWithWhereWithoutAchievementsInput, ContestUpdateWithoutAchievementsInput>, ContestUncheckedUpdateWithoutAchievementsInput>
  }

  export type ContestParticipantUpdateOneWithoutContestAchievementNestedInput = {
    create?: XOR<ContestParticipantCreateWithoutContestAchievementInput, ContestParticipantUncheckedCreateWithoutContestAchievementInput>
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutContestAchievementInput
    upsert?: ContestParticipantUpsertWithoutContestAchievementInput
    disconnect?: boolean
    delete?: ContestParticipantWhereInput | boolean
    connect?: ContestParticipantWhereUniqueInput
    update?: XOR<XOR<ContestParticipantUpdateToOneWithWhereWithoutContestAchievementInput, ContestParticipantUpdateWithoutContestAchievementInput>, ContestParticipantUncheckedUpdateWithoutContestAchievementInput>
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumSitePolicyTypeFieldUpdateOperationsInput = {
    set?: $Enums.SitePolicyType
  }

  export type TeamCreateNestedOneWithoutChatInput = {
    create?: XOR<TeamCreateWithoutChatInput, TeamUncheckedCreateWithoutChatInput>
    connectOrCreate?: TeamCreateOrConnectWithoutChatInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChatInput = {
    create?: XOR<UserCreateWithoutChatInput, UserUncheckedCreateWithoutChatInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatInput
    connect?: UserWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutChatNestedInput = {
    create?: XOR<TeamCreateWithoutChatInput, TeamUncheckedCreateWithoutChatInput>
    connectOrCreate?: TeamCreateOrConnectWithoutChatInput
    upsert?: TeamUpsertWithoutChatInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutChatInput, TeamUpdateWithoutChatInput>, TeamUncheckedUpdateWithoutChatInput>
  }

  export type UserUpdateOneRequiredWithoutChatNestedInput = {
    create?: XOR<UserCreateWithoutChatInput, UserUncheckedCreateWithoutChatInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatInput
    upsert?: UserUpsertWithoutChatInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatInput, UserUpdateWithoutChatInput>, UserUncheckedUpdateWithoutChatInput>
  }

  export type EnumProductTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProductType
  }

  export type UserCreateNestedOneWithoutCreatedTeamInput = {
    create?: XOR<UserCreateWithoutCreatedTeamInput, UserUncheckedCreateWithoutCreatedTeamInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTeamInput
    connect?: UserWhereUniqueInput
  }

  export type TeamMemberCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutTeamInput = {
    create?: XOR<ChatCreateWithoutTeamInput, ChatUncheckedCreateWithoutTeamInput> | ChatCreateWithoutTeamInput[] | ChatUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutTeamInput | ChatCreateOrConnectWithoutTeamInput[]
    createMany?: ChatCreateManyTeamInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type TeamParticipationCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamParticipationCreateWithoutTeamInput, TeamParticipationUncheckedCreateWithoutTeamInput> | TeamParticipationCreateWithoutTeamInput[] | TeamParticipationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamParticipationCreateOrConnectWithoutTeamInput | TeamParticipationCreateOrConnectWithoutTeamInput[]
    createMany?: TeamParticipationCreateManyTeamInputEnvelope
    connect?: TeamParticipationWhereUniqueInput | TeamParticipationWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<ChatCreateWithoutTeamInput, ChatUncheckedCreateWithoutTeamInput> | ChatCreateWithoutTeamInput[] | ChatUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutTeamInput | ChatCreateOrConnectWithoutTeamInput[]
    createMany?: ChatCreateManyTeamInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type TeamParticipationUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamParticipationCreateWithoutTeamInput, TeamParticipationUncheckedCreateWithoutTeamInput> | TeamParticipationCreateWithoutTeamInput[] | TeamParticipationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamParticipationCreateOrConnectWithoutTeamInput | TeamParticipationCreateOrConnectWithoutTeamInput[]
    createMany?: TeamParticipationCreateManyTeamInputEnvelope
    connect?: TeamParticipationWhereUniqueInput | TeamParticipationWhereUniqueInput[]
  }

  export type EnumTeamAccessibilityFieldUpdateOperationsInput = {
    set?: $Enums.TeamAccessibility
  }

  export type UserUpdateOneRequiredWithoutCreatedTeamNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTeamInput, UserUncheckedCreateWithoutCreatedTeamInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTeamInput
    upsert?: UserUpsertWithoutCreatedTeamInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTeamInput, UserUpdateWithoutCreatedTeamInput>, UserUncheckedUpdateWithoutCreatedTeamInput>
  }

  export type TeamMemberUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ChatCreateWithoutTeamInput, ChatUncheckedCreateWithoutTeamInput> | ChatCreateWithoutTeamInput[] | ChatUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutTeamInput | ChatCreateOrConnectWithoutTeamInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutTeamInput | ChatUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ChatCreateManyTeamInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutTeamInput | ChatUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutTeamInput | ChatUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type TeamParticipationUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamParticipationCreateWithoutTeamInput, TeamParticipationUncheckedCreateWithoutTeamInput> | TeamParticipationCreateWithoutTeamInput[] | TeamParticipationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamParticipationCreateOrConnectWithoutTeamInput | TeamParticipationCreateOrConnectWithoutTeamInput[]
    upsert?: TeamParticipationUpsertWithWhereUniqueWithoutTeamInput | TeamParticipationUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamParticipationCreateManyTeamInputEnvelope
    set?: TeamParticipationWhereUniqueInput | TeamParticipationWhereUniqueInput[]
    disconnect?: TeamParticipationWhereUniqueInput | TeamParticipationWhereUniqueInput[]
    delete?: TeamParticipationWhereUniqueInput | TeamParticipationWhereUniqueInput[]
    connect?: TeamParticipationWhereUniqueInput | TeamParticipationWhereUniqueInput[]
    update?: TeamParticipationUpdateWithWhereUniqueWithoutTeamInput | TeamParticipationUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamParticipationUpdateManyWithWhereWithoutTeamInput | TeamParticipationUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamParticipationScalarWhereInput | TeamParticipationScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ChatCreateWithoutTeamInput, ChatUncheckedCreateWithoutTeamInput> | ChatCreateWithoutTeamInput[] | ChatUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutTeamInput | ChatCreateOrConnectWithoutTeamInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutTeamInput | ChatUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ChatCreateManyTeamInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutTeamInput | ChatUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutTeamInput | ChatUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type TeamParticipationUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamParticipationCreateWithoutTeamInput, TeamParticipationUncheckedCreateWithoutTeamInput> | TeamParticipationCreateWithoutTeamInput[] | TeamParticipationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamParticipationCreateOrConnectWithoutTeamInput | TeamParticipationCreateOrConnectWithoutTeamInput[]
    upsert?: TeamParticipationUpsertWithWhereUniqueWithoutTeamInput | TeamParticipationUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamParticipationCreateManyTeamInputEnvelope
    set?: TeamParticipationWhereUniqueInput | TeamParticipationWhereUniqueInput[]
    disconnect?: TeamParticipationWhereUniqueInput | TeamParticipationWhereUniqueInput[]
    delete?: TeamParticipationWhereUniqueInput | TeamParticipationWhereUniqueInput[]
    connect?: TeamParticipationWhereUniqueInput | TeamParticipationWhereUniqueInput[]
    update?: TeamParticipationUpdateWithWhereUniqueWithoutTeamInput | TeamParticipationUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamParticipationUpdateManyWithWhereWithoutTeamInput | TeamParticipationUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamParticipationScalarWhereInput | TeamParticipationScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutJoinedTeamInput = {
    create?: XOR<UserCreateWithoutJoinedTeamInput, UserUncheckedCreateWithoutJoinedTeamInput>
    connectOrCreate?: UserCreateOrConnectWithoutJoinedTeamInput
    connect?: UserWhereUniqueInput
  }

  export type ContestParticipantCreateNestedManyWithoutMemberInput = {
    create?: XOR<ContestParticipantCreateWithoutMemberInput, ContestParticipantUncheckedCreateWithoutMemberInput> | ContestParticipantCreateWithoutMemberInput[] | ContestParticipantUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutMemberInput | ContestParticipantCreateOrConnectWithoutMemberInput[]
    createMany?: ContestParticipantCreateManyMemberInputEnvelope
    connect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
  }

  export type ContestParticipantUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<ContestParticipantCreateWithoutMemberInput, ContestParticipantUncheckedCreateWithoutMemberInput> | ContestParticipantCreateWithoutMemberInput[] | ContestParticipantUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutMemberInput | ContestParticipantCreateOrConnectWithoutMemberInput[]
    createMany?: ContestParticipantCreateManyMemberInputEnvelope
    connect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
  }

  export type EnumTeamMemberStatusFieldUpdateOperationsInput = {
    set?: $Enums.TeamMemberStatus
  }

  export type EnumMemberLevelFieldUpdateOperationsInput = {
    set?: $Enums.MemberLevel
  }

  export type TeamUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    upsert?: TeamUpsertWithoutMembersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMembersInput, TeamUpdateWithoutMembersInput>, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutJoinedTeamNestedInput = {
    create?: XOR<UserCreateWithoutJoinedTeamInput, UserUncheckedCreateWithoutJoinedTeamInput>
    connectOrCreate?: UserCreateOrConnectWithoutJoinedTeamInput
    upsert?: UserUpsertWithoutJoinedTeamInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJoinedTeamInput, UserUpdateWithoutJoinedTeamInput>, UserUncheckedUpdateWithoutJoinedTeamInput>
  }

  export type ContestParticipantUpdateManyWithoutMemberNestedInput = {
    create?: XOR<ContestParticipantCreateWithoutMemberInput, ContestParticipantUncheckedCreateWithoutMemberInput> | ContestParticipantCreateWithoutMemberInput[] | ContestParticipantUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutMemberInput | ContestParticipantCreateOrConnectWithoutMemberInput[]
    upsert?: ContestParticipantUpsertWithWhereUniqueWithoutMemberInput | ContestParticipantUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: ContestParticipantCreateManyMemberInputEnvelope
    set?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    disconnect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    delete?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    connect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    update?: ContestParticipantUpdateWithWhereUniqueWithoutMemberInput | ContestParticipantUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: ContestParticipantUpdateManyWithWhereWithoutMemberInput | ContestParticipantUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: ContestParticipantScalarWhereInput | ContestParticipantScalarWhereInput[]
  }

  export type ContestParticipantUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<ContestParticipantCreateWithoutMemberInput, ContestParticipantUncheckedCreateWithoutMemberInput> | ContestParticipantCreateWithoutMemberInput[] | ContestParticipantUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutMemberInput | ContestParticipantCreateOrConnectWithoutMemberInput[]
    upsert?: ContestParticipantUpsertWithWhereUniqueWithoutMemberInput | ContestParticipantUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: ContestParticipantCreateManyMemberInputEnvelope
    set?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    disconnect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    delete?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    connect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    update?: ContestParticipantUpdateWithWhereUniqueWithoutMemberInput | ContestParticipantUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: ContestParticipantUpdateManyWithWhereWithoutMemberInput | ContestParticipantUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: ContestParticipantScalarWhereInput | ContestParticipantScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutParticipationsInput = {
    create?: XOR<TeamCreateWithoutParticipationsInput, TeamUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutParticipationsInput
    connect?: TeamWhereUniqueInput
  }

  export type ContestCreateNestedOneWithoutTeamParticipationsInput = {
    create?: XOR<ContestCreateWithoutTeamParticipationsInput, ContestUncheckedCreateWithoutTeamParticipationsInput>
    connectOrCreate?: ContestCreateOrConnectWithoutTeamParticipationsInput
    connect?: ContestWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutParticipationsNestedInput = {
    create?: XOR<TeamCreateWithoutParticipationsInput, TeamUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutParticipationsInput
    upsert?: TeamUpsertWithoutParticipationsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutParticipationsInput, TeamUpdateWithoutParticipationsInput>, TeamUncheckedUpdateWithoutParticipationsInput>
  }

  export type ContestUpdateOneRequiredWithoutTeamParticipationsNestedInput = {
    create?: XOR<ContestCreateWithoutTeamParticipationsInput, ContestUncheckedCreateWithoutTeamParticipationsInput>
    connectOrCreate?: ContestCreateOrConnectWithoutTeamParticipationsInput
    upsert?: ContestUpsertWithoutTeamParticipationsInput
    connect?: ContestWhereUniqueInput
    update?: XOR<XOR<ContestUpdateToOneWithWhereWithoutTeamParticipationsInput, ContestUpdateWithoutTeamParticipationsInput>, ContestUncheckedUpdateWithoutTeamParticipationsInput>
  }

  export type OtpCreateNestedOneWithoutUserInput = {
    create?: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput>
    connectOrCreate?: OtpCreateOrConnectWithoutUserInput
    connect?: OtpWhereUniqueInput
  }

  export type UserStoreCreateNestedOneWithoutUserInput = {
    create?: XOR<UserStoreCreateWithoutUserInput, UserStoreUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStoreCreateOrConnectWithoutUserInput
    connect?: UserStoreWhereUniqueInput
  }

  export type TeamCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TeamCreateWithoutCreatorInput, TeamUncheckedCreateWithoutCreatorInput> | TeamCreateWithoutCreatorInput[] | TeamUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCreatorInput | TeamCreateOrConnectWithoutCreatorInput[]
    createMany?: TeamCreateManyCreatorInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type TeamMemberCreateNestedOneWithoutMemberInput = {
    create?: XOR<TeamMemberCreateWithoutMemberInput, TeamMemberUncheckedCreateWithoutMemberInput>
    connectOrCreate?: TeamMemberCreateOrConnectWithoutMemberInput
    connect?: TeamMemberWhereUniqueInput
  }

  export type ContestCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ContestCreateWithoutCreatorInput, ContestUncheckedCreateWithoutCreatorInput> | ContestCreateWithoutCreatorInput[] | ContestUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ContestCreateOrConnectWithoutCreatorInput | ContestCreateOrConnectWithoutCreatorInput[]
    createMany?: ContestCreateManyCreatorInputEnvelope
    connect?: ContestWhereUniqueInput | ContestWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutProviderInput = {
    create?: XOR<CommentCreateWithoutProviderInput, CommentUncheckedCreateWithoutProviderInput> | CommentCreateWithoutProviderInput[] | CommentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProviderInput | CommentCreateOrConnectWithoutProviderInput[]
    createMany?: CommentCreateManyProviderInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type VoteCreateNestedManyWithoutProviderInput = {
    create?: XOR<VoteCreateWithoutProviderInput, VoteUncheckedCreateWithoutProviderInput> | VoteCreateWithoutProviderInput[] | VoteUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutProviderInput | VoteCreateOrConnectWithoutProviderInput[]
    createMany?: VoteCreateManyProviderInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutProviderInput = {
    create?: XOR<LikeCreateWithoutProviderInput, LikeUncheckedCreateWithoutProviderInput> | LikeCreateWithoutProviderInput[] | LikeUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutProviderInput | LikeCreateOrConnectWithoutProviderInput[]
    createMany?: LikeCreateManyProviderInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type UserPhotoCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPhotoCreateWithoutUserInput, UserPhotoUncheckedCreateWithoutUserInput> | UserPhotoCreateWithoutUserInput[] | UserPhotoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPhotoCreateOrConnectWithoutUserInput | UserPhotoCreateOrConnectWithoutUserInput[]
    createMany?: UserPhotoCreateManyUserInputEnvelope
    connect?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
  }

  export type ContestParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<ContestParticipantCreateWithoutUserInput, ContestParticipantUncheckedCreateWithoutUserInput> | ContestParticipantCreateWithoutUserInput[] | ContestParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutUserInput | ContestParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ContestParticipantCreateManyUserInputEnvelope
    connect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatCreateWithoutSenderInput, ChatUncheckedCreateWithoutSenderInput> | ChatCreateWithoutSenderInput[] | ChatUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutSenderInput | ChatCreateOrConnectWithoutSenderInput[]
    createMany?: ChatCreateManySenderInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type OtpUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput>
    connectOrCreate?: OtpCreateOrConnectWithoutUserInput
    connect?: OtpWhereUniqueInput
  }

  export type UserStoreUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserStoreCreateWithoutUserInput, UserStoreUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStoreCreateOrConnectWithoutUserInput
    connect?: UserStoreWhereUniqueInput
  }

  export type TeamUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TeamCreateWithoutCreatorInput, TeamUncheckedCreateWithoutCreatorInput> | TeamCreateWithoutCreatorInput[] | TeamUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCreatorInput | TeamCreateOrConnectWithoutCreatorInput[]
    createMany?: TeamCreateManyCreatorInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedOneWithoutMemberInput = {
    create?: XOR<TeamMemberCreateWithoutMemberInput, TeamMemberUncheckedCreateWithoutMemberInput>
    connectOrCreate?: TeamMemberCreateOrConnectWithoutMemberInput
    connect?: TeamMemberWhereUniqueInput
  }

  export type ContestUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ContestCreateWithoutCreatorInput, ContestUncheckedCreateWithoutCreatorInput> | ContestCreateWithoutCreatorInput[] | ContestUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ContestCreateOrConnectWithoutCreatorInput | ContestCreateOrConnectWithoutCreatorInput[]
    createMany?: ContestCreateManyCreatorInputEnvelope
    connect?: ContestWhereUniqueInput | ContestWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<CommentCreateWithoutProviderInput, CommentUncheckedCreateWithoutProviderInput> | CommentCreateWithoutProviderInput[] | CommentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProviderInput | CommentCreateOrConnectWithoutProviderInput[]
    createMany?: CommentCreateManyProviderInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type VoteUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<VoteCreateWithoutProviderInput, VoteUncheckedCreateWithoutProviderInput> | VoteCreateWithoutProviderInput[] | VoteUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutProviderInput | VoteCreateOrConnectWithoutProviderInput[]
    createMany?: VoteCreateManyProviderInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<LikeCreateWithoutProviderInput, LikeUncheckedCreateWithoutProviderInput> | LikeCreateWithoutProviderInput[] | LikeUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutProviderInput | LikeCreateOrConnectWithoutProviderInput[]
    createMany?: LikeCreateManyProviderInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type UserPhotoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPhotoCreateWithoutUserInput, UserPhotoUncheckedCreateWithoutUserInput> | UserPhotoCreateWithoutUserInput[] | UserPhotoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPhotoCreateOrConnectWithoutUserInput | UserPhotoCreateOrConnectWithoutUserInput[]
    createMany?: UserPhotoCreateManyUserInputEnvelope
    connect?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
  }

  export type ContestParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContestParticipantCreateWithoutUserInput, ContestParticipantUncheckedCreateWithoutUserInput> | ContestParticipantCreateWithoutUserInput[] | ContestParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutUserInput | ContestParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ContestParticipantCreateManyUserInputEnvelope
    connect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatCreateWithoutSenderInput, ChatUncheckedCreateWithoutSenderInput> | ChatCreateWithoutSenderInput[] | ChatUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutSenderInput | ChatCreateOrConnectWithoutSenderInput[]
    createMany?: ChatCreateManySenderInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type OtpUpdateOneWithoutUserNestedInput = {
    create?: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput>
    connectOrCreate?: OtpCreateOrConnectWithoutUserInput
    upsert?: OtpUpsertWithoutUserInput
    disconnect?: OtpWhereInput | boolean
    delete?: OtpWhereInput | boolean
    connect?: OtpWhereUniqueInput
    update?: XOR<XOR<OtpUpdateToOneWithWhereWithoutUserInput, OtpUpdateWithoutUserInput>, OtpUncheckedUpdateWithoutUserInput>
  }

  export type UserStoreUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserStoreCreateWithoutUserInput, UserStoreUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStoreCreateOrConnectWithoutUserInput
    upsert?: UserStoreUpsertWithoutUserInput
    disconnect?: UserStoreWhereInput | boolean
    delete?: UserStoreWhereInput | boolean
    connect?: UserStoreWhereUniqueInput
    update?: XOR<XOR<UserStoreUpdateToOneWithWhereWithoutUserInput, UserStoreUpdateWithoutUserInput>, UserStoreUncheckedUpdateWithoutUserInput>
  }

  export type TeamUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TeamCreateWithoutCreatorInput, TeamUncheckedCreateWithoutCreatorInput> | TeamCreateWithoutCreatorInput[] | TeamUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCreatorInput | TeamCreateOrConnectWithoutCreatorInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutCreatorInput | TeamUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TeamCreateManyCreatorInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutCreatorInput | TeamUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutCreatorInput | TeamUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type TeamMemberUpdateOneWithoutMemberNestedInput = {
    create?: XOR<TeamMemberCreateWithoutMemberInput, TeamMemberUncheckedCreateWithoutMemberInput>
    connectOrCreate?: TeamMemberCreateOrConnectWithoutMemberInput
    upsert?: TeamMemberUpsertWithoutMemberInput
    disconnect?: TeamMemberWhereInput | boolean
    delete?: TeamMemberWhereInput | boolean
    connect?: TeamMemberWhereUniqueInput
    update?: XOR<XOR<TeamMemberUpdateToOneWithWhereWithoutMemberInput, TeamMemberUpdateWithoutMemberInput>, TeamMemberUncheckedUpdateWithoutMemberInput>
  }

  export type ContestUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ContestCreateWithoutCreatorInput, ContestUncheckedCreateWithoutCreatorInput> | ContestCreateWithoutCreatorInput[] | ContestUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ContestCreateOrConnectWithoutCreatorInput | ContestCreateOrConnectWithoutCreatorInput[]
    upsert?: ContestUpsertWithWhereUniqueWithoutCreatorInput | ContestUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ContestCreateManyCreatorInputEnvelope
    set?: ContestWhereUniqueInput | ContestWhereUniqueInput[]
    disconnect?: ContestWhereUniqueInput | ContestWhereUniqueInput[]
    delete?: ContestWhereUniqueInput | ContestWhereUniqueInput[]
    connect?: ContestWhereUniqueInput | ContestWhereUniqueInput[]
    update?: ContestUpdateWithWhereUniqueWithoutCreatorInput | ContestUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ContestUpdateManyWithWhereWithoutCreatorInput | ContestUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ContestScalarWhereInput | ContestScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutProviderNestedInput = {
    create?: XOR<CommentCreateWithoutProviderInput, CommentUncheckedCreateWithoutProviderInput> | CommentCreateWithoutProviderInput[] | CommentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProviderInput | CommentCreateOrConnectWithoutProviderInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutProviderInput | CommentUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: CommentCreateManyProviderInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutProviderInput | CommentUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutProviderInput | CommentUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type VoteUpdateManyWithoutProviderNestedInput = {
    create?: XOR<VoteCreateWithoutProviderInput, VoteUncheckedCreateWithoutProviderInput> | VoteCreateWithoutProviderInput[] | VoteUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutProviderInput | VoteCreateOrConnectWithoutProviderInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutProviderInput | VoteUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: VoteCreateManyProviderInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutProviderInput | VoteUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutProviderInput | VoteUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutProviderNestedInput = {
    create?: XOR<LikeCreateWithoutProviderInput, LikeUncheckedCreateWithoutProviderInput> | LikeCreateWithoutProviderInput[] | LikeUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutProviderInput | LikeCreateOrConnectWithoutProviderInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutProviderInput | LikeUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: LikeCreateManyProviderInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutProviderInput | LikeUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutProviderInput | LikeUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type UserPhotoUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPhotoCreateWithoutUserInput, UserPhotoUncheckedCreateWithoutUserInput> | UserPhotoCreateWithoutUserInput[] | UserPhotoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPhotoCreateOrConnectWithoutUserInput | UserPhotoCreateOrConnectWithoutUserInput[]
    upsert?: UserPhotoUpsertWithWhereUniqueWithoutUserInput | UserPhotoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPhotoCreateManyUserInputEnvelope
    set?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    disconnect?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    delete?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    connect?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    update?: UserPhotoUpdateWithWhereUniqueWithoutUserInput | UserPhotoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPhotoUpdateManyWithWhereWithoutUserInput | UserPhotoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPhotoScalarWhereInput | UserPhotoScalarWhereInput[]
  }

  export type ContestParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContestParticipantCreateWithoutUserInput, ContestParticipantUncheckedCreateWithoutUserInput> | ContestParticipantCreateWithoutUserInput[] | ContestParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutUserInput | ContestParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ContestParticipantUpsertWithWhereUniqueWithoutUserInput | ContestParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContestParticipantCreateManyUserInputEnvelope
    set?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    disconnect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    delete?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    connect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    update?: ContestParticipantUpdateWithWhereUniqueWithoutUserInput | ContestParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContestParticipantUpdateManyWithWhereWithoutUserInput | ContestParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContestParticipantScalarWhereInput | ContestParticipantScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatCreateWithoutSenderInput, ChatUncheckedCreateWithoutSenderInput> | ChatCreateWithoutSenderInput[] | ChatUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutSenderInput | ChatCreateOrConnectWithoutSenderInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutSenderInput | ChatUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatCreateManySenderInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutSenderInput | ChatUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutSenderInput | ChatUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type OtpUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput>
    connectOrCreate?: OtpCreateOrConnectWithoutUserInput
    upsert?: OtpUpsertWithoutUserInput
    disconnect?: OtpWhereInput | boolean
    delete?: OtpWhereInput | boolean
    connect?: OtpWhereUniqueInput
    update?: XOR<XOR<OtpUpdateToOneWithWhereWithoutUserInput, OtpUpdateWithoutUserInput>, OtpUncheckedUpdateWithoutUserInput>
  }

  export type UserStoreUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserStoreCreateWithoutUserInput, UserStoreUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStoreCreateOrConnectWithoutUserInput
    upsert?: UserStoreUpsertWithoutUserInput
    disconnect?: UserStoreWhereInput | boolean
    delete?: UserStoreWhereInput | boolean
    connect?: UserStoreWhereUniqueInput
    update?: XOR<XOR<UserStoreUpdateToOneWithWhereWithoutUserInput, UserStoreUpdateWithoutUserInput>, UserStoreUncheckedUpdateWithoutUserInput>
  }

  export type TeamUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TeamCreateWithoutCreatorInput, TeamUncheckedCreateWithoutCreatorInput> | TeamCreateWithoutCreatorInput[] | TeamUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCreatorInput | TeamCreateOrConnectWithoutCreatorInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutCreatorInput | TeamUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TeamCreateManyCreatorInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutCreatorInput | TeamUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutCreatorInput | TeamUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateOneWithoutMemberNestedInput = {
    create?: XOR<TeamMemberCreateWithoutMemberInput, TeamMemberUncheckedCreateWithoutMemberInput>
    connectOrCreate?: TeamMemberCreateOrConnectWithoutMemberInput
    upsert?: TeamMemberUpsertWithoutMemberInput
    disconnect?: TeamMemberWhereInput | boolean
    delete?: TeamMemberWhereInput | boolean
    connect?: TeamMemberWhereUniqueInput
    update?: XOR<XOR<TeamMemberUpdateToOneWithWhereWithoutMemberInput, TeamMemberUpdateWithoutMemberInput>, TeamMemberUncheckedUpdateWithoutMemberInput>
  }

  export type ContestUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ContestCreateWithoutCreatorInput, ContestUncheckedCreateWithoutCreatorInput> | ContestCreateWithoutCreatorInput[] | ContestUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ContestCreateOrConnectWithoutCreatorInput | ContestCreateOrConnectWithoutCreatorInput[]
    upsert?: ContestUpsertWithWhereUniqueWithoutCreatorInput | ContestUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ContestCreateManyCreatorInputEnvelope
    set?: ContestWhereUniqueInput | ContestWhereUniqueInput[]
    disconnect?: ContestWhereUniqueInput | ContestWhereUniqueInput[]
    delete?: ContestWhereUniqueInput | ContestWhereUniqueInput[]
    connect?: ContestWhereUniqueInput | ContestWhereUniqueInput[]
    update?: ContestUpdateWithWhereUniqueWithoutCreatorInput | ContestUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ContestUpdateManyWithWhereWithoutCreatorInput | ContestUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ContestScalarWhereInput | ContestScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<CommentCreateWithoutProviderInput, CommentUncheckedCreateWithoutProviderInput> | CommentCreateWithoutProviderInput[] | CommentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProviderInput | CommentCreateOrConnectWithoutProviderInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutProviderInput | CommentUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: CommentCreateManyProviderInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutProviderInput | CommentUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutProviderInput | CommentUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type VoteUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<VoteCreateWithoutProviderInput, VoteUncheckedCreateWithoutProviderInput> | VoteCreateWithoutProviderInput[] | VoteUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutProviderInput | VoteCreateOrConnectWithoutProviderInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutProviderInput | VoteUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: VoteCreateManyProviderInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutProviderInput | VoteUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutProviderInput | VoteUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<LikeCreateWithoutProviderInput, LikeUncheckedCreateWithoutProviderInput> | LikeCreateWithoutProviderInput[] | LikeUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutProviderInput | LikeCreateOrConnectWithoutProviderInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutProviderInput | LikeUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: LikeCreateManyProviderInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutProviderInput | LikeUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutProviderInput | LikeUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type UserPhotoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPhotoCreateWithoutUserInput, UserPhotoUncheckedCreateWithoutUserInput> | UserPhotoCreateWithoutUserInput[] | UserPhotoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPhotoCreateOrConnectWithoutUserInput | UserPhotoCreateOrConnectWithoutUserInput[]
    upsert?: UserPhotoUpsertWithWhereUniqueWithoutUserInput | UserPhotoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPhotoCreateManyUserInputEnvelope
    set?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    disconnect?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    delete?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    connect?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    update?: UserPhotoUpdateWithWhereUniqueWithoutUserInput | UserPhotoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPhotoUpdateManyWithWhereWithoutUserInput | UserPhotoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPhotoScalarWhereInput | UserPhotoScalarWhereInput[]
  }

  export type ContestParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContestParticipantCreateWithoutUserInput, ContestParticipantUncheckedCreateWithoutUserInput> | ContestParticipantCreateWithoutUserInput[] | ContestParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutUserInput | ContestParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ContestParticipantUpsertWithWhereUniqueWithoutUserInput | ContestParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContestParticipantCreateManyUserInputEnvelope
    set?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    disconnect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    delete?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    connect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    update?: ContestParticipantUpdateWithWhereUniqueWithoutUserInput | ContestParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContestParticipantUpdateManyWithWhereWithoutUserInput | ContestParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContestParticipantScalarWhereInput | ContestParticipantScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatCreateWithoutSenderInput, ChatUncheckedCreateWithoutSenderInput> | ChatCreateWithoutSenderInput[] | ChatUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutSenderInput | ChatCreateOrConnectWithoutSenderInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutSenderInput | ChatUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatCreateManySenderInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutSenderInput | ChatUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutSenderInput | ChatUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStoreInput = {
    create?: XOR<UserCreateWithoutStoreInput, UserUncheckedCreateWithoutStoreInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoreInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutStoreNestedInput = {
    create?: XOR<UserCreateWithoutStoreInput, UserUncheckedCreateWithoutStoreInput>
    connectOrCreate?: UserCreateOrConnectWithoutStoreInput
    upsert?: UserUpsertWithoutStoreInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStoreInput, UserUpdateWithoutStoreInput>, UserUncheckedUpdateWithoutStoreInput>
  }

  export type PhotoStatsNullableCreateEnvelopeInput = {
    set?: PhotoStatsCreateInput | null
  }

  export type PhotoStatsCreateInput = {
    Composition?: number
    Content?: number
    Creativity?: number
    Technique?: number
  }

  export type UserPhotoCreatelabelsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutUserPhotosInput = {
    create?: XOR<UserCreateWithoutUserPhotosInput, UserUncheckedCreateWithoutUserPhotosInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPhotosInput
    connect?: UserWhereUniqueInput
  }

  export type ContestPhotoCreateNestedManyWithoutPhotoInput = {
    create?: XOR<ContestPhotoCreateWithoutPhotoInput, ContestPhotoUncheckedCreateWithoutPhotoInput> | ContestPhotoCreateWithoutPhotoInput[] | ContestPhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutPhotoInput | ContestPhotoCreateOrConnectWithoutPhotoInput[]
    createMany?: ContestPhotoCreateManyPhotoInputEnvelope
    connect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutPhotoInput = {
    create?: XOR<LikeCreateWithoutPhotoInput, LikeUncheckedCreateWithoutPhotoInput> | LikeCreateWithoutPhotoInput[] | LikeUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPhotoInput | LikeCreateOrConnectWithoutPhotoInput[]
    createMany?: LikeCreateManyPhotoInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type ContestPhotoUncheckedCreateNestedManyWithoutPhotoInput = {
    create?: XOR<ContestPhotoCreateWithoutPhotoInput, ContestPhotoUncheckedCreateWithoutPhotoInput> | ContestPhotoCreateWithoutPhotoInput[] | ContestPhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutPhotoInput | ContestPhotoCreateOrConnectWithoutPhotoInput[]
    createMany?: ContestPhotoCreateManyPhotoInputEnvelope
    connect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutPhotoInput = {
    create?: XOR<LikeCreateWithoutPhotoInput, LikeUncheckedCreateWithoutPhotoInput> | LikeCreateWithoutPhotoInput[] | LikeUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPhotoInput | LikeCreateOrConnectWithoutPhotoInput[]
    createMany?: LikeCreateManyPhotoInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type PhotoStatsNullableUpdateEnvelopeInput = {
    set?: PhotoStatsCreateInput | null
    upsert?: PhotoStatsUpsertInput
    unset?: boolean
  }

  export type UserPhotoUpdatelabelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutUserPhotosNestedInput = {
    create?: XOR<UserCreateWithoutUserPhotosInput, UserUncheckedCreateWithoutUserPhotosInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPhotosInput
    upsert?: UserUpsertWithoutUserPhotosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserPhotosInput, UserUpdateWithoutUserPhotosInput>, UserUncheckedUpdateWithoutUserPhotosInput>
  }

  export type ContestPhotoUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<ContestPhotoCreateWithoutPhotoInput, ContestPhotoUncheckedCreateWithoutPhotoInput> | ContestPhotoCreateWithoutPhotoInput[] | ContestPhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutPhotoInput | ContestPhotoCreateOrConnectWithoutPhotoInput[]
    upsert?: ContestPhotoUpsertWithWhereUniqueWithoutPhotoInput | ContestPhotoUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: ContestPhotoCreateManyPhotoInputEnvelope
    set?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    disconnect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    delete?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    connect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    update?: ContestPhotoUpdateWithWhereUniqueWithoutPhotoInput | ContestPhotoUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: ContestPhotoUpdateManyWithWhereWithoutPhotoInput | ContestPhotoUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: ContestPhotoScalarWhereInput | ContestPhotoScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<LikeCreateWithoutPhotoInput, LikeUncheckedCreateWithoutPhotoInput> | LikeCreateWithoutPhotoInput[] | LikeUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPhotoInput | LikeCreateOrConnectWithoutPhotoInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPhotoInput | LikeUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: LikeCreateManyPhotoInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPhotoInput | LikeUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPhotoInput | LikeUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type ContestPhotoUncheckedUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<ContestPhotoCreateWithoutPhotoInput, ContestPhotoUncheckedCreateWithoutPhotoInput> | ContestPhotoCreateWithoutPhotoInput[] | ContestPhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutPhotoInput | ContestPhotoCreateOrConnectWithoutPhotoInput[]
    upsert?: ContestPhotoUpsertWithWhereUniqueWithoutPhotoInput | ContestPhotoUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: ContestPhotoCreateManyPhotoInputEnvelope
    set?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    disconnect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    delete?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    connect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    update?: ContestPhotoUpdateWithWhereUniqueWithoutPhotoInput | ContestPhotoUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: ContestPhotoUpdateManyWithWhereWithoutPhotoInput | ContestPhotoUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: ContestPhotoScalarWhereInput | ContestPhotoScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<LikeCreateWithoutPhotoInput, LikeUncheckedCreateWithoutPhotoInput> | LikeCreateWithoutPhotoInput[] | LikeUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPhotoInput | LikeCreateOrConnectWithoutPhotoInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPhotoInput | LikeUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: LikeCreateManyPhotoInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPhotoInput | LikeUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPhotoInput | LikeUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLikesInput = {
    create?: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesInput
    connect?: UserWhereUniqueInput
  }

  export type UserPhotoCreateNestedOneWithoutLikesInput = {
    create?: XOR<UserPhotoCreateWithoutLikesInput, UserPhotoUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserPhotoCreateOrConnectWithoutLikesInput
    connect?: UserPhotoWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesInput
    upsert?: UserUpsertWithoutLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikesInput, UserUpdateWithoutLikesInput>, UserUncheckedUpdateWithoutLikesInput>
  }

  export type UserPhotoUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<UserPhotoCreateWithoutLikesInput, UserPhotoUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserPhotoCreateOrConnectWithoutLikesInput
    upsert?: UserPhotoUpsertWithoutLikesInput
    connect?: UserPhotoWhereUniqueInput
    update?: XOR<XOR<UserPhotoUpdateToOneWithWhereWithoutLikesInput, UserPhotoUpdateWithoutLikesInput>, UserPhotoUncheckedUpdateWithoutLikesInput>
  }

  export type UserCreateNestedOneWithoutOtpsInput = {
    create?: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumOtpStatusFieldUpdateOperationsInput = {
    set?: $Enums.OtpStatus
  }

  export type UserUpdateOneRequiredWithoutOtpsNestedInput = {
    create?: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpsInput
    upsert?: UserUpsertWithoutOtpsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOtpsInput, UserUpdateWithoutOtpsInput>, UserUncheckedUpdateWithoutOtpsInput>
  }

  export type UserCreateNestedOneWithoutCommentProvidesInput = {
    create?: XOR<UserCreateWithoutCommentProvidesInput, UserUncheckedCreateWithoutCommentProvidesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentProvidesInput
    connect?: UserWhereUniqueInput
  }

  export type ContestPhotoCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ContestPhotoCreateWithoutCommentsInput, ContestPhotoUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutCommentsInput
    connect?: ContestPhotoWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutCommentRepliesInput = {
    create?: XOR<CommentCreateWithoutCommentRepliesInput, CommentUncheckedCreateWithoutCommentRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutCommentRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCommentProvidesNestedInput = {
    create?: XOR<UserCreateWithoutCommentProvidesInput, UserUncheckedCreateWithoutCommentProvidesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentProvidesInput
    upsert?: UserUpsertWithoutCommentProvidesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentProvidesInput, UserUpdateWithoutCommentProvidesInput>, UserUncheckedUpdateWithoutCommentProvidesInput>
  }

  export type ContestPhotoUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ContestPhotoCreateWithoutCommentsInput, ContestPhotoUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutCommentsInput
    upsert?: ContestPhotoUpsertWithoutCommentsInput
    connect?: ContestPhotoWhereUniqueInput
    update?: XOR<XOR<ContestPhotoUpdateToOneWithWhereWithoutCommentsInput, ContestPhotoUpdateWithoutCommentsInput>, ContestPhotoUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentUpdateOneWithoutCommentRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutCommentRepliesInput, CommentUncheckedCreateWithoutCommentRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutCommentRepliesInput
    upsert?: CommentUpsertWithoutCommentRepliesInput
    disconnect?: boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutCommentRepliesInput, CommentUpdateWithoutCommentRepliesInput>, CommentUncheckedUpdateWithoutCommentRepliesInput>
  }

  export type CommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutFollowersInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFollowingsInput = {
    create?: XOR<UserCreateWithoutFollowingsInput, UserUncheckedCreateWithoutFollowingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFollowersNestedInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    upsert?: UserUpsertWithoutFollowersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowersInput, UserUpdateWithoutFollowersInput>, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserUpdateOneRequiredWithoutFollowingsNestedInput = {
    create?: XOR<UserCreateWithoutFollowingsInput, UserUncheckedCreateWithoutFollowingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingsInput
    upsert?: UserUpsertWithoutFollowingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowingsInput, UserUpdateWithoutFollowingsInput>, UserUncheckedUpdateWithoutFollowingsInput>
  }

  export type UserCreateNestedOneWithoutVotesInput = {
    create?: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVotesInput
    connect?: UserWhereUniqueInput
  }

  export type ContestPhotoCreateNestedOneWithoutVotesInput = {
    create?: XOR<ContestPhotoCreateWithoutVotesInput, ContestPhotoUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutVotesInput
    connect?: ContestPhotoWhereUniqueInput
  }

  export type ContestCreateNestedOneWithoutVotesInput = {
    create?: XOR<ContestCreateWithoutVotesInput, ContestUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ContestCreateOrConnectWithoutVotesInput
    connect?: ContestWhereUniqueInput
  }

  export type EnumVoteTypeFieldUpdateOperationsInput = {
    set?: $Enums.VoteType
  }

  export type UserUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVotesInput
    upsert?: UserUpsertWithoutVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVotesInput, UserUpdateWithoutVotesInput>, UserUncheckedUpdateWithoutVotesInput>
  }

  export type ContestPhotoUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<ContestPhotoCreateWithoutVotesInput, ContestPhotoUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutVotesInput
    upsert?: ContestPhotoUpsertWithoutVotesInput
    connect?: ContestPhotoWhereUniqueInput
    update?: XOR<XOR<ContestPhotoUpdateToOneWithWhereWithoutVotesInput, ContestPhotoUpdateWithoutVotesInput>, ContestPhotoUncheckedUpdateWithoutVotesInput>
  }

  export type ContestUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<ContestCreateWithoutVotesInput, ContestUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ContestCreateOrConnectWithoutVotesInput
    upsert?: ContestUpsertWithoutVotesInput
    connect?: ContestWhereUniqueInput
    update?: XOR<XOR<ContestUpdateToOneWithWhereWithoutVotesInput, ContestUpdateWithoutVotesInput>, ContestUncheckedUpdateWithoutVotesInput>
  }

  export type LevelRequirementListCreateEnvelopeInput = {
    set?: LevelRequirementCreateInput | LevelRequirementCreateInput[]
  }

  export type LevelRequirementCreateInput = {
    title: string
    required: number
    badge: BadgeCreateInput
  }

  export type EnumLevelNameFieldUpdateOperationsInput = {
    set?: $Enums.LevelName
  }

  export type LevelRequirementListUpdateEnvelopeInput = {
    set?: LevelRequirementCreateInput | LevelRequirementCreateInput[]
    push?: LevelRequirementCreateInput | LevelRequirementCreateInput[]
    updateMany?: LevelRequirementUpdateManyInput
    deleteMany?: LevelRequirementDeleteManyInput
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedEnumContestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestStatus | EnumContestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContestStatus[] | ListEnumContestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestStatus[] | ListEnumContestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContestStatusFilter<$PrismaModel> | $Enums.ContestStatus
  }

  export type NestedEnumContestModeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestMode | EnumContestModeFieldRefInput<$PrismaModel>
    in?: $Enums.ContestMode[] | ListEnumContestModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestMode[] | ListEnumContestModeFieldRefInput<$PrismaModel>
    not?: NestedEnumContestModeFilter<$PrismaModel> | $Enums.ContestMode
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumContestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestStatus | EnumContestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContestStatus[] | ListEnumContestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestStatus[] | ListEnumContestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContestStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContestStatusFilter<$PrismaModel>
    _max?: NestedEnumContestStatusFilter<$PrismaModel>
  }

  export type NestedEnumContestModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestMode | EnumContestModeFieldRefInput<$PrismaModel>
    in?: $Enums.ContestMode[] | ListEnumContestModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestMode[] | ListEnumContestModeFieldRefInput<$PrismaModel>
    not?: NestedEnumContestModeWithAggregatesFilter<$PrismaModel> | $Enums.ContestMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContestModeFilter<$PrismaModel>
    _max?: NestedEnumContestModeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type RecurringDataWhereInput = {
    AND?: RecurringDataWhereInput | RecurringDataWhereInput[]
    OR?: RecurringDataWhereInput[]
    NOT?: RecurringDataWhereInput | RecurringDataWhereInput[]
    recurringType?: EnumRecurringTypeFilter<"RecurringData"> | $Enums.RecurringType
    previousOccurrence?: DateTimeNullableFilter<"RecurringData"> | Date | string | null
    nextOccurrence?: DateTimeFilter<"RecurringData"> | Date | string
    duration?: IntFilter<"RecurringData"> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumContestParticipantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestParticipantStatus | EnumContestParticipantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContestParticipantStatus[] | ListEnumContestParticipantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestParticipantStatus[] | ListEnumContestParticipantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContestParticipantStatusFilter<$PrismaModel> | $Enums.ContestParticipantStatus
  }

  export type NestedEnumYCLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.YCLevel | EnumYCLevelFieldRefInput<$PrismaModel>
    in?: $Enums.YCLevel[] | ListEnumYCLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.YCLevel[] | ListEnumYCLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumYCLevelFilter<$PrismaModel> | $Enums.YCLevel
  }

  export type NestedEnumContestParticipantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestParticipantStatus | EnumContestParticipantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContestParticipantStatus[] | ListEnumContestParticipantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestParticipantStatus[] | ListEnumContestParticipantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContestParticipantStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContestParticipantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContestParticipantStatusFilter<$PrismaModel>
    _max?: NestedEnumContestParticipantStatusFilter<$PrismaModel>
  }

  export type NestedEnumYCLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.YCLevel | EnumYCLevelFieldRefInput<$PrismaModel>
    in?: $Enums.YCLevel[] | ListEnumYCLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.YCLevel[] | ListEnumYCLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumYCLevelWithAggregatesFilter<$PrismaModel> | $Enums.YCLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumYCLevelFilter<$PrismaModel>
    _max?: NestedEnumYCLevelFilter<$PrismaModel>
  }

  export type NestedEnumPrizeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PrizeType | EnumPrizeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PrizeType[] | ListEnumPrizeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrizeType[] | ListEnumPrizeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPrizeTypeFilter<$PrismaModel> | $Enums.PrizeType
  }

  export type NestedEnumPrizeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrizeType | EnumPrizeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PrizeType[] | ListEnumPrizeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrizeType[] | ListEnumPrizeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPrizeTypeWithAggregatesFilter<$PrismaModel> | $Enums.PrizeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrizeTypeFilter<$PrismaModel>
    _max?: NestedEnumPrizeTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumSitePolicyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SitePolicyType | EnumSitePolicyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SitePolicyType[] | ListEnumSitePolicyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SitePolicyType[] | ListEnumSitePolicyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSitePolicyTypeFilter<$PrismaModel> | $Enums.SitePolicyType
  }

  export type NestedEnumSitePolicyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SitePolicyType | EnumSitePolicyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SitePolicyType[] | ListEnumSitePolicyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SitePolicyType[] | ListEnumSitePolicyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSitePolicyTypeWithAggregatesFilter<$PrismaModel> | $Enums.SitePolicyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSitePolicyTypeFilter<$PrismaModel>
    _max?: NestedEnumSitePolicyTypeFilter<$PrismaModel>
  }

  export type NestedEnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type NestedEnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type NestedEnumTeamAccessibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamAccessibility | EnumTeamAccessibilityFieldRefInput<$PrismaModel>
    in?: $Enums.TeamAccessibility[] | ListEnumTeamAccessibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamAccessibility[] | ListEnumTeamAccessibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamAccessibilityFilter<$PrismaModel> | $Enums.TeamAccessibility
  }

  export type NestedEnumTeamAccessibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamAccessibility | EnumTeamAccessibilityFieldRefInput<$PrismaModel>
    in?: $Enums.TeamAccessibility[] | ListEnumTeamAccessibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamAccessibility[] | ListEnumTeamAccessibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamAccessibilityWithAggregatesFilter<$PrismaModel> | $Enums.TeamAccessibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamAccessibilityFilter<$PrismaModel>
    _max?: NestedEnumTeamAccessibilityFilter<$PrismaModel>
  }

  export type NestedEnumTeamMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamMemberStatus | EnumTeamMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TeamMemberStatus[] | ListEnumTeamMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamMemberStatus[] | ListEnumTeamMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamMemberStatusFilter<$PrismaModel> | $Enums.TeamMemberStatus
  }

  export type NestedEnumMemberLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberLevel | EnumMemberLevelFieldRefInput<$PrismaModel>
    in?: $Enums.MemberLevel[] | ListEnumMemberLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberLevel[] | ListEnumMemberLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberLevelFilter<$PrismaModel> | $Enums.MemberLevel
  }

  export type NestedEnumTeamMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamMemberStatus | EnumTeamMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TeamMemberStatus[] | ListEnumTeamMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamMemberStatus[] | ListEnumTeamMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.TeamMemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumTeamMemberStatusFilter<$PrismaModel>
  }

  export type NestedEnumMemberLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberLevel | EnumMemberLevelFieldRefInput<$PrismaModel>
    in?: $Enums.MemberLevel[] | ListEnumMemberLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberLevel[] | ListEnumMemberLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberLevelWithAggregatesFilter<$PrismaModel> | $Enums.MemberLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberLevelFilter<$PrismaModel>
    _max?: NestedEnumMemberLevelFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type PhotoStatsWhereInput = {
    AND?: PhotoStatsWhereInput | PhotoStatsWhereInput[]
    OR?: PhotoStatsWhereInput[]
    NOT?: PhotoStatsWhereInput | PhotoStatsWhereInput[]
    Composition?: IntFilter<"PhotoStats"> | number
    Content?: IntFilter<"PhotoStats"> | number
    Creativity?: IntFilter<"PhotoStats"> | number
    Technique?: IntFilter<"PhotoStats"> | number
  }

  export type NestedEnumOtpStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OtpStatus | EnumOtpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OtpStatus[] | ListEnumOtpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OtpStatus[] | ListEnumOtpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOtpStatusFilter<$PrismaModel> | $Enums.OtpStatus
  }

  export type NestedEnumOtpStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OtpStatus | EnumOtpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OtpStatus[] | ListEnumOtpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OtpStatus[] | ListEnumOtpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOtpStatusWithAggregatesFilter<$PrismaModel> | $Enums.OtpStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOtpStatusFilter<$PrismaModel>
    _max?: NestedEnumOtpStatusFilter<$PrismaModel>
  }

  export type NestedEnumVoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteType | EnumVoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteTypeFilter<$PrismaModel> | $Enums.VoteType
  }

  export type NestedEnumVoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteType | EnumVoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.VoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoteTypeFilter<$PrismaModel>
    _max?: NestedEnumVoteTypeFilter<$PrismaModel>
  }

  export type NestedEnumLevelNameFilter<$PrismaModel = never> = {
    equals?: $Enums.LevelName | EnumLevelNameFieldRefInput<$PrismaModel>
    in?: $Enums.LevelName[] | ListEnumLevelNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.LevelName[] | ListEnumLevelNameFieldRefInput<$PrismaModel>
    not?: NestedEnumLevelNameFilter<$PrismaModel> | $Enums.LevelName
  }

  export type LevelRequirementWhereInput = {
    AND?: LevelRequirementWhereInput | LevelRequirementWhereInput[]
    OR?: LevelRequirementWhereInput[]
    NOT?: LevelRequirementWhereInput | LevelRequirementWhereInput[]
    title?: StringFilter<"LevelRequirement"> | string
    required?: IntFilter<"LevelRequirement"> | number
    badge?: XOR<BadgeCompositeFilter, BadgeObjectEqualityInput>
  }

  export type BadgeObjectEqualityInput = {
    type: string
    param: string
  }

  export type NestedEnumLevelNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LevelName | EnumLevelNameFieldRefInput<$PrismaModel>
    in?: $Enums.LevelName[] | ListEnumLevelNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.LevelName[] | ListEnumLevelNameFieldRefInput<$PrismaModel>
    not?: NestedEnumLevelNameWithAggregatesFilter<$PrismaModel> | $Enums.LevelName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLevelNameFilter<$PrismaModel>
    _max?: NestedEnumLevelNameFilter<$PrismaModel>
  }

  export type UserCreateWithoutCreatedContestsInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    store?: UserStoreCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutCreatedContestsInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    store?: UserStoreUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutCreatedContestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedContestsInput, UserUncheckedCreateWithoutCreatedContestsInput>
  }

  export type ContestParticipantCreateWithoutContestInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    level?: $Enums.YCLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContestParticipantInput
    member?: TeamMemberCreateNestedOneWithoutContestParticipantInput
    photos?: ContestPhotoCreateNestedManyWithoutParticipantInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantUncheckedCreateWithoutContestInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    userId: string
    memberId?: string | null
    level?: $Enums.YCLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ContestPhotoUncheckedCreateNestedManyWithoutParticipantInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantCreateOrConnectWithoutContestInput = {
    where: ContestParticipantWhereUniqueInput
    create: XOR<ContestParticipantCreateWithoutContestInput, ContestParticipantUncheckedCreateWithoutContestInput>
  }

  export type ContestParticipantCreateManyContestInputEnvelope = {
    data: ContestParticipantCreateManyContestInput | ContestParticipantCreateManyContestInput[]
  }

  export type TeamParticipationCreateWithoutContestInput = {
    id?: string
    team: TeamCreateNestedOneWithoutParticipationsInput
  }

  export type TeamParticipationUncheckedCreateWithoutContestInput = {
    id?: string
    teamId: string
  }

  export type TeamParticipationCreateOrConnectWithoutContestInput = {
    where: TeamParticipationWhereUniqueInput
    create: XOR<TeamParticipationCreateWithoutContestInput, TeamParticipationUncheckedCreateWithoutContestInput>
  }

  export type TeamParticipationCreateManyContestInputEnvelope = {
    data: TeamParticipationCreateManyContestInput | TeamParticipationCreateManyContestInput[]
  }

  export type VoteCreateWithoutContestInput = {
    id?: string
    type: $Enums.VoteType
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: UserCreateNestedOneWithoutVotesInput
    photo: ContestPhotoCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateWithoutContestInput = {
    id?: string
    providerId: string
    photoId: string
    type: $Enums.VoteType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteCreateOrConnectWithoutContestInput = {
    where: VoteWhereUniqueInput
    create: XOR<VoteCreateWithoutContestInput, VoteUncheckedCreateWithoutContestInput>
  }

  export type VoteCreateManyContestInputEnvelope = {
    data: VoteCreateManyContestInput | VoteCreateManyContestInput[]
  }

  export type ContestRuleCreateWithoutContestInput = {
    id?: string
    icon?: string | null
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestRuleUncheckedCreateWithoutContestInput = {
    id?: string
    icon?: string | null
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestRuleCreateOrConnectWithoutContestInput = {
    where: ContestRuleWhereUniqueInput
    create: XOR<ContestRuleCreateWithoutContestInput, ContestRuleUncheckedCreateWithoutContestInput>
  }

  export type ContestRuleCreateManyContestInputEnvelope = {
    data: ContestRuleCreateManyContestInput | ContestRuleCreateManyContestInput[]
  }

  export type ContestPrizeCreateWithoutContestInput = {
    id?: string
    category: $Enums.PrizeType
    trades?: number
    charges?: number
    keys?: number
  }

  export type ContestPrizeUncheckedCreateWithoutContestInput = {
    id?: string
    category: $Enums.PrizeType
    trades?: number
    charges?: number
    keys?: number
  }

  export type ContestPrizeCreateOrConnectWithoutContestInput = {
    where: ContestPrizeWhereUniqueInput
    create: XOR<ContestPrizeCreateWithoutContestInput, ContestPrizeUncheckedCreateWithoutContestInput>
  }

  export type ContestPrizeCreateManyContestInputEnvelope = {
    data: ContestPrizeCreateManyContestInput | ContestPrizeCreateManyContestInput[]
  }

  export type ContestAchievementCreateWithoutContestInput = {
    id?: string
    category: $Enums.PrizeType
    createdAt?: Date | string
    updatedAt?: Date | string
    photo?: ContestPhotoCreateNestedOneWithoutAchievementsInput
    participant?: ContestParticipantCreateNestedOneWithoutContestAchievementInput
  }

  export type ContestAchievementUncheckedCreateWithoutContestInput = {
    id?: string
    category: $Enums.PrizeType
    photoId?: string | null
    participantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestAchievementCreateOrConnectWithoutContestInput = {
    where: ContestAchievementWhereUniqueInput
    create: XOR<ContestAchievementCreateWithoutContestInput, ContestAchievementUncheckedCreateWithoutContestInput>
  }

  export type ContestAchievementCreateManyContestInputEnvelope = {
    data: ContestAchievementCreateManyContestInput | ContestAchievementCreateManyContestInput[]
  }

  export type UserUpsertWithoutCreatedContestsInput = {
    update: XOR<UserUpdateWithoutCreatedContestsInput, UserUncheckedUpdateWithoutCreatedContestsInput>
    create: XOR<UserCreateWithoutCreatedContestsInput, UserUncheckedCreateWithoutCreatedContestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedContestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedContestsInput, UserUncheckedUpdateWithoutCreatedContestsInput>
  }

  export type UserUpdateWithoutCreatedContestsInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    store?: UserStoreUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedContestsInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    store?: UserStoreUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type ContestParticipantUpsertWithWhereUniqueWithoutContestInput = {
    where: ContestParticipantWhereUniqueInput
    update: XOR<ContestParticipantUpdateWithoutContestInput, ContestParticipantUncheckedUpdateWithoutContestInput>
    create: XOR<ContestParticipantCreateWithoutContestInput, ContestParticipantUncheckedCreateWithoutContestInput>
  }

  export type ContestParticipantUpdateWithWhereUniqueWithoutContestInput = {
    where: ContestParticipantWhereUniqueInput
    data: XOR<ContestParticipantUpdateWithoutContestInput, ContestParticipantUncheckedUpdateWithoutContestInput>
  }

  export type ContestParticipantUpdateManyWithWhereWithoutContestInput = {
    where: ContestParticipantScalarWhereInput
    data: XOR<ContestParticipantUpdateManyMutationInput, ContestParticipantUncheckedUpdateManyWithoutContestInput>
  }

  export type ContestParticipantScalarWhereInput = {
    AND?: ContestParticipantScalarWhereInput | ContestParticipantScalarWhereInput[]
    OR?: ContestParticipantScalarWhereInput[]
    NOT?: ContestParticipantScalarWhereInput | ContestParticipantScalarWhereInput[]
    id?: StringFilter<"ContestParticipant"> | string
    status?: EnumContestParticipantStatusFilter<"ContestParticipant"> | $Enums.ContestParticipantStatus
    contestId?: StringFilter<"ContestParticipant"> | string
    userId?: StringFilter<"ContestParticipant"> | string
    memberId?: StringNullableFilter<"ContestParticipant"> | string | null
    level?: EnumYCLevelFilter<"ContestParticipant"> | $Enums.YCLevel
    rank?: IntNullableFilter<"ContestParticipant"> | number | null
    createdAt?: DateTimeFilter<"ContestParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"ContestParticipant"> | Date | string
  }

  export type TeamParticipationUpsertWithWhereUniqueWithoutContestInput = {
    where: TeamParticipationWhereUniqueInput
    update: XOR<TeamParticipationUpdateWithoutContestInput, TeamParticipationUncheckedUpdateWithoutContestInput>
    create: XOR<TeamParticipationCreateWithoutContestInput, TeamParticipationUncheckedCreateWithoutContestInput>
  }

  export type TeamParticipationUpdateWithWhereUniqueWithoutContestInput = {
    where: TeamParticipationWhereUniqueInput
    data: XOR<TeamParticipationUpdateWithoutContestInput, TeamParticipationUncheckedUpdateWithoutContestInput>
  }

  export type TeamParticipationUpdateManyWithWhereWithoutContestInput = {
    where: TeamParticipationScalarWhereInput
    data: XOR<TeamParticipationUpdateManyMutationInput, TeamParticipationUncheckedUpdateManyWithoutContestInput>
  }

  export type TeamParticipationScalarWhereInput = {
    AND?: TeamParticipationScalarWhereInput | TeamParticipationScalarWhereInput[]
    OR?: TeamParticipationScalarWhereInput[]
    NOT?: TeamParticipationScalarWhereInput | TeamParticipationScalarWhereInput[]
    id?: StringFilter<"TeamParticipation"> | string
    teamId?: StringFilter<"TeamParticipation"> | string
    contestId?: StringFilter<"TeamParticipation"> | string
  }

  export type VoteUpsertWithWhereUniqueWithoutContestInput = {
    where: VoteWhereUniqueInput
    update: XOR<VoteUpdateWithoutContestInput, VoteUncheckedUpdateWithoutContestInput>
    create: XOR<VoteCreateWithoutContestInput, VoteUncheckedCreateWithoutContestInput>
  }

  export type VoteUpdateWithWhereUniqueWithoutContestInput = {
    where: VoteWhereUniqueInput
    data: XOR<VoteUpdateWithoutContestInput, VoteUncheckedUpdateWithoutContestInput>
  }

  export type VoteUpdateManyWithWhereWithoutContestInput = {
    where: VoteScalarWhereInput
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyWithoutContestInput>
  }

  export type VoteScalarWhereInput = {
    AND?: VoteScalarWhereInput | VoteScalarWhereInput[]
    OR?: VoteScalarWhereInput[]
    NOT?: VoteScalarWhereInput | VoteScalarWhereInput[]
    id?: StringFilter<"Vote"> | string
    providerId?: StringFilter<"Vote"> | string
    photoId?: StringFilter<"Vote"> | string
    contestId?: StringFilter<"Vote"> | string
    type?: EnumVoteTypeFilter<"Vote"> | $Enums.VoteType
    createdAt?: DateTimeFilter<"Vote"> | Date | string
    updatedAt?: DateTimeFilter<"Vote"> | Date | string
  }

  export type ContestRuleUpsertWithWhereUniqueWithoutContestInput = {
    where: ContestRuleWhereUniqueInput
    update: XOR<ContestRuleUpdateWithoutContestInput, ContestRuleUncheckedUpdateWithoutContestInput>
    create: XOR<ContestRuleCreateWithoutContestInput, ContestRuleUncheckedCreateWithoutContestInput>
  }

  export type ContestRuleUpdateWithWhereUniqueWithoutContestInput = {
    where: ContestRuleWhereUniqueInput
    data: XOR<ContestRuleUpdateWithoutContestInput, ContestRuleUncheckedUpdateWithoutContestInput>
  }

  export type ContestRuleUpdateManyWithWhereWithoutContestInput = {
    where: ContestRuleScalarWhereInput
    data: XOR<ContestRuleUpdateManyMutationInput, ContestRuleUncheckedUpdateManyWithoutContestInput>
  }

  export type ContestRuleScalarWhereInput = {
    AND?: ContestRuleScalarWhereInput | ContestRuleScalarWhereInput[]
    OR?: ContestRuleScalarWhereInput[]
    NOT?: ContestRuleScalarWhereInput | ContestRuleScalarWhereInput[]
    id?: StringFilter<"ContestRule"> | string
    icon?: StringNullableFilter<"ContestRule"> | string | null
    name?: StringFilter<"ContestRule"> | string
    description?: StringFilter<"ContestRule"> | string
    contestId?: StringFilter<"ContestRule"> | string
    createdAt?: DateTimeFilter<"ContestRule"> | Date | string
    updatedAt?: DateTimeFilter<"ContestRule"> | Date | string
  }

  export type ContestPrizeUpsertWithWhereUniqueWithoutContestInput = {
    where: ContestPrizeWhereUniqueInput
    update: XOR<ContestPrizeUpdateWithoutContestInput, ContestPrizeUncheckedUpdateWithoutContestInput>
    create: XOR<ContestPrizeCreateWithoutContestInput, ContestPrizeUncheckedCreateWithoutContestInput>
  }

  export type ContestPrizeUpdateWithWhereUniqueWithoutContestInput = {
    where: ContestPrizeWhereUniqueInput
    data: XOR<ContestPrizeUpdateWithoutContestInput, ContestPrizeUncheckedUpdateWithoutContestInput>
  }

  export type ContestPrizeUpdateManyWithWhereWithoutContestInput = {
    where: ContestPrizeScalarWhereInput
    data: XOR<ContestPrizeUpdateManyMutationInput, ContestPrizeUncheckedUpdateManyWithoutContestInput>
  }

  export type ContestPrizeScalarWhereInput = {
    AND?: ContestPrizeScalarWhereInput | ContestPrizeScalarWhereInput[]
    OR?: ContestPrizeScalarWhereInput[]
    NOT?: ContestPrizeScalarWhereInput | ContestPrizeScalarWhereInput[]
    id?: StringFilter<"ContestPrize"> | string
    category?: EnumPrizeTypeFilter<"ContestPrize"> | $Enums.PrizeType
    trades?: IntFilter<"ContestPrize"> | number
    charges?: IntFilter<"ContestPrize"> | number
    keys?: IntFilter<"ContestPrize"> | number
    contestId?: StringFilter<"ContestPrize"> | string
  }

  export type ContestAchievementUpsertWithWhereUniqueWithoutContestInput = {
    where: ContestAchievementWhereUniqueInput
    update: XOR<ContestAchievementUpdateWithoutContestInput, ContestAchievementUncheckedUpdateWithoutContestInput>
    create: XOR<ContestAchievementCreateWithoutContestInput, ContestAchievementUncheckedCreateWithoutContestInput>
  }

  export type ContestAchievementUpdateWithWhereUniqueWithoutContestInput = {
    where: ContestAchievementWhereUniqueInput
    data: XOR<ContestAchievementUpdateWithoutContestInput, ContestAchievementUncheckedUpdateWithoutContestInput>
  }

  export type ContestAchievementUpdateManyWithWhereWithoutContestInput = {
    where: ContestAchievementScalarWhereInput
    data: XOR<ContestAchievementUpdateManyMutationInput, ContestAchievementUncheckedUpdateManyWithoutContestInput>
  }

  export type ContestAchievementScalarWhereInput = {
    AND?: ContestAchievementScalarWhereInput | ContestAchievementScalarWhereInput[]
    OR?: ContestAchievementScalarWhereInput[]
    NOT?: ContestAchievementScalarWhereInput | ContestAchievementScalarWhereInput[]
    id?: StringFilter<"ContestAchievement"> | string
    category?: EnumPrizeTypeFilter<"ContestAchievement"> | $Enums.PrizeType
    photoId?: StringNullableFilter<"ContestAchievement"> | string | null
    participantId?: StringNullableFilter<"ContestAchievement"> | string | null
    contestId?: StringFilter<"ContestAchievement"> | string
    createdAt?: DateTimeFilter<"ContestAchievement"> | Date | string
    updatedAt?: DateTimeFilter<"ContestAchievement"> | Date | string
  }

  export type RecurringDataUpdateInput = {
    recurringType?: EnumRecurringTypeFieldUpdateOperationsInput | $Enums.RecurringType
    previousOccurrence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
  }

  export type ContestCreateWithoutContestRulesInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    mode?: $Enums.ContestMode
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: ContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedContestsInput
    participants?: ContestParticipantCreateNestedManyWithoutContestInput
    teamParticipations?: TeamParticipationCreateNestedManyWithoutContestInput
    votes?: VoteCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeCreateNestedManyWithoutContestInput
    achievements?: ContestAchievementCreateNestedManyWithoutContestInput
  }

  export type ContestUncheckedCreateWithoutContestRulesInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    mode?: $Enums.ContestMode
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: ContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ContestParticipantUncheckedCreateNestedManyWithoutContestInput
    teamParticipations?: TeamParticipationUncheckedCreateNestedManyWithoutContestInput
    votes?: VoteUncheckedCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeUncheckedCreateNestedManyWithoutContestInput
    achievements?: ContestAchievementUncheckedCreateNestedManyWithoutContestInput
  }

  export type ContestCreateOrConnectWithoutContestRulesInput = {
    where: ContestWhereUniqueInput
    create: XOR<ContestCreateWithoutContestRulesInput, ContestUncheckedCreateWithoutContestRulesInput>
  }

  export type ContestUpsertWithoutContestRulesInput = {
    update: XOR<ContestUpdateWithoutContestRulesInput, ContestUncheckedUpdateWithoutContestRulesInput>
    create: XOR<ContestCreateWithoutContestRulesInput, ContestUncheckedCreateWithoutContestRulesInput>
    where?: ContestWhereInput
  }

  export type ContestUpdateToOneWithWhereWithoutContestRulesInput = {
    where?: ContestWhereInput
    data: XOR<ContestUpdateWithoutContestRulesInput, ContestUncheckedUpdateWithoutContestRulesInput>
  }

  export type ContestUpdateWithoutContestRulesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    mode?: EnumContestModeFieldUpdateOperationsInput | $Enums.ContestMode
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: ContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedContestsNestedInput
    participants?: ContestParticipantUpdateManyWithoutContestNestedInput
    teamParticipations?: TeamParticipationUpdateManyWithoutContestNestedInput
    votes?: VoteUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUpdateManyWithoutContestNestedInput
    achievements?: ContestAchievementUpdateManyWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateWithoutContestRulesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    mode?: EnumContestModeFieldUpdateOperationsInput | $Enums.ContestMode
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: ContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ContestParticipantUncheckedUpdateManyWithoutContestNestedInput
    teamParticipations?: TeamParticipationUncheckedUpdateManyWithoutContestNestedInput
    votes?: VoteUncheckedUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUncheckedUpdateManyWithoutContestNestedInput
    achievements?: ContestAchievementUncheckedUpdateManyWithoutContestNestedInput
  }

  export type ContestParticipantCreateWithoutPhotosInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    level?: $Enums.YCLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contest: ContestCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutContestParticipantInput
    member?: TeamMemberCreateNestedOneWithoutContestParticipantInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantUncheckedCreateWithoutPhotosInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    contestId: string
    userId: string
    memberId?: string | null
    level?: $Enums.YCLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantCreateOrConnectWithoutPhotosInput = {
    where: ContestParticipantWhereUniqueInput
    create: XOR<ContestParticipantCreateWithoutPhotosInput, ContestParticipantUncheckedCreateWithoutPhotosInput>
  }

  export type VoteCreateWithoutPhotoInput = {
    id?: string
    type: $Enums.VoteType
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: UserCreateNestedOneWithoutVotesInput
    contest: ContestCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateWithoutPhotoInput = {
    id?: string
    providerId: string
    contestId: string
    type: $Enums.VoteType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteCreateOrConnectWithoutPhotoInput = {
    where: VoteWhereUniqueInput
    create: XOR<VoteCreateWithoutPhotoInput, VoteUncheckedCreateWithoutPhotoInput>
  }

  export type VoteCreateManyPhotoInputEnvelope = {
    data: VoteCreateManyPhotoInput | VoteCreateManyPhotoInput[]
  }

  export type UserPhotoCreateWithoutContestUploadInput = {
    id?: string
    url: string
    states?: XOR<PhotoStatsNullableCreateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: number
    labels?: UserPhotoCreatelabelsInput | string[]
    title?: string | null
    description?: string | null
    adult?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserPhotosInput
    likes?: LikeCreateNestedManyWithoutPhotoInput
  }

  export type UserPhotoUncheckedCreateWithoutContestUploadInput = {
    id?: string
    url: string
    userId: string
    states?: XOR<PhotoStatsNullableCreateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: number
    labels?: UserPhotoCreatelabelsInput | string[]
    title?: string | null
    description?: string | null
    adult?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: LikeUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type UserPhotoCreateOrConnectWithoutContestUploadInput = {
    where: UserPhotoWhereUniqueInput
    create: XOR<UserPhotoCreateWithoutContestUploadInput, UserPhotoUncheckedCreateWithoutContestUploadInput>
  }

  export type CommentCreateWithoutReceiverInput = {
    id?: string
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: UserCreateNestedOneWithoutCommentProvidesInput
    parent?: CommentCreateNestedOneWithoutCommentRepliesInput
    CommentReplies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutReceiverInput = {
    id?: string
    text: string
    providerId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CommentReplies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutReceiverInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutReceiverInput, CommentUncheckedCreateWithoutReceiverInput>
  }

  export type CommentCreateManyReceiverInputEnvelope = {
    data: CommentCreateManyReceiverInput | CommentCreateManyReceiverInput[]
  }

  export type ContestAchievementCreateWithoutPhotoInput = {
    id?: string
    category: $Enums.PrizeType
    createdAt?: Date | string
    updatedAt?: Date | string
    contest: ContestCreateNestedOneWithoutAchievementsInput
    participant?: ContestParticipantCreateNestedOneWithoutContestAchievementInput
  }

  export type ContestAchievementUncheckedCreateWithoutPhotoInput = {
    id?: string
    category: $Enums.PrizeType
    participantId?: string | null
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestAchievementCreateOrConnectWithoutPhotoInput = {
    where: ContestAchievementWhereUniqueInput
    create: XOR<ContestAchievementCreateWithoutPhotoInput, ContestAchievementUncheckedCreateWithoutPhotoInput>
  }

  export type ContestAchievementCreateManyPhotoInputEnvelope = {
    data: ContestAchievementCreateManyPhotoInput | ContestAchievementCreateManyPhotoInput[]
  }

  export type ContestWinnerCreateWithoutPhotoInput = {
    id?: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participant: ContestParticipantCreateNestedOneWithoutContestWinnerInput
  }

  export type ContestWinnerUncheckedCreateWithoutPhotoInput = {
    id?: string
    participantId: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestWinnerCreateOrConnectWithoutPhotoInput = {
    where: ContestWinnerWhereUniqueInput
    create: XOR<ContestWinnerCreateWithoutPhotoInput, ContestWinnerUncheckedCreateWithoutPhotoInput>
  }

  export type ContestWinnerCreateManyPhotoInputEnvelope = {
    data: ContestWinnerCreateManyPhotoInput | ContestWinnerCreateManyPhotoInput[]
  }

  export type ContestParticipantUpsertWithoutPhotosInput = {
    update: XOR<ContestParticipantUpdateWithoutPhotosInput, ContestParticipantUncheckedUpdateWithoutPhotosInput>
    create: XOR<ContestParticipantCreateWithoutPhotosInput, ContestParticipantUncheckedCreateWithoutPhotosInput>
    where?: ContestParticipantWhereInput
  }

  export type ContestParticipantUpdateToOneWithWhereWithoutPhotosInput = {
    where?: ContestParticipantWhereInput
    data: XOR<ContestParticipantUpdateWithoutPhotosInput, ContestParticipantUncheckedUpdateWithoutPhotosInput>
  }

  export type ContestParticipantUpdateWithoutPhotosInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    level?: EnumYCLevelFieldUpdateOperationsInput | $Enums.YCLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contest?: ContestUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutContestParticipantNestedInput
    member?: TeamMemberUpdateOneWithoutContestParticipantNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUpdateManyWithoutParticipantNestedInput
  }

  export type ContestParticipantUncheckedUpdateWithoutPhotosInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    contestId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumYCLevelFieldUpdateOperationsInput | $Enums.YCLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type VoteUpsertWithWhereUniqueWithoutPhotoInput = {
    where: VoteWhereUniqueInput
    update: XOR<VoteUpdateWithoutPhotoInput, VoteUncheckedUpdateWithoutPhotoInput>
    create: XOR<VoteCreateWithoutPhotoInput, VoteUncheckedCreateWithoutPhotoInput>
  }

  export type VoteUpdateWithWhereUniqueWithoutPhotoInput = {
    where: VoteWhereUniqueInput
    data: XOR<VoteUpdateWithoutPhotoInput, VoteUncheckedUpdateWithoutPhotoInput>
  }

  export type VoteUpdateManyWithWhereWithoutPhotoInput = {
    where: VoteScalarWhereInput
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyWithoutPhotoInput>
  }

  export type UserPhotoUpsertWithoutContestUploadInput = {
    update: XOR<UserPhotoUpdateWithoutContestUploadInput, UserPhotoUncheckedUpdateWithoutContestUploadInput>
    create: XOR<UserPhotoCreateWithoutContestUploadInput, UserPhotoUncheckedCreateWithoutContestUploadInput>
    where?: UserPhotoWhereInput
  }

  export type UserPhotoUpdateToOneWithWhereWithoutContestUploadInput = {
    where?: UserPhotoWhereInput
    data: XOR<UserPhotoUpdateWithoutContestUploadInput, UserPhotoUncheckedUpdateWithoutContestUploadInput>
  }

  export type UserPhotoUpdateWithoutContestUploadInput = {
    url?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserPhotosNestedInput
    likes?: LikeUpdateManyWithoutPhotoNestedInput
  }

  export type UserPhotoUncheckedUpdateWithoutContestUploadInput = {
    url?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: LikeUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutReceiverInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutReceiverInput, CommentUncheckedUpdateWithoutReceiverInput>
    create: XOR<CommentCreateWithoutReceiverInput, CommentUncheckedCreateWithoutReceiverInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutReceiverInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutReceiverInput, CommentUncheckedUpdateWithoutReceiverInput>
  }

  export type CommentUpdateManyWithWhereWithoutReceiverInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutReceiverInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    text?: StringFilter<"Comment"> | string
    providerId?: StringFilter<"Comment"> | string
    receiverId?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type ContestAchievementUpsertWithWhereUniqueWithoutPhotoInput = {
    where: ContestAchievementWhereUniqueInput
    update: XOR<ContestAchievementUpdateWithoutPhotoInput, ContestAchievementUncheckedUpdateWithoutPhotoInput>
    create: XOR<ContestAchievementCreateWithoutPhotoInput, ContestAchievementUncheckedCreateWithoutPhotoInput>
  }

  export type ContestAchievementUpdateWithWhereUniqueWithoutPhotoInput = {
    where: ContestAchievementWhereUniqueInput
    data: XOR<ContestAchievementUpdateWithoutPhotoInput, ContestAchievementUncheckedUpdateWithoutPhotoInput>
  }

  export type ContestAchievementUpdateManyWithWhereWithoutPhotoInput = {
    where: ContestAchievementScalarWhereInput
    data: XOR<ContestAchievementUpdateManyMutationInput, ContestAchievementUncheckedUpdateManyWithoutPhotoInput>
  }

  export type ContestWinnerUpsertWithWhereUniqueWithoutPhotoInput = {
    where: ContestWinnerWhereUniqueInput
    update: XOR<ContestWinnerUpdateWithoutPhotoInput, ContestWinnerUncheckedUpdateWithoutPhotoInput>
    create: XOR<ContestWinnerCreateWithoutPhotoInput, ContestWinnerUncheckedCreateWithoutPhotoInput>
  }

  export type ContestWinnerUpdateWithWhereUniqueWithoutPhotoInput = {
    where: ContestWinnerWhereUniqueInput
    data: XOR<ContestWinnerUpdateWithoutPhotoInput, ContestWinnerUncheckedUpdateWithoutPhotoInput>
  }

  export type ContestWinnerUpdateManyWithWhereWithoutPhotoInput = {
    where: ContestWinnerScalarWhereInput
    data: XOR<ContestWinnerUpdateManyMutationInput, ContestWinnerUncheckedUpdateManyWithoutPhotoInput>
  }

  export type ContestWinnerScalarWhereInput = {
    AND?: ContestWinnerScalarWhereInput | ContestWinnerScalarWhereInput[]
    OR?: ContestWinnerScalarWhereInput[]
    NOT?: ContestWinnerScalarWhereInput | ContestWinnerScalarWhereInput[]
    id?: StringFilter<"ContestWinner"> | string
    participantId?: StringFilter<"ContestWinner"> | string
    contestId?: StringFilter<"ContestWinner"> | string
    contestPhotoId?: StringFilter<"ContestWinner"> | string
    createdAt?: DateTimeFilter<"ContestWinner"> | Date | string
    updatedAt?: DateTimeFilter<"ContestWinner"> | Date | string
  }

  export type ContestParticipantCreateWithoutContestWinnerInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    level?: $Enums.YCLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contest: ContestCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutContestParticipantInput
    member?: TeamMemberCreateNestedOneWithoutContestParticipantInput
    photos?: ContestPhotoCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantUncheckedCreateWithoutContestWinnerInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    contestId: string
    userId: string
    memberId?: string | null
    level?: $Enums.YCLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ContestPhotoUncheckedCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantCreateOrConnectWithoutContestWinnerInput = {
    where: ContestParticipantWhereUniqueInput
    create: XOR<ContestParticipantCreateWithoutContestWinnerInput, ContestParticipantUncheckedCreateWithoutContestWinnerInput>
  }

  export type ContestPhotoCreateWithoutContestWinnerInput = {
    id?: string
    title?: string | null
    contestId: string
    rank?: number | null
    promoted?: boolean
    promotionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participant: ContestParticipantCreateNestedOneWithoutPhotosInput
    votes?: VoteCreateNestedManyWithoutPhotoInput
    photo: UserPhotoCreateNestedOneWithoutContestUploadInput
    comments?: CommentCreateNestedManyWithoutReceiverInput
    achievements?: ContestAchievementCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoUncheckedCreateWithoutContestWinnerInput = {
    id?: string
    title?: string | null
    contestId: string
    participantId: string
    photoId: string
    rank?: number | null
    promoted?: boolean
    promotionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutPhotoInput
    comments?: CommentUncheckedCreateNestedManyWithoutReceiverInput
    achievements?: ContestAchievementUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoCreateOrConnectWithoutContestWinnerInput = {
    where: ContestPhotoWhereUniqueInput
    create: XOR<ContestPhotoCreateWithoutContestWinnerInput, ContestPhotoUncheckedCreateWithoutContestWinnerInput>
  }

  export type ContestParticipantUpsertWithoutContestWinnerInput = {
    update: XOR<ContestParticipantUpdateWithoutContestWinnerInput, ContestParticipantUncheckedUpdateWithoutContestWinnerInput>
    create: XOR<ContestParticipantCreateWithoutContestWinnerInput, ContestParticipantUncheckedCreateWithoutContestWinnerInput>
    where?: ContestParticipantWhereInput
  }

  export type ContestParticipantUpdateToOneWithWhereWithoutContestWinnerInput = {
    where?: ContestParticipantWhereInput
    data: XOR<ContestParticipantUpdateWithoutContestWinnerInput, ContestParticipantUncheckedUpdateWithoutContestWinnerInput>
  }

  export type ContestParticipantUpdateWithoutContestWinnerInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    level?: EnumYCLevelFieldUpdateOperationsInput | $Enums.YCLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contest?: ContestUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutContestParticipantNestedInput
    member?: TeamMemberUpdateOneWithoutContestParticipantNestedInput
    photos?: ContestPhotoUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUpdateManyWithoutParticipantNestedInput
  }

  export type ContestParticipantUncheckedUpdateWithoutContestWinnerInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    contestId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumYCLevelFieldUpdateOperationsInput | $Enums.YCLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ContestPhotoUncheckedUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type ContestPhotoUpsertWithoutContestWinnerInput = {
    update: XOR<ContestPhotoUpdateWithoutContestWinnerInput, ContestPhotoUncheckedUpdateWithoutContestWinnerInput>
    create: XOR<ContestPhotoCreateWithoutContestWinnerInput, ContestPhotoUncheckedCreateWithoutContestWinnerInput>
    where?: ContestPhotoWhereInput
  }

  export type ContestPhotoUpdateToOneWithWhereWithoutContestWinnerInput = {
    where?: ContestPhotoWhereInput
    data: XOR<ContestPhotoUpdateWithoutContestWinnerInput, ContestPhotoUncheckedUpdateWithoutContestWinnerInput>
  }

  export type ContestPhotoUpdateWithoutContestWinnerInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    promoted?: BoolFieldUpdateOperationsInput | boolean
    promotionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ContestParticipantUpdateOneRequiredWithoutPhotosNestedInput
    votes?: VoteUpdateManyWithoutPhotoNestedInput
    photo?: UserPhotoUpdateOneRequiredWithoutContestUploadNestedInput
    comments?: CommentUpdateManyWithoutReceiverNestedInput
    achievements?: ContestAchievementUpdateManyWithoutPhotoNestedInput
  }

  export type ContestPhotoUncheckedUpdateWithoutContestWinnerInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    promoted?: BoolFieldUpdateOperationsInput | boolean
    promotionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutPhotoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutReceiverNestedInput
    achievements?: ContestAchievementUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type ContestCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    mode?: $Enums.ContestMode
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: ContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedContestsInput
    teamParticipations?: TeamParticipationCreateNestedManyWithoutContestInput
    votes?: VoteCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeCreateNestedManyWithoutContestInput
    achievements?: ContestAchievementCreateNestedManyWithoutContestInput
  }

  export type ContestUncheckedCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    mode?: $Enums.ContestMode
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: ContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teamParticipations?: TeamParticipationUncheckedCreateNestedManyWithoutContestInput
    votes?: VoteUncheckedCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleUncheckedCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeUncheckedCreateNestedManyWithoutContestInput
    achievements?: ContestAchievementUncheckedCreateNestedManyWithoutContestInput
  }

  export type ContestCreateOrConnectWithoutParticipantsInput = {
    where: ContestWhereUniqueInput
    create: XOR<ContestCreateWithoutParticipantsInput, ContestUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutContestParticipantInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    store?: UserStoreCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutContestParticipantInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    store?: UserStoreUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutContestParticipantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContestParticipantInput, UserUncheckedCreateWithoutContestParticipantInput>
  }

  export type TeamMemberCreateWithoutContestParticipantInput = {
    id?: string
    status?: $Enums.TeamMemberStatus
    level?: $Enums.MemberLevel
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
    member: UserCreateNestedOneWithoutJoinedTeamInput
  }

  export type TeamMemberUncheckedCreateWithoutContestParticipantInput = {
    id?: string
    status?: $Enums.TeamMemberStatus
    level?: $Enums.MemberLevel
    teamId: string
    memberId: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutContestParticipantInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutContestParticipantInput, TeamMemberUncheckedCreateWithoutContestParticipantInput>
  }

  export type ContestPhotoCreateWithoutParticipantInput = {
    id?: string
    title?: string | null
    contestId: string
    rank?: number | null
    promoted?: boolean
    promotionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: VoteCreateNestedManyWithoutPhotoInput
    photo: UserPhotoCreateNestedOneWithoutContestUploadInput
    comments?: CommentCreateNestedManyWithoutReceiverInput
    achievements?: ContestAchievementCreateNestedManyWithoutPhotoInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoUncheckedCreateWithoutParticipantInput = {
    id?: string
    title?: string | null
    contestId: string
    photoId: string
    rank?: number | null
    promoted?: boolean
    promotionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutPhotoInput
    comments?: CommentUncheckedCreateNestedManyWithoutReceiverInput
    achievements?: ContestAchievementUncheckedCreateNestedManyWithoutPhotoInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoCreateOrConnectWithoutParticipantInput = {
    where: ContestPhotoWhereUniqueInput
    create: XOR<ContestPhotoCreateWithoutParticipantInput, ContestPhotoUncheckedCreateWithoutParticipantInput>
  }

  export type ContestPhotoCreateManyParticipantInputEnvelope = {
    data: ContestPhotoCreateManyParticipantInput | ContestPhotoCreateManyParticipantInput[]
  }

  export type ContestWinnerCreateWithoutParticipantInput = {
    id?: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    photo: ContestPhotoCreateNestedOneWithoutContestWinnerInput
  }

  export type ContestWinnerUncheckedCreateWithoutParticipantInput = {
    id?: string
    contestId: string
    contestPhotoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestWinnerCreateOrConnectWithoutParticipantInput = {
    where: ContestWinnerWhereUniqueInput
    create: XOR<ContestWinnerCreateWithoutParticipantInput, ContestWinnerUncheckedCreateWithoutParticipantInput>
  }

  export type ContestWinnerCreateManyParticipantInputEnvelope = {
    data: ContestWinnerCreateManyParticipantInput | ContestWinnerCreateManyParticipantInput[]
  }

  export type ContestAchievementCreateWithoutParticipantInput = {
    id?: string
    category: $Enums.PrizeType
    createdAt?: Date | string
    updatedAt?: Date | string
    photo?: ContestPhotoCreateNestedOneWithoutAchievementsInput
    contest: ContestCreateNestedOneWithoutAchievementsInput
  }

  export type ContestAchievementUncheckedCreateWithoutParticipantInput = {
    id?: string
    category: $Enums.PrizeType
    photoId?: string | null
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestAchievementCreateOrConnectWithoutParticipantInput = {
    where: ContestAchievementWhereUniqueInput
    create: XOR<ContestAchievementCreateWithoutParticipantInput, ContestAchievementUncheckedCreateWithoutParticipantInput>
  }

  export type ContestAchievementCreateManyParticipantInputEnvelope = {
    data: ContestAchievementCreateManyParticipantInput | ContestAchievementCreateManyParticipantInput[]
  }

  export type ContestUpsertWithoutParticipantsInput = {
    update: XOR<ContestUpdateWithoutParticipantsInput, ContestUncheckedUpdateWithoutParticipantsInput>
    create: XOR<ContestCreateWithoutParticipantsInput, ContestUncheckedCreateWithoutParticipantsInput>
    where?: ContestWhereInput
  }

  export type ContestUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: ContestWhereInput
    data: XOR<ContestUpdateWithoutParticipantsInput, ContestUncheckedUpdateWithoutParticipantsInput>
  }

  export type ContestUpdateWithoutParticipantsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    mode?: EnumContestModeFieldUpdateOperationsInput | $Enums.ContestMode
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: ContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedContestsNestedInput
    teamParticipations?: TeamParticipationUpdateManyWithoutContestNestedInput
    votes?: VoteUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUpdateManyWithoutContestNestedInput
    achievements?: ContestAchievementUpdateManyWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateWithoutParticipantsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    mode?: EnumContestModeFieldUpdateOperationsInput | $Enums.ContestMode
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: ContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamParticipations?: TeamParticipationUncheckedUpdateManyWithoutContestNestedInput
    votes?: VoteUncheckedUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUncheckedUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUncheckedUpdateManyWithoutContestNestedInput
    achievements?: ContestAchievementUncheckedUpdateManyWithoutContestNestedInput
  }

  export type UserUpsertWithoutContestParticipantInput = {
    update: XOR<UserUpdateWithoutContestParticipantInput, UserUncheckedUpdateWithoutContestParticipantInput>
    create: XOR<UserCreateWithoutContestParticipantInput, UserUncheckedCreateWithoutContestParticipantInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContestParticipantInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContestParticipantInput, UserUncheckedUpdateWithoutContestParticipantInput>
  }

  export type UserUpdateWithoutContestParticipantInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    store?: UserStoreUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutContestParticipantInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    store?: UserStoreUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type TeamMemberUpsertWithoutContestParticipantInput = {
    update: XOR<TeamMemberUpdateWithoutContestParticipantInput, TeamMemberUncheckedUpdateWithoutContestParticipantInput>
    create: XOR<TeamMemberCreateWithoutContestParticipantInput, TeamMemberUncheckedCreateWithoutContestParticipantInput>
    where?: TeamMemberWhereInput
  }

  export type TeamMemberUpdateToOneWithWhereWithoutContestParticipantInput = {
    where?: TeamMemberWhereInput
    data: XOR<TeamMemberUpdateWithoutContestParticipantInput, TeamMemberUncheckedUpdateWithoutContestParticipantInput>
  }

  export type TeamMemberUpdateWithoutContestParticipantInput = {
    status?: EnumTeamMemberStatusFieldUpdateOperationsInput | $Enums.TeamMemberStatus
    level?: EnumMemberLevelFieldUpdateOperationsInput | $Enums.MemberLevel
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
    member?: UserUpdateOneRequiredWithoutJoinedTeamNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutContestParticipantInput = {
    status?: EnumTeamMemberStatusFieldUpdateOperationsInput | $Enums.TeamMemberStatus
    level?: EnumMemberLevelFieldUpdateOperationsInput | $Enums.MemberLevel
    teamId?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestPhotoUpsertWithWhereUniqueWithoutParticipantInput = {
    where: ContestPhotoWhereUniqueInput
    update: XOR<ContestPhotoUpdateWithoutParticipantInput, ContestPhotoUncheckedUpdateWithoutParticipantInput>
    create: XOR<ContestPhotoCreateWithoutParticipantInput, ContestPhotoUncheckedCreateWithoutParticipantInput>
  }

  export type ContestPhotoUpdateWithWhereUniqueWithoutParticipantInput = {
    where: ContestPhotoWhereUniqueInput
    data: XOR<ContestPhotoUpdateWithoutParticipantInput, ContestPhotoUncheckedUpdateWithoutParticipantInput>
  }

  export type ContestPhotoUpdateManyWithWhereWithoutParticipantInput = {
    where: ContestPhotoScalarWhereInput
    data: XOR<ContestPhotoUpdateManyMutationInput, ContestPhotoUncheckedUpdateManyWithoutParticipantInput>
  }

  export type ContestPhotoScalarWhereInput = {
    AND?: ContestPhotoScalarWhereInput | ContestPhotoScalarWhereInput[]
    OR?: ContestPhotoScalarWhereInput[]
    NOT?: ContestPhotoScalarWhereInput | ContestPhotoScalarWhereInput[]
    id?: StringFilter<"ContestPhoto"> | string
    title?: StringNullableFilter<"ContestPhoto"> | string | null
    contestId?: StringFilter<"ContestPhoto"> | string
    participantId?: StringFilter<"ContestPhoto"> | string
    photoId?: StringFilter<"ContestPhoto"> | string
    rank?: IntNullableFilter<"ContestPhoto"> | number | null
    promoted?: BoolFilter<"ContestPhoto"> | boolean
    promotionExpiresAt?: DateTimeNullableFilter<"ContestPhoto"> | Date | string | null
    createdAt?: DateTimeFilter<"ContestPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"ContestPhoto"> | Date | string
  }

  export type ContestWinnerUpsertWithWhereUniqueWithoutParticipantInput = {
    where: ContestWinnerWhereUniqueInput
    update: XOR<ContestWinnerUpdateWithoutParticipantInput, ContestWinnerUncheckedUpdateWithoutParticipantInput>
    create: XOR<ContestWinnerCreateWithoutParticipantInput, ContestWinnerUncheckedCreateWithoutParticipantInput>
  }

  export type ContestWinnerUpdateWithWhereUniqueWithoutParticipantInput = {
    where: ContestWinnerWhereUniqueInput
    data: XOR<ContestWinnerUpdateWithoutParticipantInput, ContestWinnerUncheckedUpdateWithoutParticipantInput>
  }

  export type ContestWinnerUpdateManyWithWhereWithoutParticipantInput = {
    where: ContestWinnerScalarWhereInput
    data: XOR<ContestWinnerUpdateManyMutationInput, ContestWinnerUncheckedUpdateManyWithoutParticipantInput>
  }

  export type ContestAchievementUpsertWithWhereUniqueWithoutParticipantInput = {
    where: ContestAchievementWhereUniqueInput
    update: XOR<ContestAchievementUpdateWithoutParticipantInput, ContestAchievementUncheckedUpdateWithoutParticipantInput>
    create: XOR<ContestAchievementCreateWithoutParticipantInput, ContestAchievementUncheckedCreateWithoutParticipantInput>
  }

  export type ContestAchievementUpdateWithWhereUniqueWithoutParticipantInput = {
    where: ContestAchievementWhereUniqueInput
    data: XOR<ContestAchievementUpdateWithoutParticipantInput, ContestAchievementUncheckedUpdateWithoutParticipantInput>
  }

  export type ContestAchievementUpdateManyWithWhereWithoutParticipantInput = {
    where: ContestAchievementScalarWhereInput
    data: XOR<ContestAchievementUpdateManyMutationInput, ContestAchievementUncheckedUpdateManyWithoutParticipantInput>
  }

  export type ContestCreateWithoutContestPrizesInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    mode?: $Enums.ContestMode
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: ContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedContestsInput
    participants?: ContestParticipantCreateNestedManyWithoutContestInput
    teamParticipations?: TeamParticipationCreateNestedManyWithoutContestInput
    votes?: VoteCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleCreateNestedManyWithoutContestInput
    achievements?: ContestAchievementCreateNestedManyWithoutContestInput
  }

  export type ContestUncheckedCreateWithoutContestPrizesInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    mode?: $Enums.ContestMode
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: ContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ContestParticipantUncheckedCreateNestedManyWithoutContestInput
    teamParticipations?: TeamParticipationUncheckedCreateNestedManyWithoutContestInput
    votes?: VoteUncheckedCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleUncheckedCreateNestedManyWithoutContestInput
    achievements?: ContestAchievementUncheckedCreateNestedManyWithoutContestInput
  }

  export type ContestCreateOrConnectWithoutContestPrizesInput = {
    where: ContestWhereUniqueInput
    create: XOR<ContestCreateWithoutContestPrizesInput, ContestUncheckedCreateWithoutContestPrizesInput>
  }

  export type ContestUpsertWithoutContestPrizesInput = {
    update: XOR<ContestUpdateWithoutContestPrizesInput, ContestUncheckedUpdateWithoutContestPrizesInput>
    create: XOR<ContestCreateWithoutContestPrizesInput, ContestUncheckedCreateWithoutContestPrizesInput>
    where?: ContestWhereInput
  }

  export type ContestUpdateToOneWithWhereWithoutContestPrizesInput = {
    where?: ContestWhereInput
    data: XOR<ContestUpdateWithoutContestPrizesInput, ContestUncheckedUpdateWithoutContestPrizesInput>
  }

  export type ContestUpdateWithoutContestPrizesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    mode?: EnumContestModeFieldUpdateOperationsInput | $Enums.ContestMode
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: ContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedContestsNestedInput
    participants?: ContestParticipantUpdateManyWithoutContestNestedInput
    teamParticipations?: TeamParticipationUpdateManyWithoutContestNestedInput
    votes?: VoteUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUpdateManyWithoutContestNestedInput
    achievements?: ContestAchievementUpdateManyWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateWithoutContestPrizesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    mode?: EnumContestModeFieldUpdateOperationsInput | $Enums.ContestMode
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: ContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ContestParticipantUncheckedUpdateManyWithoutContestNestedInput
    teamParticipations?: TeamParticipationUncheckedUpdateManyWithoutContestNestedInput
    votes?: VoteUncheckedUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUncheckedUpdateManyWithoutContestNestedInput
    achievements?: ContestAchievementUncheckedUpdateManyWithoutContestNestedInput
  }

  export type ContestPhotoCreateWithoutAchievementsInput = {
    id?: string
    title?: string | null
    contestId: string
    rank?: number | null
    promoted?: boolean
    promotionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participant: ContestParticipantCreateNestedOneWithoutPhotosInput
    votes?: VoteCreateNestedManyWithoutPhotoInput
    photo: UserPhotoCreateNestedOneWithoutContestUploadInput
    comments?: CommentCreateNestedManyWithoutReceiverInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoUncheckedCreateWithoutAchievementsInput = {
    id?: string
    title?: string | null
    contestId: string
    participantId: string
    photoId: string
    rank?: number | null
    promoted?: boolean
    promotionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutPhotoInput
    comments?: CommentUncheckedCreateNestedManyWithoutReceiverInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoCreateOrConnectWithoutAchievementsInput = {
    where: ContestPhotoWhereUniqueInput
    create: XOR<ContestPhotoCreateWithoutAchievementsInput, ContestPhotoUncheckedCreateWithoutAchievementsInput>
  }

  export type ContestCreateWithoutAchievementsInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    mode?: $Enums.ContestMode
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: ContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedContestsInput
    participants?: ContestParticipantCreateNestedManyWithoutContestInput
    teamParticipations?: TeamParticipationCreateNestedManyWithoutContestInput
    votes?: VoteCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeCreateNestedManyWithoutContestInput
  }

  export type ContestUncheckedCreateWithoutAchievementsInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    mode?: $Enums.ContestMode
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: ContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ContestParticipantUncheckedCreateNestedManyWithoutContestInput
    teamParticipations?: TeamParticipationUncheckedCreateNestedManyWithoutContestInput
    votes?: VoteUncheckedCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleUncheckedCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeUncheckedCreateNestedManyWithoutContestInput
  }

  export type ContestCreateOrConnectWithoutAchievementsInput = {
    where: ContestWhereUniqueInput
    create: XOR<ContestCreateWithoutAchievementsInput, ContestUncheckedCreateWithoutAchievementsInput>
  }

  export type ContestParticipantCreateWithoutContestAchievementInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    level?: $Enums.YCLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contest: ContestCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutContestParticipantInput
    member?: TeamMemberCreateNestedOneWithoutContestParticipantInput
    photos?: ContestPhotoCreateNestedManyWithoutParticipantInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantUncheckedCreateWithoutContestAchievementInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    contestId: string
    userId: string
    memberId?: string | null
    level?: $Enums.YCLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ContestPhotoUncheckedCreateNestedManyWithoutParticipantInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantCreateOrConnectWithoutContestAchievementInput = {
    where: ContestParticipantWhereUniqueInput
    create: XOR<ContestParticipantCreateWithoutContestAchievementInput, ContestParticipantUncheckedCreateWithoutContestAchievementInput>
  }

  export type ContestPhotoUpsertWithoutAchievementsInput = {
    update: XOR<ContestPhotoUpdateWithoutAchievementsInput, ContestPhotoUncheckedUpdateWithoutAchievementsInput>
    create: XOR<ContestPhotoCreateWithoutAchievementsInput, ContestPhotoUncheckedCreateWithoutAchievementsInput>
    where?: ContestPhotoWhereInput
  }

  export type ContestPhotoUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: ContestPhotoWhereInput
    data: XOR<ContestPhotoUpdateWithoutAchievementsInput, ContestPhotoUncheckedUpdateWithoutAchievementsInput>
  }

  export type ContestPhotoUpdateWithoutAchievementsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    promoted?: BoolFieldUpdateOperationsInput | boolean
    promotionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ContestParticipantUpdateOneRequiredWithoutPhotosNestedInput
    votes?: VoteUpdateManyWithoutPhotoNestedInput
    photo?: UserPhotoUpdateOneRequiredWithoutContestUploadNestedInput
    comments?: CommentUpdateManyWithoutReceiverNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutPhotoNestedInput
  }

  export type ContestPhotoUncheckedUpdateWithoutAchievementsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    promoted?: BoolFieldUpdateOperationsInput | boolean
    promotionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutPhotoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutReceiverNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type ContestUpsertWithoutAchievementsInput = {
    update: XOR<ContestUpdateWithoutAchievementsInput, ContestUncheckedUpdateWithoutAchievementsInput>
    create: XOR<ContestCreateWithoutAchievementsInput, ContestUncheckedCreateWithoutAchievementsInput>
    where?: ContestWhereInput
  }

  export type ContestUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: ContestWhereInput
    data: XOR<ContestUpdateWithoutAchievementsInput, ContestUncheckedUpdateWithoutAchievementsInput>
  }

  export type ContestUpdateWithoutAchievementsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    mode?: EnumContestModeFieldUpdateOperationsInput | $Enums.ContestMode
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: ContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedContestsNestedInput
    participants?: ContestParticipantUpdateManyWithoutContestNestedInput
    teamParticipations?: TeamParticipationUpdateManyWithoutContestNestedInput
    votes?: VoteUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUpdateManyWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateWithoutAchievementsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    mode?: EnumContestModeFieldUpdateOperationsInput | $Enums.ContestMode
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: ContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ContestParticipantUncheckedUpdateManyWithoutContestNestedInput
    teamParticipations?: TeamParticipationUncheckedUpdateManyWithoutContestNestedInput
    votes?: VoteUncheckedUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUncheckedUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUncheckedUpdateManyWithoutContestNestedInput
  }

  export type ContestParticipantUpsertWithoutContestAchievementInput = {
    update: XOR<ContestParticipantUpdateWithoutContestAchievementInput, ContestParticipantUncheckedUpdateWithoutContestAchievementInput>
    create: XOR<ContestParticipantCreateWithoutContestAchievementInput, ContestParticipantUncheckedCreateWithoutContestAchievementInput>
    where?: ContestParticipantWhereInput
  }

  export type ContestParticipantUpdateToOneWithWhereWithoutContestAchievementInput = {
    where?: ContestParticipantWhereInput
    data: XOR<ContestParticipantUpdateWithoutContestAchievementInput, ContestParticipantUncheckedUpdateWithoutContestAchievementInput>
  }

  export type ContestParticipantUpdateWithoutContestAchievementInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    level?: EnumYCLevelFieldUpdateOperationsInput | $Enums.YCLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contest?: ContestUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutContestParticipantNestedInput
    member?: TeamMemberUpdateOneWithoutContestParticipantNestedInput
    photos?: ContestPhotoUpdateManyWithoutParticipantNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutParticipantNestedInput
  }

  export type ContestParticipantUncheckedUpdateWithoutContestAchievementInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    contestId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumYCLevelFieldUpdateOperationsInput | $Enums.YCLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ContestPhotoUncheckedUpdateManyWithoutParticipantNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type TeamCreateWithoutChatInput = {
    id?: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility?: $Enums.TeamAccessibility
    score?: number
    win?: number
    lost?: number
    badge: string
    min_requirement: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedTeamInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    participations?: TeamParticipationCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutChatInput = {
    id?: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility?: $Enums.TeamAccessibility
    score?: number
    win?: number
    lost?: number
    badge: string
    min_requirement: number
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    participations?: TeamParticipationUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutChatInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutChatInput, TeamUncheckedCreateWithoutChatInput>
  }

  export type UserCreateWithoutChatInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    store?: UserStoreCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChatInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    store?: UserStoreUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatInput, UserUncheckedCreateWithoutChatInput>
  }

  export type TeamUpsertWithoutChatInput = {
    update: XOR<TeamUpdateWithoutChatInput, TeamUncheckedUpdateWithoutChatInput>
    create: XOR<TeamCreateWithoutChatInput, TeamUncheckedCreateWithoutChatInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutChatInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutChatInput, TeamUncheckedUpdateWithoutChatInput>
  }

  export type TeamUpdateWithoutChatInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    score?: IntFieldUpdateOperationsInput | number
    win?: IntFieldUpdateOperationsInput | number
    lost?: IntFieldUpdateOperationsInput | number
    badge?: StringFieldUpdateOperationsInput | string
    min_requirement?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedTeamNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    participations?: TeamParticipationUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutChatInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    score?: IntFieldUpdateOperationsInput | number
    win?: IntFieldUpdateOperationsInput | number
    lost?: IntFieldUpdateOperationsInput | number
    badge?: StringFieldUpdateOperationsInput | string
    min_requirement?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    participations?: TeamParticipationUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutChatInput = {
    update: XOR<UserUpdateWithoutChatInput, UserUncheckedUpdateWithoutChatInput>
    create: XOR<UserCreateWithoutChatInput, UserUncheckedCreateWithoutChatInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatInput, UserUncheckedUpdateWithoutChatInput>
  }

  export type UserUpdateWithoutChatInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    store?: UserStoreUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChatInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    store?: UserStoreUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCreatedTeamInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    store?: UserStoreCreateNestedOneWithoutUserInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutCreatedTeamInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    store?: UserStoreUncheckedCreateNestedOneWithoutUserInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutCreatedTeamInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTeamInput, UserUncheckedCreateWithoutCreatedTeamInput>
  }

  export type TeamMemberCreateWithoutTeamInput = {
    id?: string
    status?: $Enums.TeamMemberStatus
    level?: $Enums.MemberLevel
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    member: UserCreateNestedOneWithoutJoinedTeamInput
    contestParticipant?: ContestParticipantCreateNestedManyWithoutMemberInput
  }

  export type TeamMemberUncheckedCreateWithoutTeamInput = {
    id?: string
    status?: $Enums.TeamMemberStatus
    level?: $Enums.MemberLevel
    memberId: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutMemberInput
  }

  export type TeamMemberCreateOrConnectWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberCreateManyTeamInputEnvelope = {
    data: TeamMemberCreateManyTeamInput | TeamMemberCreateManyTeamInput[]
  }

  export type ChatCreateWithoutTeamInput = {
    id?: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutTeamInput = {
    id?: string
    senderId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatCreateOrConnectWithoutTeamInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutTeamInput, ChatUncheckedCreateWithoutTeamInput>
  }

  export type ChatCreateManyTeamInputEnvelope = {
    data: ChatCreateManyTeamInput | ChatCreateManyTeamInput[]
  }

  export type TeamParticipationCreateWithoutTeamInput = {
    id?: string
    contest: ContestCreateNestedOneWithoutTeamParticipationsInput
  }

  export type TeamParticipationUncheckedCreateWithoutTeamInput = {
    id?: string
    contestId: string
  }

  export type TeamParticipationCreateOrConnectWithoutTeamInput = {
    where: TeamParticipationWhereUniqueInput
    create: XOR<TeamParticipationCreateWithoutTeamInput, TeamParticipationUncheckedCreateWithoutTeamInput>
  }

  export type TeamParticipationCreateManyTeamInputEnvelope = {
    data: TeamParticipationCreateManyTeamInput | TeamParticipationCreateManyTeamInput[]
  }

  export type UserUpsertWithoutCreatedTeamInput = {
    update: XOR<UserUpdateWithoutCreatedTeamInput, UserUncheckedUpdateWithoutCreatedTeamInput>
    create: XOR<UserCreateWithoutCreatedTeamInput, UserUncheckedCreateWithoutCreatedTeamInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTeamInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTeamInput, UserUncheckedUpdateWithoutCreatedTeamInput>
  }

  export type UserUpdateWithoutCreatedTeamInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    store?: UserStoreUpdateOneWithoutUserNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTeamInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    store?: UserStoreUncheckedUpdateOneWithoutUserNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamMemberScalarWhereInput = {
    AND?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    OR?: TeamMemberScalarWhereInput[]
    NOT?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    status?: EnumTeamMemberStatusFilter<"TeamMember"> | $Enums.TeamMemberStatus
    level?: EnumMemberLevelFilter<"TeamMember"> | $Enums.MemberLevel
    teamId?: StringFilter<"TeamMember"> | string
    memberId?: StringFilter<"TeamMember"> | string
    contestId?: StringFilter<"TeamMember"> | string
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"TeamMember"> | Date | string
  }

  export type ChatUpsertWithWhereUniqueWithoutTeamInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutTeamInput, ChatUncheckedUpdateWithoutTeamInput>
    create: XOR<ChatCreateWithoutTeamInput, ChatUncheckedCreateWithoutTeamInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutTeamInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutTeamInput, ChatUncheckedUpdateWithoutTeamInput>
  }

  export type ChatUpdateManyWithWhereWithoutTeamInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutTeamInput>
  }

  export type ChatScalarWhereInput = {
    AND?: ChatScalarWhereInput | ChatScalarWhereInput[]
    OR?: ChatScalarWhereInput[]
    NOT?: ChatScalarWhereInput | ChatScalarWhereInput[]
    id?: StringFilter<"Chat"> | string
    teamId?: StringFilter<"Chat"> | string
    senderId?: StringFilter<"Chat"> | string
    message?: StringFilter<"Chat"> | string
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
  }

  export type TeamParticipationUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamParticipationWhereUniqueInput
    update: XOR<TeamParticipationUpdateWithoutTeamInput, TeamParticipationUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamParticipationCreateWithoutTeamInput, TeamParticipationUncheckedCreateWithoutTeamInput>
  }

  export type TeamParticipationUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamParticipationWhereUniqueInput
    data: XOR<TeamParticipationUpdateWithoutTeamInput, TeamParticipationUncheckedUpdateWithoutTeamInput>
  }

  export type TeamParticipationUpdateManyWithWhereWithoutTeamInput = {
    where: TeamParticipationScalarWhereInput
    data: XOR<TeamParticipationUpdateManyMutationInput, TeamParticipationUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamCreateWithoutMembersInput = {
    id?: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility?: $Enums.TeamAccessibility
    score?: number
    win?: number
    lost?: number
    badge: string
    min_requirement: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedTeamInput
    chat?: ChatCreateNestedManyWithoutTeamInput
    participations?: TeamParticipationCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility?: $Enums.TeamAccessibility
    score?: number
    win?: number
    lost?: number
    badge: string
    min_requirement: number
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chat?: ChatUncheckedCreateNestedManyWithoutTeamInput
    participations?: TeamParticipationUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutMembersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutJoinedTeamInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    store?: UserStoreCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutJoinedTeamInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    store?: UserStoreUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutJoinedTeamInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJoinedTeamInput, UserUncheckedCreateWithoutJoinedTeamInput>
  }

  export type ContestParticipantCreateWithoutMemberInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    level?: $Enums.YCLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contest: ContestCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutContestParticipantInput
    photos?: ContestPhotoCreateNestedManyWithoutParticipantInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantUncheckedCreateWithoutMemberInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    contestId: string
    userId: string
    level?: $Enums.YCLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ContestPhotoUncheckedCreateNestedManyWithoutParticipantInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantCreateOrConnectWithoutMemberInput = {
    where: ContestParticipantWhereUniqueInput
    create: XOR<ContestParticipantCreateWithoutMemberInput, ContestParticipantUncheckedCreateWithoutMemberInput>
  }

  export type ContestParticipantCreateManyMemberInputEnvelope = {
    data: ContestParticipantCreateManyMemberInput | ContestParticipantCreateManyMemberInput[]
  }

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type TeamUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    score?: IntFieldUpdateOperationsInput | number
    win?: IntFieldUpdateOperationsInput | number
    lost?: IntFieldUpdateOperationsInput | number
    badge?: StringFieldUpdateOperationsInput | string
    min_requirement?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedTeamNestedInput
    chat?: ChatUpdateManyWithoutTeamNestedInput
    participations?: TeamParticipationUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    score?: IntFieldUpdateOperationsInput | number
    win?: IntFieldUpdateOperationsInput | number
    lost?: IntFieldUpdateOperationsInput | number
    badge?: StringFieldUpdateOperationsInput | string
    min_requirement?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUncheckedUpdateManyWithoutTeamNestedInput
    participations?: TeamParticipationUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutJoinedTeamInput = {
    update: XOR<UserUpdateWithoutJoinedTeamInput, UserUncheckedUpdateWithoutJoinedTeamInput>
    create: XOR<UserCreateWithoutJoinedTeamInput, UserUncheckedCreateWithoutJoinedTeamInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJoinedTeamInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJoinedTeamInput, UserUncheckedUpdateWithoutJoinedTeamInput>
  }

  export type UserUpdateWithoutJoinedTeamInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    store?: UserStoreUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutJoinedTeamInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    store?: UserStoreUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type ContestParticipantUpsertWithWhereUniqueWithoutMemberInput = {
    where: ContestParticipantWhereUniqueInput
    update: XOR<ContestParticipantUpdateWithoutMemberInput, ContestParticipantUncheckedUpdateWithoutMemberInput>
    create: XOR<ContestParticipantCreateWithoutMemberInput, ContestParticipantUncheckedCreateWithoutMemberInput>
  }

  export type ContestParticipantUpdateWithWhereUniqueWithoutMemberInput = {
    where: ContestParticipantWhereUniqueInput
    data: XOR<ContestParticipantUpdateWithoutMemberInput, ContestParticipantUncheckedUpdateWithoutMemberInput>
  }

  export type ContestParticipantUpdateManyWithWhereWithoutMemberInput = {
    where: ContestParticipantScalarWhereInput
    data: XOR<ContestParticipantUpdateManyMutationInput, ContestParticipantUncheckedUpdateManyWithoutMemberInput>
  }

  export type TeamCreateWithoutParticipationsInput = {
    id?: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility?: $Enums.TeamAccessibility
    score?: number
    win?: number
    lost?: number
    badge: string
    min_requirement: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedTeamInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    chat?: ChatCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutParticipationsInput = {
    id?: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility?: $Enums.TeamAccessibility
    score?: number
    win?: number
    lost?: number
    badge: string
    min_requirement: number
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    chat?: ChatUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutParticipationsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutParticipationsInput, TeamUncheckedCreateWithoutParticipationsInput>
  }

  export type ContestCreateWithoutTeamParticipationsInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    mode?: $Enums.ContestMode
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: ContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedContestsInput
    participants?: ContestParticipantCreateNestedManyWithoutContestInput
    votes?: VoteCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeCreateNestedManyWithoutContestInput
    achievements?: ContestAchievementCreateNestedManyWithoutContestInput
  }

  export type ContestUncheckedCreateWithoutTeamParticipationsInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    mode?: $Enums.ContestMode
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: ContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ContestParticipantUncheckedCreateNestedManyWithoutContestInput
    votes?: VoteUncheckedCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleUncheckedCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeUncheckedCreateNestedManyWithoutContestInput
    achievements?: ContestAchievementUncheckedCreateNestedManyWithoutContestInput
  }

  export type ContestCreateOrConnectWithoutTeamParticipationsInput = {
    where: ContestWhereUniqueInput
    create: XOR<ContestCreateWithoutTeamParticipationsInput, ContestUncheckedCreateWithoutTeamParticipationsInput>
  }

  export type TeamUpsertWithoutParticipationsInput = {
    update: XOR<TeamUpdateWithoutParticipationsInput, TeamUncheckedUpdateWithoutParticipationsInput>
    create: XOR<TeamCreateWithoutParticipationsInput, TeamUncheckedCreateWithoutParticipationsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutParticipationsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutParticipationsInput, TeamUncheckedUpdateWithoutParticipationsInput>
  }

  export type TeamUpdateWithoutParticipationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    score?: IntFieldUpdateOperationsInput | number
    win?: IntFieldUpdateOperationsInput | number
    lost?: IntFieldUpdateOperationsInput | number
    badge?: StringFieldUpdateOperationsInput | string
    min_requirement?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedTeamNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    chat?: ChatUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutParticipationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    score?: IntFieldUpdateOperationsInput | number
    win?: IntFieldUpdateOperationsInput | number
    lost?: IntFieldUpdateOperationsInput | number
    badge?: StringFieldUpdateOperationsInput | string
    min_requirement?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    chat?: ChatUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type ContestUpsertWithoutTeamParticipationsInput = {
    update: XOR<ContestUpdateWithoutTeamParticipationsInput, ContestUncheckedUpdateWithoutTeamParticipationsInput>
    create: XOR<ContestCreateWithoutTeamParticipationsInput, ContestUncheckedCreateWithoutTeamParticipationsInput>
    where?: ContestWhereInput
  }

  export type ContestUpdateToOneWithWhereWithoutTeamParticipationsInput = {
    where?: ContestWhereInput
    data: XOR<ContestUpdateWithoutTeamParticipationsInput, ContestUncheckedUpdateWithoutTeamParticipationsInput>
  }

  export type ContestUpdateWithoutTeamParticipationsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    mode?: EnumContestModeFieldUpdateOperationsInput | $Enums.ContestMode
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: ContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedContestsNestedInput
    participants?: ContestParticipantUpdateManyWithoutContestNestedInput
    votes?: VoteUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUpdateManyWithoutContestNestedInput
    achievements?: ContestAchievementUpdateManyWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateWithoutTeamParticipationsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    mode?: EnumContestModeFieldUpdateOperationsInput | $Enums.ContestMode
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: ContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ContestParticipantUncheckedUpdateManyWithoutContestNestedInput
    votes?: VoteUncheckedUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUncheckedUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUncheckedUpdateManyWithoutContestNestedInput
    achievements?: ContestAchievementUncheckedUpdateManyWithoutContestNestedInput
  }

  export type OtpCreateWithoutUserInput = {
    id?: string
    code: string
    expires_in: Date | string
    otpStatus?: $Enums.OtpStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
  }

  export type OtpUncheckedCreateWithoutUserInput = {
    id?: string
    code: string
    expires_in: Date | string
    otpStatus?: $Enums.OtpStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
  }

  export type OtpCreateOrConnectWithoutUserInput = {
    where: OtpWhereUniqueInput
    create: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput>
  }

  export type UserStoreCreateWithoutUserInput = {
    id?: string
    promotes?: number
    trades?: number
    charges?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserStoreUncheckedCreateWithoutUserInput = {
    id?: string
    promotes?: number
    trades?: number
    charges?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserStoreCreateOrConnectWithoutUserInput = {
    where: UserStoreWhereUniqueInput
    create: XOR<UserStoreCreateWithoutUserInput, UserStoreUncheckedCreateWithoutUserInput>
  }

  export type TeamCreateWithoutCreatorInput = {
    id?: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility?: $Enums.TeamAccessibility
    score?: number
    win?: number
    lost?: number
    badge: string
    min_requirement: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    chat?: ChatCreateNestedManyWithoutTeamInput
    participations?: TeamParticipationCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility?: $Enums.TeamAccessibility
    score?: number
    win?: number
    lost?: number
    badge: string
    min_requirement: number
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    chat?: ChatUncheckedCreateNestedManyWithoutTeamInput
    participations?: TeamParticipationUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutCreatorInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutCreatorInput, TeamUncheckedCreateWithoutCreatorInput>
  }

  export type TeamCreateManyCreatorInputEnvelope = {
    data: TeamCreateManyCreatorInput | TeamCreateManyCreatorInput[]
  }

  export type TeamMemberCreateWithoutMemberInput = {
    id?: string
    status?: $Enums.TeamMemberStatus
    level?: $Enums.MemberLevel
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
    contestParticipant?: ContestParticipantCreateNestedManyWithoutMemberInput
  }

  export type TeamMemberUncheckedCreateWithoutMemberInput = {
    id?: string
    status?: $Enums.TeamMemberStatus
    level?: $Enums.MemberLevel
    teamId: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutMemberInput
  }

  export type TeamMemberCreateOrConnectWithoutMemberInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutMemberInput, TeamMemberUncheckedCreateWithoutMemberInput>
  }

  export type ContestCreateWithoutCreatorInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    mode?: $Enums.ContestMode
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: ContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ContestParticipantCreateNestedManyWithoutContestInput
    teamParticipations?: TeamParticipationCreateNestedManyWithoutContestInput
    votes?: VoteCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeCreateNestedManyWithoutContestInput
    achievements?: ContestAchievementCreateNestedManyWithoutContestInput
  }

  export type ContestUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    mode?: $Enums.ContestMode
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: ContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ContestParticipantUncheckedCreateNestedManyWithoutContestInput
    teamParticipations?: TeamParticipationUncheckedCreateNestedManyWithoutContestInput
    votes?: VoteUncheckedCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleUncheckedCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeUncheckedCreateNestedManyWithoutContestInput
    achievements?: ContestAchievementUncheckedCreateNestedManyWithoutContestInput
  }

  export type ContestCreateOrConnectWithoutCreatorInput = {
    where: ContestWhereUniqueInput
    create: XOR<ContestCreateWithoutCreatorInput, ContestUncheckedCreateWithoutCreatorInput>
  }

  export type ContestCreateManyCreatorInputEnvelope = {
    data: ContestCreateManyCreatorInput | ContestCreateManyCreatorInput[]
  }

  export type CommentCreateWithoutProviderInput = {
    id?: string
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: ContestPhotoCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutCommentRepliesInput
    CommentReplies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutProviderInput = {
    id?: string
    text: string
    receiverId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CommentReplies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutProviderInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutProviderInput, CommentUncheckedCreateWithoutProviderInput>
  }

  export type CommentCreateManyProviderInputEnvelope = {
    data: CommentCreateManyProviderInput | CommentCreateManyProviderInput[]
  }

  export type FollowCreateWithoutFollowerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    following: UserCreateNestedOneWithoutFollowingsInput
  }

  export type FollowUncheckedCreateWithoutFollowerInput = {
    id?: string
    followingId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowCreateOrConnectWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowCreateManyFollowerInputEnvelope = {
    data: FollowCreateManyFollowerInput | FollowCreateManyFollowerInput[]
  }

  export type FollowCreateWithoutFollowingInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowersInput
  }

  export type FollowUncheckedCreateWithoutFollowingInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowCreateOrConnectWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowCreateManyFollowingInputEnvelope = {
    data: FollowCreateManyFollowingInput | FollowCreateManyFollowingInput[]
  }

  export type VoteCreateWithoutProviderInput = {
    id?: string
    type: $Enums.VoteType
    createdAt?: Date | string
    updatedAt?: Date | string
    photo: ContestPhotoCreateNestedOneWithoutVotesInput
    contest: ContestCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateWithoutProviderInput = {
    id?: string
    photoId: string
    contestId: string
    type: $Enums.VoteType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteCreateOrConnectWithoutProviderInput = {
    where: VoteWhereUniqueInput
    create: XOR<VoteCreateWithoutProviderInput, VoteUncheckedCreateWithoutProviderInput>
  }

  export type VoteCreateManyProviderInputEnvelope = {
    data: VoteCreateManyProviderInput | VoteCreateManyProviderInput[]
  }

  export type LikeCreateWithoutProviderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    photo: UserPhotoCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutProviderInput = {
    id?: string
    photoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutProviderInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutProviderInput, LikeUncheckedCreateWithoutProviderInput>
  }

  export type LikeCreateManyProviderInputEnvelope = {
    data: LikeCreateManyProviderInput | LikeCreateManyProviderInput[]
  }

  export type UserPhotoCreateWithoutUserInput = {
    id?: string
    url: string
    states?: XOR<PhotoStatsNullableCreateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: number
    labels?: UserPhotoCreatelabelsInput | string[]
    title?: string | null
    description?: string | null
    adult?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contestUpload?: ContestPhotoCreateNestedManyWithoutPhotoInput
    likes?: LikeCreateNestedManyWithoutPhotoInput
  }

  export type UserPhotoUncheckedCreateWithoutUserInput = {
    id?: string
    url: string
    states?: XOR<PhotoStatsNullableCreateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: number
    labels?: UserPhotoCreatelabelsInput | string[]
    title?: string | null
    description?: string | null
    adult?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contestUpload?: ContestPhotoUncheckedCreateNestedManyWithoutPhotoInput
    likes?: LikeUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type UserPhotoCreateOrConnectWithoutUserInput = {
    where: UserPhotoWhereUniqueInput
    create: XOR<UserPhotoCreateWithoutUserInput, UserPhotoUncheckedCreateWithoutUserInput>
  }

  export type UserPhotoCreateManyUserInputEnvelope = {
    data: UserPhotoCreateManyUserInput | UserPhotoCreateManyUserInput[]
  }

  export type ContestParticipantCreateWithoutUserInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    level?: $Enums.YCLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contest: ContestCreateNestedOneWithoutParticipantsInput
    member?: TeamMemberCreateNestedOneWithoutContestParticipantInput
    photos?: ContestPhotoCreateNestedManyWithoutParticipantInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    contestId: string
    memberId?: string | null
    level?: $Enums.YCLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ContestPhotoUncheckedCreateNestedManyWithoutParticipantInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantCreateOrConnectWithoutUserInput = {
    where: ContestParticipantWhereUniqueInput
    create: XOR<ContestParticipantCreateWithoutUserInput, ContestParticipantUncheckedCreateWithoutUserInput>
  }

  export type ContestParticipantCreateManyUserInputEnvelope = {
    data: ContestParticipantCreateManyUserInput | ContestParticipantCreateManyUserInput[]
  }

  export type ChatCreateWithoutSenderInput = {
    id?: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutSenderInput = {
    id?: string
    teamId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatCreateOrConnectWithoutSenderInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutSenderInput, ChatUncheckedCreateWithoutSenderInput>
  }

  export type ChatCreateManySenderInputEnvelope = {
    data: ChatCreateManySenderInput | ChatCreateManySenderInput[]
  }

  export type OtpUpsertWithoutUserInput = {
    update: XOR<OtpUpdateWithoutUserInput, OtpUncheckedUpdateWithoutUserInput>
    create: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput>
    where?: OtpWhereInput
  }

  export type OtpUpdateToOneWithWhereWithoutUserInput = {
    where?: OtpWhereInput
    data: XOR<OtpUpdateWithoutUserInput, OtpUncheckedUpdateWithoutUserInput>
  }

  export type OtpUpdateWithoutUserInput = {
    code?: StringFieldUpdateOperationsInput | string
    expires_in?: DateTimeFieldUpdateOperationsInput | Date | string
    otpStatus?: EnumOtpStatusFieldUpdateOperationsInput | $Enums.OtpStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUncheckedUpdateWithoutUserInput = {
    code?: StringFieldUpdateOperationsInput | string
    expires_in?: DateTimeFieldUpdateOperationsInput | Date | string
    otpStatus?: EnumOtpStatusFieldUpdateOperationsInput | $Enums.OtpStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStoreUpsertWithoutUserInput = {
    update: XOR<UserStoreUpdateWithoutUserInput, UserStoreUncheckedUpdateWithoutUserInput>
    create: XOR<UserStoreCreateWithoutUserInput, UserStoreUncheckedCreateWithoutUserInput>
    where?: UserStoreWhereInput
  }

  export type UserStoreUpdateToOneWithWhereWithoutUserInput = {
    where?: UserStoreWhereInput
    data: XOR<UserStoreUpdateWithoutUserInput, UserStoreUncheckedUpdateWithoutUserInput>
  }

  export type UserStoreUpdateWithoutUserInput = {
    promotes?: IntFieldUpdateOperationsInput | number
    trades?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStoreUncheckedUpdateWithoutUserInput = {
    promotes?: IntFieldUpdateOperationsInput | number
    trades?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutCreatorInput, TeamUncheckedUpdateWithoutCreatorInput>
    create: XOR<TeamCreateWithoutCreatorInput, TeamUncheckedCreateWithoutCreatorInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutCreatorInput, TeamUncheckedUpdateWithoutCreatorInput>
  }

  export type TeamUpdateManyWithWhereWithoutCreatorInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    level?: StringFilter<"Team"> | string
    language?: StringFilter<"Team"> | string
    country?: StringFilter<"Team"> | string
    description?: StringFilter<"Team"> | string
    accessibility?: EnumTeamAccessibilityFilter<"Team"> | $Enums.TeamAccessibility
    score?: IntFilter<"Team"> | number
    win?: IntFilter<"Team"> | number
    lost?: IntFilter<"Team"> | number
    badge?: StringFilter<"Team"> | string
    min_requirement?: IntFilter<"Team"> | number
    creatorId?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
  }

  export type TeamMemberUpsertWithoutMemberInput = {
    update: XOR<TeamMemberUpdateWithoutMemberInput, TeamMemberUncheckedUpdateWithoutMemberInput>
    create: XOR<TeamMemberCreateWithoutMemberInput, TeamMemberUncheckedCreateWithoutMemberInput>
    where?: TeamMemberWhereInput
  }

  export type TeamMemberUpdateToOneWithWhereWithoutMemberInput = {
    where?: TeamMemberWhereInput
    data: XOR<TeamMemberUpdateWithoutMemberInput, TeamMemberUncheckedUpdateWithoutMemberInput>
  }

  export type TeamMemberUpdateWithoutMemberInput = {
    status?: EnumTeamMemberStatusFieldUpdateOperationsInput | $Enums.TeamMemberStatus
    level?: EnumMemberLevelFieldUpdateOperationsInput | $Enums.MemberLevel
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
    contestParticipant?: ContestParticipantUpdateManyWithoutMemberNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutMemberInput = {
    status?: EnumTeamMemberStatusFieldUpdateOperationsInput | $Enums.TeamMemberStatus
    level?: EnumMemberLevelFieldUpdateOperationsInput | $Enums.MemberLevel
    teamId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contestParticipant?: ContestParticipantUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type ContestUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ContestWhereUniqueInput
    update: XOR<ContestUpdateWithoutCreatorInput, ContestUncheckedUpdateWithoutCreatorInput>
    create: XOR<ContestCreateWithoutCreatorInput, ContestUncheckedCreateWithoutCreatorInput>
  }

  export type ContestUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ContestWhereUniqueInput
    data: XOR<ContestUpdateWithoutCreatorInput, ContestUncheckedUpdateWithoutCreatorInput>
  }

  export type ContestUpdateManyWithWhereWithoutCreatorInput = {
    where: ContestScalarWhereInput
    data: XOR<ContestUpdateManyMutationInput, ContestUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ContestScalarWhereInput = {
    AND?: ContestScalarWhereInput | ContestScalarWhereInput[]
    OR?: ContestScalarWhereInput[]
    NOT?: ContestScalarWhereInput | ContestScalarWhereInput[]
    id?: StringFilter<"Contest"> | string
    title?: StringFilter<"Contest"> | string
    description?: StringFilter<"Contest"> | string
    banner?: StringNullableFilter<"Contest"> | string | null
    status?: EnumContestStatusFilter<"Contest"> | $Enums.ContestStatus
    mode?: EnumContestModeFilter<"Contest"> | $Enums.ContestMode
    maxUploads?: IntFilter<"Contest"> | number
    isMoneyContest?: BoolFilter<"Contest"> | boolean
    maxPrize?: IntNullableFilter<"Contest"> | number | null
    minPrize?: IntNullableFilter<"Contest"> | number | null
    level_requirements?: IntNullableListFilter<"Contest">
    startDate?: DateTimeFilter<"Contest"> | Date | string
    endDate?: DateTimeFilter<"Contest"> | Date | string
    creatorId?: StringFilter<"Contest"> | string
    createdAt?: DateTimeFilter<"Contest"> | Date | string
    updatedAt?: DateTimeFilter<"Contest"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutProviderInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutProviderInput, CommentUncheckedUpdateWithoutProviderInput>
    create: XOR<CommentCreateWithoutProviderInput, CommentUncheckedCreateWithoutProviderInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutProviderInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutProviderInput, CommentUncheckedUpdateWithoutProviderInput>
  }

  export type CommentUpdateManyWithWhereWithoutProviderInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutProviderInput>
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowerInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowerInput>
  }

  export type FollowScalarWhereInput = {
    AND?: FollowScalarWhereInput | FollowScalarWhereInput[]
    OR?: FollowScalarWhereInput[]
    NOT?: FollowScalarWhereInput | FollowScalarWhereInput[]
    id?: StringFilter<"Follow"> | string
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    updatedAt?: DateTimeFilter<"Follow"> | Date | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowingInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowingInput>
  }

  export type VoteUpsertWithWhereUniqueWithoutProviderInput = {
    where: VoteWhereUniqueInput
    update: XOR<VoteUpdateWithoutProviderInput, VoteUncheckedUpdateWithoutProviderInput>
    create: XOR<VoteCreateWithoutProviderInput, VoteUncheckedCreateWithoutProviderInput>
  }

  export type VoteUpdateWithWhereUniqueWithoutProviderInput = {
    where: VoteWhereUniqueInput
    data: XOR<VoteUpdateWithoutProviderInput, VoteUncheckedUpdateWithoutProviderInput>
  }

  export type VoteUpdateManyWithWhereWithoutProviderInput = {
    where: VoteScalarWhereInput
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyWithoutProviderInput>
  }

  export type LikeUpsertWithWhereUniqueWithoutProviderInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutProviderInput, LikeUncheckedUpdateWithoutProviderInput>
    create: XOR<LikeCreateWithoutProviderInput, LikeUncheckedCreateWithoutProviderInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutProviderInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutProviderInput, LikeUncheckedUpdateWithoutProviderInput>
  }

  export type LikeUpdateManyWithWhereWithoutProviderInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutProviderInput>
  }

  export type LikeScalarWhereInput = {
    AND?: LikeScalarWhereInput | LikeScalarWhereInput[]
    OR?: LikeScalarWhereInput[]
    NOT?: LikeScalarWhereInput | LikeScalarWhereInput[]
    id?: StringFilter<"Like"> | string
    providerId?: StringFilter<"Like"> | string
    photoId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    updatedAt?: DateTimeFilter<"Like"> | Date | string
  }

  export type UserPhotoUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPhotoWhereUniqueInput
    update: XOR<UserPhotoUpdateWithoutUserInput, UserPhotoUncheckedUpdateWithoutUserInput>
    create: XOR<UserPhotoCreateWithoutUserInput, UserPhotoUncheckedCreateWithoutUserInput>
  }

  export type UserPhotoUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPhotoWhereUniqueInput
    data: XOR<UserPhotoUpdateWithoutUserInput, UserPhotoUncheckedUpdateWithoutUserInput>
  }

  export type UserPhotoUpdateManyWithWhereWithoutUserInput = {
    where: UserPhotoScalarWhereInput
    data: XOR<UserPhotoUpdateManyMutationInput, UserPhotoUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPhotoScalarWhereInput = {
    AND?: UserPhotoScalarWhereInput | UserPhotoScalarWhereInput[]
    OR?: UserPhotoScalarWhereInput[]
    NOT?: UserPhotoScalarWhereInput | UserPhotoScalarWhereInput[]
    id?: StringFilter<"UserPhoto"> | string
    url?: StringFilter<"UserPhoto"> | string
    userId?: StringFilter<"UserPhoto"> | string
    views?: IntFilter<"UserPhoto"> | number
    labels?: StringNullableListFilter<"UserPhoto">
    title?: StringNullableFilter<"UserPhoto"> | string | null
    description?: StringNullableFilter<"UserPhoto"> | string | null
    adult?: BoolFilter<"UserPhoto"> | boolean
    createdAt?: DateTimeFilter<"UserPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"UserPhoto"> | Date | string
  }

  export type ContestParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: ContestParticipantWhereUniqueInput
    update: XOR<ContestParticipantUpdateWithoutUserInput, ContestParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<ContestParticipantCreateWithoutUserInput, ContestParticipantUncheckedCreateWithoutUserInput>
  }

  export type ContestParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: ContestParticipantWhereUniqueInput
    data: XOR<ContestParticipantUpdateWithoutUserInput, ContestParticipantUncheckedUpdateWithoutUserInput>
  }

  export type ContestParticipantUpdateManyWithWhereWithoutUserInput = {
    where: ContestParticipantScalarWhereInput
    data: XOR<ContestParticipantUpdateManyMutationInput, ContestParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatUpsertWithWhereUniqueWithoutSenderInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutSenderInput, ChatUncheckedUpdateWithoutSenderInput>
    create: XOR<ChatCreateWithoutSenderInput, ChatUncheckedCreateWithoutSenderInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutSenderInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutSenderInput, ChatUncheckedUpdateWithoutSenderInput>
  }

  export type ChatUpdateManyWithWhereWithoutSenderInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutSenderInput>
  }

  export type UserCreateWithoutStoreInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutStoreInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutStoreInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStoreInput, UserUncheckedCreateWithoutStoreInput>
  }

  export type UserUpsertWithoutStoreInput = {
    update: XOR<UserUpdateWithoutStoreInput, UserUncheckedUpdateWithoutStoreInput>
    create: XOR<UserCreateWithoutStoreInput, UserUncheckedCreateWithoutStoreInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStoreInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStoreInput, UserUncheckedUpdateWithoutStoreInput>
  }

  export type UserUpdateWithoutStoreInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutStoreInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutUserPhotosInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    store?: UserStoreCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutUserPhotosInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    store?: UserStoreUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutUserPhotosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPhotosInput, UserUncheckedCreateWithoutUserPhotosInput>
  }

  export type ContestPhotoCreateWithoutPhotoInput = {
    id?: string
    title?: string | null
    contestId: string
    rank?: number | null
    promoted?: boolean
    promotionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participant: ContestParticipantCreateNestedOneWithoutPhotosInput
    votes?: VoteCreateNestedManyWithoutPhotoInput
    comments?: CommentCreateNestedManyWithoutReceiverInput
    achievements?: ContestAchievementCreateNestedManyWithoutPhotoInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoUncheckedCreateWithoutPhotoInput = {
    id?: string
    title?: string | null
    contestId: string
    participantId: string
    rank?: number | null
    promoted?: boolean
    promotionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutPhotoInput
    comments?: CommentUncheckedCreateNestedManyWithoutReceiverInput
    achievements?: ContestAchievementUncheckedCreateNestedManyWithoutPhotoInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoCreateOrConnectWithoutPhotoInput = {
    where: ContestPhotoWhereUniqueInput
    create: XOR<ContestPhotoCreateWithoutPhotoInput, ContestPhotoUncheckedCreateWithoutPhotoInput>
  }

  export type ContestPhotoCreateManyPhotoInputEnvelope = {
    data: ContestPhotoCreateManyPhotoInput | ContestPhotoCreateManyPhotoInput[]
  }

  export type LikeCreateWithoutPhotoInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: UserCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutPhotoInput = {
    id?: string
    providerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutPhotoInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutPhotoInput, LikeUncheckedCreateWithoutPhotoInput>
  }

  export type LikeCreateManyPhotoInputEnvelope = {
    data: LikeCreateManyPhotoInput | LikeCreateManyPhotoInput[]
  }

  export type PhotoStatsUpsertInput = {
    set: PhotoStatsCreateInput | null
    update: PhotoStatsUpdateInput
  }

  export type UserUpsertWithoutUserPhotosInput = {
    update: XOR<UserUpdateWithoutUserPhotosInput, UserUncheckedUpdateWithoutUserPhotosInput>
    create: XOR<UserCreateWithoutUserPhotosInput, UserUncheckedCreateWithoutUserPhotosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserPhotosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserPhotosInput, UserUncheckedUpdateWithoutUserPhotosInput>
  }

  export type UserUpdateWithoutUserPhotosInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    store?: UserStoreUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutUserPhotosInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    store?: UserStoreUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type ContestPhotoUpsertWithWhereUniqueWithoutPhotoInput = {
    where: ContestPhotoWhereUniqueInput
    update: XOR<ContestPhotoUpdateWithoutPhotoInput, ContestPhotoUncheckedUpdateWithoutPhotoInput>
    create: XOR<ContestPhotoCreateWithoutPhotoInput, ContestPhotoUncheckedCreateWithoutPhotoInput>
  }

  export type ContestPhotoUpdateWithWhereUniqueWithoutPhotoInput = {
    where: ContestPhotoWhereUniqueInput
    data: XOR<ContestPhotoUpdateWithoutPhotoInput, ContestPhotoUncheckedUpdateWithoutPhotoInput>
  }

  export type ContestPhotoUpdateManyWithWhereWithoutPhotoInput = {
    where: ContestPhotoScalarWhereInput
    data: XOR<ContestPhotoUpdateManyMutationInput, ContestPhotoUncheckedUpdateManyWithoutPhotoInput>
  }

  export type LikeUpsertWithWhereUniqueWithoutPhotoInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutPhotoInput, LikeUncheckedUpdateWithoutPhotoInput>
    create: XOR<LikeCreateWithoutPhotoInput, LikeUncheckedCreateWithoutPhotoInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutPhotoInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutPhotoInput, LikeUncheckedUpdateWithoutPhotoInput>
  }

  export type LikeUpdateManyWithWhereWithoutPhotoInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutPhotoInput>
  }

  export type UserCreateWithoutLikesInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    store?: UserStoreCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutLikesInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    store?: UserStoreUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
  }

  export type UserPhotoCreateWithoutLikesInput = {
    id?: string
    url: string
    states?: XOR<PhotoStatsNullableCreateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: number
    labels?: UserPhotoCreatelabelsInput | string[]
    title?: string | null
    description?: string | null
    adult?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserPhotosInput
    contestUpload?: ContestPhotoCreateNestedManyWithoutPhotoInput
  }

  export type UserPhotoUncheckedCreateWithoutLikesInput = {
    id?: string
    url: string
    userId: string
    states?: XOR<PhotoStatsNullableCreateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: number
    labels?: UserPhotoCreatelabelsInput | string[]
    title?: string | null
    description?: string | null
    adult?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contestUpload?: ContestPhotoUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type UserPhotoCreateOrConnectWithoutLikesInput = {
    where: UserPhotoWhereUniqueInput
    create: XOR<UserPhotoCreateWithoutLikesInput, UserPhotoUncheckedCreateWithoutLikesInput>
  }

  export type UserUpsertWithoutLikesInput = {
    update: XOR<UserUpdateWithoutLikesInput, UserUncheckedUpdateWithoutLikesInput>
    create: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikesInput, UserUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateWithoutLikesInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    store?: UserStoreUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutLikesInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    store?: UserStoreUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserPhotoUpsertWithoutLikesInput = {
    update: XOR<UserPhotoUpdateWithoutLikesInput, UserPhotoUncheckedUpdateWithoutLikesInput>
    create: XOR<UserPhotoCreateWithoutLikesInput, UserPhotoUncheckedCreateWithoutLikesInput>
    where?: UserPhotoWhereInput
  }

  export type UserPhotoUpdateToOneWithWhereWithoutLikesInput = {
    where?: UserPhotoWhereInput
    data: XOR<UserPhotoUpdateWithoutLikesInput, UserPhotoUncheckedUpdateWithoutLikesInput>
  }

  export type UserPhotoUpdateWithoutLikesInput = {
    url?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserPhotosNestedInput
    contestUpload?: ContestPhotoUpdateManyWithoutPhotoNestedInput
  }

  export type UserPhotoUncheckedUpdateWithoutLikesInput = {
    url?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contestUpload?: ContestPhotoUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type UserCreateWithoutOtpsInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: UserStoreCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutOtpsInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store?: UserStoreUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutOtpsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
  }

  export type UserUpsertWithoutOtpsInput = {
    update: XOR<UserUpdateWithoutOtpsInput, UserUncheckedUpdateWithoutOtpsInput>
    create: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOtpsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOtpsInput, UserUncheckedUpdateWithoutOtpsInput>
  }

  export type UserUpdateWithoutOtpsInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: UserStoreUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutOtpsInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: UserStoreUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutCommentProvidesInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    store?: UserStoreCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutCommentProvidesInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    store?: UserStoreUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutCommentProvidesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentProvidesInput, UserUncheckedCreateWithoutCommentProvidesInput>
  }

  export type ContestPhotoCreateWithoutCommentsInput = {
    id?: string
    title?: string | null
    contestId: string
    rank?: number | null
    promoted?: boolean
    promotionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participant: ContestParticipantCreateNestedOneWithoutPhotosInput
    votes?: VoteCreateNestedManyWithoutPhotoInput
    photo: UserPhotoCreateNestedOneWithoutContestUploadInput
    achievements?: ContestAchievementCreateNestedManyWithoutPhotoInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoUncheckedCreateWithoutCommentsInput = {
    id?: string
    title?: string | null
    contestId: string
    participantId: string
    photoId: string
    rank?: number | null
    promoted?: boolean
    promotionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutPhotoInput
    achievements?: ContestAchievementUncheckedCreateNestedManyWithoutPhotoInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoCreateOrConnectWithoutCommentsInput = {
    where: ContestPhotoWhereUniqueInput
    create: XOR<ContestPhotoCreateWithoutCommentsInput, ContestPhotoUncheckedCreateWithoutCommentsInput>
  }

  export type CommentCreateWithoutCommentRepliesInput = {
    id?: string
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: UserCreateNestedOneWithoutCommentProvidesInput
    receiver: ContestPhotoCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutCommentRepliesInput
  }

  export type CommentUncheckedCreateWithoutCommentRepliesInput = {
    id?: string
    text: string
    providerId: string
    receiverId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutCommentRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutCommentRepliesInput, CommentUncheckedCreateWithoutCommentRepliesInput>
  }

  export type CommentCreateWithoutParentInput = {
    id?: string
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: UserCreateNestedOneWithoutCommentProvidesInput
    receiver: ContestPhotoCreateNestedOneWithoutCommentsInput
    CommentReplies?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutParentInput = {
    id?: string
    text: string
    providerId: string
    receiverId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    CommentReplies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutParentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentCreateManyParentInputEnvelope = {
    data: CommentCreateManyParentInput | CommentCreateManyParentInput[]
  }

  export type UserUpsertWithoutCommentProvidesInput = {
    update: XOR<UserUpdateWithoutCommentProvidesInput, UserUncheckedUpdateWithoutCommentProvidesInput>
    create: XOR<UserCreateWithoutCommentProvidesInput, UserUncheckedCreateWithoutCommentProvidesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentProvidesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentProvidesInput, UserUncheckedUpdateWithoutCommentProvidesInput>
  }

  export type UserUpdateWithoutCommentProvidesInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    store?: UserStoreUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentProvidesInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    store?: UserStoreUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type ContestPhotoUpsertWithoutCommentsInput = {
    update: XOR<ContestPhotoUpdateWithoutCommentsInput, ContestPhotoUncheckedUpdateWithoutCommentsInput>
    create: XOR<ContestPhotoCreateWithoutCommentsInput, ContestPhotoUncheckedCreateWithoutCommentsInput>
    where?: ContestPhotoWhereInput
  }

  export type ContestPhotoUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ContestPhotoWhereInput
    data: XOR<ContestPhotoUpdateWithoutCommentsInput, ContestPhotoUncheckedUpdateWithoutCommentsInput>
  }

  export type ContestPhotoUpdateWithoutCommentsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    promoted?: BoolFieldUpdateOperationsInput | boolean
    promotionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ContestParticipantUpdateOneRequiredWithoutPhotosNestedInput
    votes?: VoteUpdateManyWithoutPhotoNestedInput
    photo?: UserPhotoUpdateOneRequiredWithoutContestUploadNestedInput
    achievements?: ContestAchievementUpdateManyWithoutPhotoNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutPhotoNestedInput
  }

  export type ContestPhotoUncheckedUpdateWithoutCommentsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    promoted?: BoolFieldUpdateOperationsInput | boolean
    promotionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutPhotoNestedInput
    achievements?: ContestAchievementUncheckedUpdateManyWithoutPhotoNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type CommentUpsertWithoutCommentRepliesInput = {
    update: XOR<CommentUpdateWithoutCommentRepliesInput, CommentUncheckedUpdateWithoutCommentRepliesInput>
    create: XOR<CommentCreateWithoutCommentRepliesInput, CommentUncheckedCreateWithoutCommentRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutCommentRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutCommentRepliesInput, CommentUncheckedUpdateWithoutCommentRepliesInput>
  }

  export type CommentUpdateWithoutCommentRepliesInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: UserUpdateOneRequiredWithoutCommentProvidesNestedInput
    receiver?: ContestPhotoUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutCommentRepliesNestedInput
  }

  export type CommentUncheckedUpdateWithoutCommentRepliesInput = {
    text?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentInput>
  }

  export type UserCreateWithoutFollowersInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    store?: UserStoreCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutFollowersInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    store?: UserStoreUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutFollowersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
  }

  export type UserCreateWithoutFollowingsInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    store?: UserStoreCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutFollowingsInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    store?: UserStoreUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutFollowingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingsInput, UserUncheckedCreateWithoutFollowingsInput>
  }

  export type UserUpsertWithoutFollowersInput = {
    update: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserUpdateWithoutFollowersInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    store?: UserStoreUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowersInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    store?: UserStoreUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserUpsertWithoutFollowingsInput = {
    update: XOR<UserUpdateWithoutFollowingsInput, UserUncheckedUpdateWithoutFollowingsInput>
    create: XOR<UserCreateWithoutFollowingsInput, UserUncheckedCreateWithoutFollowingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowingsInput, UserUncheckedUpdateWithoutFollowingsInput>
  }

  export type UserUpdateWithoutFollowingsInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    store?: UserStoreUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowingsInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    store?: UserStoreUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutVotesInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    store?: UserStoreCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
    chat?: ChatCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutVotesInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    store?: UserStoreUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
    chat?: ChatUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
  }

  export type ContestPhotoCreateWithoutVotesInput = {
    id?: string
    title?: string | null
    contestId: string
    rank?: number | null
    promoted?: boolean
    promotionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participant: ContestParticipantCreateNestedOneWithoutPhotosInput
    photo: UserPhotoCreateNestedOneWithoutContestUploadInput
    comments?: CommentCreateNestedManyWithoutReceiverInput
    achievements?: ContestAchievementCreateNestedManyWithoutPhotoInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoUncheckedCreateWithoutVotesInput = {
    id?: string
    title?: string | null
    contestId: string
    participantId: string
    photoId: string
    rank?: number | null
    promoted?: boolean
    promotionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutReceiverInput
    achievements?: ContestAchievementUncheckedCreateNestedManyWithoutPhotoInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoCreateOrConnectWithoutVotesInput = {
    where: ContestPhotoWhereUniqueInput
    create: XOR<ContestPhotoCreateWithoutVotesInput, ContestPhotoUncheckedCreateWithoutVotesInput>
  }

  export type ContestCreateWithoutVotesInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    mode?: $Enums.ContestMode
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: ContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedContestsInput
    participants?: ContestParticipantCreateNestedManyWithoutContestInput
    teamParticipations?: TeamParticipationCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeCreateNestedManyWithoutContestInput
    achievements?: ContestAchievementCreateNestedManyWithoutContestInput
  }

  export type ContestUncheckedCreateWithoutVotesInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    mode?: $Enums.ContestMode
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: ContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ContestParticipantUncheckedCreateNestedManyWithoutContestInput
    teamParticipations?: TeamParticipationUncheckedCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleUncheckedCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeUncheckedCreateNestedManyWithoutContestInput
    achievements?: ContestAchievementUncheckedCreateNestedManyWithoutContestInput
  }

  export type ContestCreateOrConnectWithoutVotesInput = {
    where: ContestWhereUniqueInput
    create: XOR<ContestCreateWithoutVotesInput, ContestUncheckedCreateWithoutVotesInput>
  }

  export type UserUpsertWithoutVotesInput = {
    update: XOR<UserUpdateWithoutVotesInput, UserUncheckedUpdateWithoutVotesInput>
    create: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVotesInput, UserUncheckedUpdateWithoutVotesInput>
  }

  export type UserUpdateWithoutVotesInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    store?: UserStoreUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
    chat?: ChatUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutVotesInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    store?: UserStoreUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
    chat?: ChatUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type ContestPhotoUpsertWithoutVotesInput = {
    update: XOR<ContestPhotoUpdateWithoutVotesInput, ContestPhotoUncheckedUpdateWithoutVotesInput>
    create: XOR<ContestPhotoCreateWithoutVotesInput, ContestPhotoUncheckedCreateWithoutVotesInput>
    where?: ContestPhotoWhereInput
  }

  export type ContestPhotoUpdateToOneWithWhereWithoutVotesInput = {
    where?: ContestPhotoWhereInput
    data: XOR<ContestPhotoUpdateWithoutVotesInput, ContestPhotoUncheckedUpdateWithoutVotesInput>
  }

  export type ContestPhotoUpdateWithoutVotesInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    promoted?: BoolFieldUpdateOperationsInput | boolean
    promotionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ContestParticipantUpdateOneRequiredWithoutPhotosNestedInput
    photo?: UserPhotoUpdateOneRequiredWithoutContestUploadNestedInput
    comments?: CommentUpdateManyWithoutReceiverNestedInput
    achievements?: ContestAchievementUpdateManyWithoutPhotoNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutPhotoNestedInput
  }

  export type ContestPhotoUncheckedUpdateWithoutVotesInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    promoted?: BoolFieldUpdateOperationsInput | boolean
    promotionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutReceiverNestedInput
    achievements?: ContestAchievementUncheckedUpdateManyWithoutPhotoNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type ContestUpsertWithoutVotesInput = {
    update: XOR<ContestUpdateWithoutVotesInput, ContestUncheckedUpdateWithoutVotesInput>
    create: XOR<ContestCreateWithoutVotesInput, ContestUncheckedCreateWithoutVotesInput>
    where?: ContestWhereInput
  }

  export type ContestUpdateToOneWithWhereWithoutVotesInput = {
    where?: ContestWhereInput
    data: XOR<ContestUpdateWithoutVotesInput, ContestUncheckedUpdateWithoutVotesInput>
  }

  export type ContestUpdateWithoutVotesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    mode?: EnumContestModeFieldUpdateOperationsInput | $Enums.ContestMode
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: ContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedContestsNestedInput
    participants?: ContestParticipantUpdateManyWithoutContestNestedInput
    teamParticipations?: TeamParticipationUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUpdateManyWithoutContestNestedInput
    achievements?: ContestAchievementUpdateManyWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateWithoutVotesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    mode?: EnumContestModeFieldUpdateOperationsInput | $Enums.ContestMode
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: ContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ContestParticipantUncheckedUpdateManyWithoutContestNestedInput
    teamParticipations?: TeamParticipationUncheckedUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUncheckedUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUncheckedUpdateManyWithoutContestNestedInput
    achievements?: ContestAchievementUncheckedUpdateManyWithoutContestNestedInput
  }

  export type BadgeCreateInput = {
    type: string
    param: string
  }

  export type LevelRequirementUpdateManyInput = {
    where: LevelRequirementWhereInput
    data: LevelRequirementUpdateInput
  }

  export type LevelRequirementDeleteManyInput = {
    where: LevelRequirementWhereInput
  }

  export type EnumRecurringTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurringType | EnumRecurringTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RecurringType[] | ListEnumRecurringTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecurringType[] | ListEnumRecurringTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurringTypeFilter<$PrismaModel> | $Enums.RecurringType
  }

  export type BadgeCompositeFilter = {
    equals?: BadgeObjectEqualityInput
    is?: BadgeWhereInput
    isNot?: BadgeWhereInput
  }

  export type ContestParticipantCreateManyContestInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    userId: string
    memberId?: string | null
    level?: $Enums.YCLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamParticipationCreateManyContestInput = {
    id?: string
    teamId: string
  }

  export type VoteCreateManyContestInput = {
    id?: string
    providerId: string
    photoId: string
    type: $Enums.VoteType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestRuleCreateManyContestInput = {
    id?: string
    icon?: string | null
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestPrizeCreateManyContestInput = {
    id?: string
    category: $Enums.PrizeType
    trades?: number
    charges?: number
    keys?: number
  }

  export type ContestAchievementCreateManyContestInput = {
    id?: string
    category: $Enums.PrizeType
    photoId?: string | null
    participantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestParticipantUpdateWithoutContestInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    level?: EnumYCLevelFieldUpdateOperationsInput | $Enums.YCLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContestParticipantNestedInput
    member?: TeamMemberUpdateOneWithoutContestParticipantNestedInput
    photos?: ContestPhotoUpdateManyWithoutParticipantNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUpdateManyWithoutParticipantNestedInput
  }

  export type ContestParticipantUncheckedUpdateWithoutContestInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    userId?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumYCLevelFieldUpdateOperationsInput | $Enums.YCLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ContestPhotoUncheckedUpdateManyWithoutParticipantNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type ContestParticipantUncheckedUpdateManyWithoutContestInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    userId?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumYCLevelFieldUpdateOperationsInput | $Enums.YCLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamParticipationUpdateWithoutContestInput = {
    team?: TeamUpdateOneRequiredWithoutParticipationsNestedInput
  }

  export type TeamParticipationUncheckedUpdateWithoutContestInput = {
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamParticipationUncheckedUpdateManyWithoutContestInput = {
    teamId?: StringFieldUpdateOperationsInput | string
  }

  export type VoteUpdateWithoutContestInput = {
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: UserUpdateOneRequiredWithoutVotesNestedInput
    photo?: ContestPhotoUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateWithoutContestInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUncheckedUpdateManyWithoutContestInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestRuleUpdateWithoutContestInput = {
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestRuleUncheckedUpdateWithoutContestInput = {
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestRuleUncheckedUpdateManyWithoutContestInput = {
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestPrizeUpdateWithoutContestInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    trades?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    keys?: IntFieldUpdateOperationsInput | number
  }

  export type ContestPrizeUncheckedUpdateWithoutContestInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    trades?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    keys?: IntFieldUpdateOperationsInput | number
  }

  export type ContestPrizeUncheckedUpdateManyWithoutContestInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    trades?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    keys?: IntFieldUpdateOperationsInput | number
  }

  export type ContestAchievementUpdateWithoutContestInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: ContestPhotoUpdateOneWithoutAchievementsNestedInput
    participant?: ContestParticipantUpdateOneWithoutContestAchievementNestedInput
  }

  export type ContestAchievementUncheckedUpdateWithoutContestInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    photoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestAchievementUncheckedUpdateManyWithoutContestInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    photoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnumRecurringTypeFieldUpdateOperationsInput = {
    set?: $Enums.RecurringType
  }

  export type VoteCreateManyPhotoInput = {
    id?: string
    providerId: string
    contestId: string
    type: $Enums.VoteType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyReceiverInput = {
    id?: string
    text: string
    providerId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestAchievementCreateManyPhotoInput = {
    id?: string
    category: $Enums.PrizeType
    participantId?: string | null
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestWinnerCreateManyPhotoInput = {
    id?: string
    participantId: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteUpdateWithoutPhotoInput = {
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: UserUpdateOneRequiredWithoutVotesNestedInput
    contest?: ContestUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateWithoutPhotoInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUncheckedUpdateManyWithoutPhotoInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutReceiverInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: UserUpdateOneRequiredWithoutCommentProvidesNestedInput
    parent?: CommentUpdateOneWithoutCommentRepliesNestedInput
    CommentReplies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutReceiverInput = {
    text?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CommentReplies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutReceiverInput = {
    text?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestAchievementUpdateWithoutPhotoInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contest?: ContestUpdateOneRequiredWithoutAchievementsNestedInput
    participant?: ContestParticipantUpdateOneWithoutContestAchievementNestedInput
  }

  export type ContestAchievementUncheckedUpdateWithoutPhotoInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestAchievementUncheckedUpdateManyWithoutPhotoInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestWinnerUpdateWithoutPhotoInput = {
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ContestParticipantUpdateOneRequiredWithoutContestWinnerNestedInput
  }

  export type ContestWinnerUncheckedUpdateWithoutPhotoInput = {
    participantId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestWinnerUncheckedUpdateManyWithoutPhotoInput = {
    participantId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestPhotoCreateManyParticipantInput = {
    id?: string
    title?: string | null
    contestId: string
    photoId: string
    rank?: number | null
    promoted?: boolean
    promotionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestWinnerCreateManyParticipantInput = {
    id?: string
    contestId: string
    contestPhotoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestAchievementCreateManyParticipantInput = {
    id?: string
    category: $Enums.PrizeType
    photoId?: string | null
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestPhotoUpdateWithoutParticipantInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    promoted?: BoolFieldUpdateOperationsInput | boolean
    promotionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUpdateManyWithoutPhotoNestedInput
    photo?: UserPhotoUpdateOneRequiredWithoutContestUploadNestedInput
    comments?: CommentUpdateManyWithoutReceiverNestedInput
    achievements?: ContestAchievementUpdateManyWithoutPhotoNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutPhotoNestedInput
  }

  export type ContestPhotoUncheckedUpdateWithoutParticipantInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    promoted?: BoolFieldUpdateOperationsInput | boolean
    promotionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutPhotoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutReceiverNestedInput
    achievements?: ContestAchievementUncheckedUpdateManyWithoutPhotoNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type ContestPhotoUncheckedUpdateManyWithoutParticipantInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    promoted?: BoolFieldUpdateOperationsInput | boolean
    promotionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestWinnerUpdateWithoutParticipantInput = {
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: ContestPhotoUpdateOneRequiredWithoutContestWinnerNestedInput
  }

  export type ContestWinnerUncheckedUpdateWithoutParticipantInput = {
    contestId?: StringFieldUpdateOperationsInput | string
    contestPhotoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestWinnerUncheckedUpdateManyWithoutParticipantInput = {
    contestId?: StringFieldUpdateOperationsInput | string
    contestPhotoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestAchievementUpdateWithoutParticipantInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: ContestPhotoUpdateOneWithoutAchievementsNestedInput
    contest?: ContestUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type ContestAchievementUncheckedUpdateWithoutParticipantInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    photoId?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestAchievementUncheckedUpdateManyWithoutParticipantInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    photoId?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyTeamInput = {
    id?: string
    status?: $Enums.TeamMemberStatus
    level?: $Enums.MemberLevel
    memberId: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatCreateManyTeamInput = {
    id?: string
    senderId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamParticipationCreateManyTeamInput = {
    id?: string
    contestId: string
  }

  export type TeamMemberUpdateWithoutTeamInput = {
    status?: EnumTeamMemberStatusFieldUpdateOperationsInput | $Enums.TeamMemberStatus
    level?: EnumMemberLevelFieldUpdateOperationsInput | $Enums.MemberLevel
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: UserUpdateOneRequiredWithoutJoinedTeamNestedInput
    contestParticipant?: ContestParticipantUpdateManyWithoutMemberNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutTeamInput = {
    status?: EnumTeamMemberStatusFieldUpdateOperationsInput | $Enums.TeamMemberStatus
    level?: EnumMemberLevelFieldUpdateOperationsInput | $Enums.MemberLevel
    memberId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contestParticipant?: ContestParticipantUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamInput = {
    status?: EnumTeamMemberStatusFieldUpdateOperationsInput | $Enums.TeamMemberStatus
    level?: EnumMemberLevelFieldUpdateOperationsInput | $Enums.MemberLevel
    memberId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUpdateWithoutTeamInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutTeamInput = {
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUncheckedUpdateManyWithoutTeamInput = {
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamParticipationUpdateWithoutTeamInput = {
    contest?: ContestUpdateOneRequiredWithoutTeamParticipationsNestedInput
  }

  export type TeamParticipationUncheckedUpdateWithoutTeamInput = {
    contestId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamParticipationUncheckedUpdateManyWithoutTeamInput = {
    contestId?: StringFieldUpdateOperationsInput | string
  }

  export type ContestParticipantCreateManyMemberInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    contestId: string
    userId: string
    level?: $Enums.YCLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestParticipantUpdateWithoutMemberInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    level?: EnumYCLevelFieldUpdateOperationsInput | $Enums.YCLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contest?: ContestUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutContestParticipantNestedInput
    photos?: ContestPhotoUpdateManyWithoutParticipantNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUpdateManyWithoutParticipantNestedInput
  }

  export type ContestParticipantUncheckedUpdateWithoutMemberInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    contestId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    level?: EnumYCLevelFieldUpdateOperationsInput | $Enums.YCLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ContestPhotoUncheckedUpdateManyWithoutParticipantNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type ContestParticipantUncheckedUpdateManyWithoutMemberInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    contestId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    level?: EnumYCLevelFieldUpdateOperationsInput | $Enums.YCLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateManyCreatorInput = {
    id?: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility?: $Enums.TeamAccessibility
    score?: number
    win?: number
    lost?: number
    badge: string
    min_requirement: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestCreateManyCreatorInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    mode?: $Enums.ContestMode
    maxUploads?: number
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    level_requirements?: ContestCreatelevel_requirementsInput | number[]
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyProviderInput = {
    id?: string
    text: string
    receiverId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowCreateManyFollowerInput = {
    id?: string
    followingId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowCreateManyFollowingInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteCreateManyProviderInput = {
    id?: string
    photoId: string
    contestId: string
    type: $Enums.VoteType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeCreateManyProviderInput = {
    id?: string
    photoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPhotoCreateManyUserInput = {
    id?: string
    url: string
    states?: XOR<PhotoStatsNullableCreateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: number
    labels?: UserPhotoCreatelabelsInput | string[]
    title?: string | null
    description?: string | null
    adult?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestParticipantCreateManyUserInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    contestId: string
    memberId?: string | null
    level?: $Enums.YCLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatCreateManySenderInput = {
    id?: string
    teamId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    score?: IntFieldUpdateOperationsInput | number
    win?: IntFieldUpdateOperationsInput | number
    lost?: IntFieldUpdateOperationsInput | number
    badge?: StringFieldUpdateOperationsInput | string
    min_requirement?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    chat?: ChatUpdateManyWithoutTeamNestedInput
    participations?: TeamParticipationUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    score?: IntFieldUpdateOperationsInput | number
    win?: IntFieldUpdateOperationsInput | number
    lost?: IntFieldUpdateOperationsInput | number
    badge?: StringFieldUpdateOperationsInput | string
    min_requirement?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    chat?: ChatUncheckedUpdateManyWithoutTeamNestedInput
    participations?: TeamParticipationUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    score?: IntFieldUpdateOperationsInput | number
    win?: IntFieldUpdateOperationsInput | number
    lost?: IntFieldUpdateOperationsInput | number
    badge?: StringFieldUpdateOperationsInput | string
    min_requirement?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestUpdateWithoutCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    mode?: EnumContestModeFieldUpdateOperationsInput | $Enums.ContestMode
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: ContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ContestParticipantUpdateManyWithoutContestNestedInput
    teamParticipations?: TeamParticipationUpdateManyWithoutContestNestedInput
    votes?: VoteUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUpdateManyWithoutContestNestedInput
    achievements?: ContestAchievementUpdateManyWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateWithoutCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    mode?: EnumContestModeFieldUpdateOperationsInput | $Enums.ContestMode
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: ContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ContestParticipantUncheckedUpdateManyWithoutContestNestedInput
    teamParticipations?: TeamParticipationUncheckedUpdateManyWithoutContestNestedInput
    votes?: VoteUncheckedUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUncheckedUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUncheckedUpdateManyWithoutContestNestedInput
    achievements?: ContestAchievementUncheckedUpdateManyWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateManyWithoutCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    mode?: EnumContestModeFieldUpdateOperationsInput | $Enums.ContestMode
    maxUploads?: IntFieldUpdateOperationsInput | number
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    level_requirements?: ContestUpdatelevel_requirementsInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutProviderInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: ContestPhotoUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutCommentRepliesNestedInput
    CommentReplies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutProviderInput = {
    text?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CommentReplies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutProviderInput = {
    text?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFollowerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    following?: UserUpdateOneRequiredWithoutFollowingsNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowerInput = {
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowerInput = {
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFollowingInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowingInput = {
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowingInput = {
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUpdateWithoutProviderInput = {
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: ContestPhotoUpdateOneRequiredWithoutVotesNestedInput
    contest?: ContestUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateWithoutProviderInput = {
    photoId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUncheckedUpdateManyWithoutProviderInput = {
    photoId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutProviderInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: UserPhotoUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutProviderInput = {
    photoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutProviderInput = {
    photoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhotoUpdateWithoutUserInput = {
    url?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contestUpload?: ContestPhotoUpdateManyWithoutPhotoNestedInput
    likes?: LikeUpdateManyWithoutPhotoNestedInput
  }

  export type UserPhotoUncheckedUpdateWithoutUserInput = {
    url?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contestUpload?: ContestPhotoUncheckedUpdateManyWithoutPhotoNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type UserPhotoUncheckedUpdateManyWithoutUserInput = {
    url?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestParticipantUpdateWithoutUserInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    level?: EnumYCLevelFieldUpdateOperationsInput | $Enums.YCLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contest?: ContestUpdateOneRequiredWithoutParticipantsNestedInput
    member?: TeamMemberUpdateOneWithoutContestParticipantNestedInput
    photos?: ContestPhotoUpdateManyWithoutParticipantNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUpdateManyWithoutParticipantNestedInput
  }

  export type ContestParticipantUncheckedUpdateWithoutUserInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    contestId?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumYCLevelFieldUpdateOperationsInput | $Enums.YCLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ContestPhotoUncheckedUpdateManyWithoutParticipantNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type ContestParticipantUncheckedUpdateManyWithoutUserInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    contestId?: StringFieldUpdateOperationsInput | string
    memberId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumYCLevelFieldUpdateOperationsInput | $Enums.YCLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUpdateWithoutSenderInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutSenderInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUncheckedUpdateManyWithoutSenderInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestPhotoCreateManyPhotoInput = {
    id?: string
    title?: string | null
    contestId: string
    participantId: string
    rank?: number | null
    promoted?: boolean
    promotionExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeCreateManyPhotoInput = {
    id?: string
    providerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhotoStatsUpdateInput = {
    Composition?: IntFieldUpdateOperationsInput | number
    Content?: IntFieldUpdateOperationsInput | number
    Creativity?: IntFieldUpdateOperationsInput | number
    Technique?: IntFieldUpdateOperationsInput | number
  }

  export type ContestPhotoUpdateWithoutPhotoInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    promoted?: BoolFieldUpdateOperationsInput | boolean
    promotionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ContestParticipantUpdateOneRequiredWithoutPhotosNestedInput
    votes?: VoteUpdateManyWithoutPhotoNestedInput
    comments?: CommentUpdateManyWithoutReceiverNestedInput
    achievements?: ContestAchievementUpdateManyWithoutPhotoNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutPhotoNestedInput
  }

  export type ContestPhotoUncheckedUpdateWithoutPhotoInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    promoted?: BoolFieldUpdateOperationsInput | boolean
    promotionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutPhotoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutReceiverNestedInput
    achievements?: ContestAchievementUncheckedUpdateManyWithoutPhotoNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type ContestPhotoUncheckedUpdateManyWithoutPhotoInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    promoted?: BoolFieldUpdateOperationsInput | boolean
    promotionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutPhotoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: UserUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutPhotoInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutPhotoInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyParentInput = {
    id?: string
    text: string
    providerId: string
    receiverId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutParentInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: UserUpdateOneRequiredWithoutCommentProvidesNestedInput
    receiver?: ContestPhotoUpdateOneRequiredWithoutCommentsNestedInput
    CommentReplies?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentInput = {
    text?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CommentReplies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentInput = {
    text?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevelRequirementUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    required?: IntFieldUpdateOperationsInput | number
    badge?: XOR<BadgeUpdateEnvelopeInput, BadgeCreateInput>
  }

  export type NestedEnumRecurringTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurringType | EnumRecurringTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RecurringType[] | ListEnumRecurringTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecurringType[] | ListEnumRecurringTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurringTypeFilter<$PrismaModel> | $Enums.RecurringType
  }

  export type BadgeWhereInput = {
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    type?: StringFilter<"Badge"> | string
    param?: StringFilter<"Badge"> | string
  }

  export type BadgeUpdateEnvelopeInput = {
    set?: BadgeCreateInput
    update?: BadgeUpdateInput
  }

  export type BadgeUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    param?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}