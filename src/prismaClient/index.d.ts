
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model RecurringData
 * 
 */
export type RecurringData = $Result.DefaultSelection<Prisma.$RecurringDataPayload>
/**
 * Model PhotoStats
 * 
 */
export type PhotoStats = $Result.DefaultSelection<Prisma.$PhotoStatsPayload>
/**
 * Model Contest
 * 
 */
export type Contest = $Result.DefaultSelection<Prisma.$ContestPayload>
/**
 * Model ContestRule
 * 
 */
export type ContestRule = $Result.DefaultSelection<Prisma.$ContestRulePayload>
/**
 * Model RecurringContestData
 * 
 */
export type RecurringContestData = $Result.DefaultSelection<Prisma.$RecurringContestDataPayload>
/**
 * Model RecurringContest
 * 
 */
export type RecurringContest = $Result.DefaultSelection<Prisma.$RecurringContestPayload>
/**
 * Model ContestPhoto
 * 
 */
export type ContestPhoto = $Result.DefaultSelection<Prisma.$ContestPhotoPayload>
/**
 * Model ContestWinner
 * 
 */
export type ContestWinner = $Result.DefaultSelection<Prisma.$ContestWinnerPayload>
/**
 * Model ContestParticipant
 * 
 */
export type ContestParticipant = $Result.DefaultSelection<Prisma.$ContestParticipantPayload>
/**
 * Model ContestPrize
 * 
 */
export type ContestPrize = $Result.DefaultSelection<Prisma.$ContestPrizePayload>
/**
 * Model ContestAchievement
 * 
 */
export type ContestAchievement = $Result.DefaultSelection<Prisma.$ContestAchievementPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model TeamMember
 * 
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserPhoto
 * 
 */
export type UserPhoto = $Result.DefaultSelection<Prisma.$UserPhotoPayload>
/**
 * Model Like
 * 
 */
export type Like = $Result.DefaultSelection<Prisma.$LikePayload>
/**
 * Model Otp
 * 
 */
export type Otp = $Result.DefaultSelection<Prisma.$OtpPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Follow
 * 
 */
export type Follow = $Result.DefaultSelection<Prisma.$FollowPayload>
/**
 * Model Vote
 * 
 */
export type Vote = $Result.DefaultSelection<Prisma.$VotePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PrizeType: {
  TOP_PHOTO: 'TOP_PHOTO',
  TOP_PHOTOGRAPHER: 'TOP_PHOTOGRAPHER',
  TOP_YC_PICK: 'TOP_YC_PICK'
};

export type PrizeType = (typeof PrizeType)[keyof typeof PrizeType]


export const ContestStatus: {
  NEW: 'NEW',
  UPCOMING: 'UPCOMING',
  ACTIVE: 'ACTIVE',
  OPEN: 'OPEN',
  CLOSED: 'CLOSED'
};

export type ContestStatus = (typeof ContestStatus)[keyof typeof ContestStatus]


export const ContestType: {
  ONETIME: 'ONETIME',
  RECURRING: 'RECURRING'
};

export type ContestType = (typeof ContestType)[keyof typeof ContestType]


export const RecurringType: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY'
};

export type RecurringType = (typeof RecurringType)[keyof typeof RecurringType]


export const ContestLevel: {
  POPULAR: 'POPULAR',
  SKILLED: 'SKILLED',
  PREMIER: 'PREMIER',
  ELITE: 'ELITE',
  ALL_STAR: 'ALL_STAR'
};

export type ContestLevel = (typeof ContestLevel)[keyof typeof ContestLevel]


export const ContestLevel2: {
  AMATEUR: 'AMATEUR',
  TALANTED: 'TALANTED',
  SUPREME: 'SUPREME',
  SUPERIOR: 'SUPERIOR',
  TOP_NOTCH: 'TOP_NOTCH'
};

export type ContestLevel2 = (typeof ContestLevel2)[keyof typeof ContestLevel2]


export const ContestParticipantStatus: {
  ACTIVE: 'ACTIVE',
  BLOCKED: 'BLOCKED'
};

export type ContestParticipantStatus = (typeof ContestParticipantStatus)[keyof typeof ContestParticipantStatus]


export const TeamAccessibility: {
  PUBLIC: 'PUBLIC',
  PRIVATE: 'PRIVATE'
};

export type TeamAccessibility = (typeof TeamAccessibility)[keyof typeof TeamAccessibility]


export const TeamMemberStatus: {
  ACTIVE: 'ACTIVE',
  REMOVED: 'REMOVED',
  BLOCKED: 'BLOCKED'
};

export type TeamMemberStatus = (typeof TeamMemberStatus)[keyof typeof TeamMemberStatus]


export const UserLevel: {
  APPRENTICE: 'APPRENTICE',
  STUDENT: 'STUDENT',
  TRAINED: 'TRAINED',
  TALENTED: 'TALENTED',
  CONTENDER: 'CONTENDER',
  VIRTUOSO: 'VIRTUOSO',
  LEADER: 'LEADER',
  AVANTGARDE: 'AVANTGARDE',
  PRO: 'PRO'
};

export type UserLevel = (typeof UserLevel)[keyof typeof UserLevel]


export const UserRole: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const OtpStatus: {
  CREATED: 'CREATED',
  VALIDATED: 'VALIDATED'
};

export type OtpStatus = (typeof OtpStatus)[keyof typeof OtpStatus]

}

export type PrizeType = $Enums.PrizeType

export const PrizeType: typeof $Enums.PrizeType

export type ContestStatus = $Enums.ContestStatus

export const ContestStatus: typeof $Enums.ContestStatus

export type ContestType = $Enums.ContestType

export const ContestType: typeof $Enums.ContestType

export type RecurringType = $Enums.RecurringType

export const RecurringType: typeof $Enums.RecurringType

export type ContestLevel = $Enums.ContestLevel

export const ContestLevel: typeof $Enums.ContestLevel

export type ContestLevel2 = $Enums.ContestLevel2

export const ContestLevel2: typeof $Enums.ContestLevel2

export type ContestParticipantStatus = $Enums.ContestParticipantStatus

export const ContestParticipantStatus: typeof $Enums.ContestParticipantStatus

export type TeamAccessibility = $Enums.TeamAccessibility

export const TeamAccessibility: typeof $Enums.TeamAccessibility

export type TeamMemberStatus = $Enums.TeamMemberStatus

export const TeamMemberStatus: typeof $Enums.TeamMemberStatus

export type UserLevel = $Enums.UserLevel

export const UserLevel: typeof $Enums.UserLevel

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type OtpStatus = $Enums.OtpStatus

export const OtpStatus: typeof $Enums.OtpStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Contests
 * const contests = await prisma.contest.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Contests
   * const contests = await prisma.contest.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.contest`: Exposes CRUD operations for the **Contest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contests
    * const contests = await prisma.contest.findMany()
    * ```
    */
  get contest(): Prisma.ContestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contestRule`: Exposes CRUD operations for the **ContestRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContestRules
    * const contestRules = await prisma.contestRule.findMany()
    * ```
    */
  get contestRule(): Prisma.ContestRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recurringContestData`: Exposes CRUD operations for the **RecurringContestData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecurringContestData
    * const recurringContestData = await prisma.recurringContestData.findMany()
    * ```
    */
  get recurringContestData(): Prisma.RecurringContestDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recurringContest`: Exposes CRUD operations for the **RecurringContest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecurringContests
    * const recurringContests = await prisma.recurringContest.findMany()
    * ```
    */
  get recurringContest(): Prisma.RecurringContestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contestPhoto`: Exposes CRUD operations for the **ContestPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContestPhotos
    * const contestPhotos = await prisma.contestPhoto.findMany()
    * ```
    */
  get contestPhoto(): Prisma.ContestPhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contestWinner`: Exposes CRUD operations for the **ContestWinner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContestWinners
    * const contestWinners = await prisma.contestWinner.findMany()
    * ```
    */
  get contestWinner(): Prisma.ContestWinnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contestParticipant`: Exposes CRUD operations for the **ContestParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContestParticipants
    * const contestParticipants = await prisma.contestParticipant.findMany()
    * ```
    */
  get contestParticipant(): Prisma.ContestParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contestPrize`: Exposes CRUD operations for the **ContestPrize** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContestPrizes
    * const contestPrizes = await prisma.contestPrize.findMany()
    * ```
    */
  get contestPrize(): Prisma.ContestPrizeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contestAchievement`: Exposes CRUD operations for the **ContestAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContestAchievements
    * const contestAchievements = await prisma.contestAchievement.findMany()
    * ```
    */
  get contestAchievement(): Prisma.ContestAchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPhoto`: Exposes CRUD operations for the **UserPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPhotos
    * const userPhotos = await prisma.userPhoto.findMany()
    * ```
    */
  get userPhoto(): Prisma.UserPhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.like`: Exposes CRUD operations for the **Like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Likes
    * const likes = await prisma.like.findMany()
    * ```
    */
  get like(): Prisma.LikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.otp`: Exposes CRUD operations for the **Otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otp.findMany()
    * ```
    */
  get otp(): Prisma.OtpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.follow`: Exposes CRUD operations for the **Follow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Follows
    * const follows = await prisma.follow.findMany()
    * ```
    */
  get follow(): Prisma.FollowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vote`: Exposes CRUD operations for the **Vote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Votes
    * const votes = await prisma.vote.findMany()
    * ```
    */
  get vote(): Prisma.VoteDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Contest: 'Contest',
    ContestRule: 'ContestRule',
    RecurringContestData: 'RecurringContestData',
    RecurringContest: 'RecurringContest',
    ContestPhoto: 'ContestPhoto',
    ContestWinner: 'ContestWinner',
    ContestParticipant: 'ContestParticipant',
    ContestPrize: 'ContestPrize',
    ContestAchievement: 'ContestAchievement',
    Team: 'Team',
    TeamMember: 'TeamMember',
    User: 'User',
    UserPhoto: 'UserPhoto',
    Like: 'Like',
    Otp: 'Otp',
    Comment: 'Comment',
    Follow: 'Follow',
    Vote: 'Vote'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "contest" | "contestRule" | "recurringContestData" | "recurringContest" | "contestPhoto" | "contestWinner" | "contestParticipant" | "contestPrize" | "contestAchievement" | "team" | "teamMember" | "user" | "userPhoto" | "like" | "otp" | "comment" | "follow" | "vote"
      txIsolationLevel: never
    }
    model: {
      Contest: {
        payload: Prisma.$ContestPayload<ExtArgs>
        fields: Prisma.ContestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>
          }
          findFirst: {
            args: Prisma.ContestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>
          }
          findMany: {
            args: Prisma.ContestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>[]
          }
          create: {
            args: Prisma.ContestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>
          }
          createMany: {
            args: Prisma.ContestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>
          }
          update: {
            args: Prisma.ContestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>
          }
          deleteMany: {
            args: Prisma.ContestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPayload>
          }
          aggregate: {
            args: Prisma.ContestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContest>
          }
          groupBy: {
            args: Prisma.ContestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContestGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ContestFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ContestAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ContestCountArgs<ExtArgs>
            result: $Utils.Optional<ContestCountAggregateOutputType> | number
          }
        }
      }
      ContestRule: {
        payload: Prisma.$ContestRulePayload<ExtArgs>
        fields: Prisma.ContestRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContestRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContestRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestRulePayload>
          }
          findFirst: {
            args: Prisma.ContestRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContestRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestRulePayload>
          }
          findMany: {
            args: Prisma.ContestRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestRulePayload>[]
          }
          create: {
            args: Prisma.ContestRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestRulePayload>
          }
          createMany: {
            args: Prisma.ContestRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContestRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestRulePayload>
          }
          update: {
            args: Prisma.ContestRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestRulePayload>
          }
          deleteMany: {
            args: Prisma.ContestRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContestRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContestRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestRulePayload>
          }
          aggregate: {
            args: Prisma.ContestRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContestRule>
          }
          groupBy: {
            args: Prisma.ContestRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContestRuleGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ContestRuleFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ContestRuleAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ContestRuleCountArgs<ExtArgs>
            result: $Utils.Optional<ContestRuleCountAggregateOutputType> | number
          }
        }
      }
      RecurringContestData: {
        payload: Prisma.$RecurringContestDataPayload<ExtArgs>
        fields: Prisma.RecurringContestDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecurringContestDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecurringContestDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestDataPayload>
          }
          findFirst: {
            args: Prisma.RecurringContestDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecurringContestDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestDataPayload>
          }
          findMany: {
            args: Prisma.RecurringContestDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestDataPayload>[]
          }
          create: {
            args: Prisma.RecurringContestDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestDataPayload>
          }
          createMany: {
            args: Prisma.RecurringContestDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RecurringContestDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestDataPayload>
          }
          update: {
            args: Prisma.RecurringContestDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestDataPayload>
          }
          deleteMany: {
            args: Prisma.RecurringContestDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecurringContestDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecurringContestDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestDataPayload>
          }
          aggregate: {
            args: Prisma.RecurringContestDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurringContestData>
          }
          groupBy: {
            args: Prisma.RecurringContestDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecurringContestDataGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.RecurringContestDataFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.RecurringContestDataAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.RecurringContestDataCountArgs<ExtArgs>
            result: $Utils.Optional<RecurringContestDataCountAggregateOutputType> | number
          }
        }
      }
      RecurringContest: {
        payload: Prisma.$RecurringContestPayload<ExtArgs>
        fields: Prisma.RecurringContestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecurringContestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecurringContestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestPayload>
          }
          findFirst: {
            args: Prisma.RecurringContestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecurringContestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestPayload>
          }
          findMany: {
            args: Prisma.RecurringContestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestPayload>[]
          }
          create: {
            args: Prisma.RecurringContestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestPayload>
          }
          createMany: {
            args: Prisma.RecurringContestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RecurringContestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestPayload>
          }
          update: {
            args: Prisma.RecurringContestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestPayload>
          }
          deleteMany: {
            args: Prisma.RecurringContestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecurringContestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecurringContestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringContestPayload>
          }
          aggregate: {
            args: Prisma.RecurringContestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurringContest>
          }
          groupBy: {
            args: Prisma.RecurringContestGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecurringContestGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.RecurringContestFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.RecurringContestAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.RecurringContestCountArgs<ExtArgs>
            result: $Utils.Optional<RecurringContestCountAggregateOutputType> | number
          }
        }
      }
      ContestPhoto: {
        payload: Prisma.$ContestPhotoPayload<ExtArgs>
        fields: Prisma.ContestPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContestPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContestPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPhotoPayload>
          }
          findFirst: {
            args: Prisma.ContestPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContestPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPhotoPayload>
          }
          findMany: {
            args: Prisma.ContestPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPhotoPayload>[]
          }
          create: {
            args: Prisma.ContestPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPhotoPayload>
          }
          createMany: {
            args: Prisma.ContestPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContestPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPhotoPayload>
          }
          update: {
            args: Prisma.ContestPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPhotoPayload>
          }
          deleteMany: {
            args: Prisma.ContestPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContestPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContestPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPhotoPayload>
          }
          aggregate: {
            args: Prisma.ContestPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContestPhoto>
          }
          groupBy: {
            args: Prisma.ContestPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContestPhotoGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ContestPhotoFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ContestPhotoAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ContestPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<ContestPhotoCountAggregateOutputType> | number
          }
        }
      }
      ContestWinner: {
        payload: Prisma.$ContestWinnerPayload<ExtArgs>
        fields: Prisma.ContestWinnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContestWinnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestWinnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContestWinnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestWinnerPayload>
          }
          findFirst: {
            args: Prisma.ContestWinnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestWinnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContestWinnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestWinnerPayload>
          }
          findMany: {
            args: Prisma.ContestWinnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestWinnerPayload>[]
          }
          create: {
            args: Prisma.ContestWinnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestWinnerPayload>
          }
          createMany: {
            args: Prisma.ContestWinnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContestWinnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestWinnerPayload>
          }
          update: {
            args: Prisma.ContestWinnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestWinnerPayload>
          }
          deleteMany: {
            args: Prisma.ContestWinnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContestWinnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContestWinnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestWinnerPayload>
          }
          aggregate: {
            args: Prisma.ContestWinnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContestWinner>
          }
          groupBy: {
            args: Prisma.ContestWinnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContestWinnerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ContestWinnerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ContestWinnerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ContestWinnerCountArgs<ExtArgs>
            result: $Utils.Optional<ContestWinnerCountAggregateOutputType> | number
          }
        }
      }
      ContestParticipant: {
        payload: Prisma.$ContestParticipantPayload<ExtArgs>
        fields: Prisma.ContestParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContestParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContestParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestParticipantPayload>
          }
          findFirst: {
            args: Prisma.ContestParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContestParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestParticipantPayload>
          }
          findMany: {
            args: Prisma.ContestParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestParticipantPayload>[]
          }
          create: {
            args: Prisma.ContestParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestParticipantPayload>
          }
          createMany: {
            args: Prisma.ContestParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContestParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestParticipantPayload>
          }
          update: {
            args: Prisma.ContestParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ContestParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContestParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContestParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestParticipantPayload>
          }
          aggregate: {
            args: Prisma.ContestParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContestParticipant>
          }
          groupBy: {
            args: Prisma.ContestParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContestParticipantGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ContestParticipantFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ContestParticipantAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ContestParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ContestParticipantCountAggregateOutputType> | number
          }
        }
      }
      ContestPrize: {
        payload: Prisma.$ContestPrizePayload<ExtArgs>
        fields: Prisma.ContestPrizeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContestPrizeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPrizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContestPrizeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPrizePayload>
          }
          findFirst: {
            args: Prisma.ContestPrizeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPrizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContestPrizeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPrizePayload>
          }
          findMany: {
            args: Prisma.ContestPrizeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPrizePayload>[]
          }
          create: {
            args: Prisma.ContestPrizeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPrizePayload>
          }
          createMany: {
            args: Prisma.ContestPrizeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContestPrizeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPrizePayload>
          }
          update: {
            args: Prisma.ContestPrizeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPrizePayload>
          }
          deleteMany: {
            args: Prisma.ContestPrizeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContestPrizeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContestPrizeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestPrizePayload>
          }
          aggregate: {
            args: Prisma.ContestPrizeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContestPrize>
          }
          groupBy: {
            args: Prisma.ContestPrizeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContestPrizeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ContestPrizeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ContestPrizeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ContestPrizeCountArgs<ExtArgs>
            result: $Utils.Optional<ContestPrizeCountAggregateOutputType> | number
          }
        }
      }
      ContestAchievement: {
        payload: Prisma.$ContestAchievementPayload<ExtArgs>
        fields: Prisma.ContestAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContestAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContestAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAchievementPayload>
          }
          findFirst: {
            args: Prisma.ContestAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContestAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAchievementPayload>
          }
          findMany: {
            args: Prisma.ContestAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAchievementPayload>[]
          }
          create: {
            args: Prisma.ContestAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAchievementPayload>
          }
          createMany: {
            args: Prisma.ContestAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContestAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAchievementPayload>
          }
          update: {
            args: Prisma.ContestAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAchievementPayload>
          }
          deleteMany: {
            args: Prisma.ContestAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContestAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContestAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContestAchievementPayload>
          }
          aggregate: {
            args: Prisma.ContestAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContestAchievement>
          }
          groupBy: {
            args: Prisma.ContestAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContestAchievementGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ContestAchievementFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ContestAchievementAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ContestAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<ContestAchievementCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TeamFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TeamAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>
        fields: Prisma.TeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TeamMemberFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TeamMemberAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserPhoto: {
        payload: Prisma.$UserPhotoPayload<ExtArgs>
        fields: Prisma.UserPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          findFirst: {
            args: Prisma.UserPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          findMany: {
            args: Prisma.UserPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>[]
          }
          create: {
            args: Prisma.UserPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          createMany: {
            args: Prisma.UserPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          update: {
            args: Prisma.UserPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          deleteMany: {
            args: Prisma.UserPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhotoPayload>
          }
          aggregate: {
            args: Prisma.UserPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPhoto>
          }
          groupBy: {
            args: Prisma.UserPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPhotoGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserPhotoFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserPhotoAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<UserPhotoCountAggregateOutputType> | number
          }
        }
      }
      Like: {
        payload: Prisma.$LikePayload<ExtArgs>
        fields: Prisma.LikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findFirst: {
            args: Prisma.LikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findMany: {
            args: Prisma.LikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          create: {
            args: Prisma.LikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          createMany: {
            args: Prisma.LikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          update: {
            args: Prisma.LikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          deleteMany: {
            args: Prisma.LikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          aggregate: {
            args: Prisma.LikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLike>
          }
          groupBy: {
            args: Prisma.LikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LikeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LikeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LikeCountArgs<ExtArgs>
            result: $Utils.Optional<LikeCountAggregateOutputType> | number
          }
        }
      }
      Otp: {
        payload: Prisma.$OtpPayload<ExtArgs>
        fields: Prisma.OtpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findFirst: {
            args: Prisma.OtpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findMany: {
            args: Prisma.OtpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          create: {
            args: Prisma.OtpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          createMany: {
            args: Prisma.OtpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OtpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          update: {
            args: Prisma.OtpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          deleteMany: {
            args: Prisma.OtpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OtpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          aggregate: {
            args: Prisma.OtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtp>
          }
          groupBy: {
            args: Prisma.OtpGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.OtpFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.OtpAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.OtpCountArgs<ExtArgs>
            result: $Utils.Optional<OtpCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CommentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CommentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Follow: {
        payload: Prisma.$FollowPayload<ExtArgs>
        fields: Prisma.FollowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findFirst: {
            args: Prisma.FollowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findMany: {
            args: Prisma.FollowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          create: {
            args: Prisma.FollowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          createMany: {
            args: Prisma.FollowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FollowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          update: {
            args: Prisma.FollowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          deleteMany: {
            args: Prisma.FollowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FollowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          aggregate: {
            args: Prisma.FollowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollow>
          }
          groupBy: {
            args: Prisma.FollowGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FollowFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FollowAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FollowCountArgs<ExtArgs>
            result: $Utils.Optional<FollowCountAggregateOutputType> | number
          }
        }
      }
      Vote: {
        payload: Prisma.$VotePayload<ExtArgs>
        fields: Prisma.VoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          findFirst: {
            args: Prisma.VoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          findMany: {
            args: Prisma.VoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          create: {
            args: Prisma.VoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          createMany: {
            args: Prisma.VoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          update: {
            args: Prisma.VoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          deleteMany: {
            args: Prisma.VoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          aggregate: {
            args: Prisma.VoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVote>
          }
          groupBy: {
            args: Prisma.VoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoteGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.VoteFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.VoteAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.VoteCountArgs<ExtArgs>
            result: $Utils.Optional<VoteCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    contest?: ContestOmit
    contestRule?: ContestRuleOmit
    recurringContestData?: RecurringContestDataOmit
    recurringContest?: RecurringContestOmit
    contestPhoto?: ContestPhotoOmit
    contestWinner?: ContestWinnerOmit
    contestParticipant?: ContestParticipantOmit
    contestPrize?: ContestPrizeOmit
    contestAchievement?: ContestAchievementOmit
    team?: TeamOmit
    teamMember?: TeamMemberOmit
    user?: UserOmit
    userPhoto?: UserPhotoOmit
    like?: LikeOmit
    otp?: OtpOmit
    comment?: CommentOmit
    follow?: FollowOmit
    vote?: VoteOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ContestCountOutputType
   */

  export type ContestCountOutputType = {
    participants: number
    votes: number
    contestRules: number
    contestPrizes: number
  }

  export type ContestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | ContestCountOutputTypeCountParticipantsArgs
    votes?: boolean | ContestCountOutputTypeCountVotesArgs
    contestRules?: boolean | ContestCountOutputTypeCountContestRulesArgs
    contestPrizes?: boolean | ContestCountOutputTypeCountContestPrizesArgs
  }

  // Custom InputTypes
  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestCountOutputType
     */
    select?: ContestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestParticipantWhereInput
  }

  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
  }

  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountContestRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestRuleWhereInput
  }

  /**
   * ContestCountOutputType without action
   */
  export type ContestCountOutputTypeCountContestPrizesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestPrizeWhereInput
  }


  /**
   * Count Type ContestPhotoCountOutputType
   */

  export type ContestPhotoCountOutputType = {
    votes: number
    comments: number
    achievements: number
    ContestWinner: number
  }

  export type ContestPhotoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    votes?: boolean | ContestPhotoCountOutputTypeCountVotesArgs
    comments?: boolean | ContestPhotoCountOutputTypeCountCommentsArgs
    achievements?: boolean | ContestPhotoCountOutputTypeCountAchievementsArgs
    ContestWinner?: boolean | ContestPhotoCountOutputTypeCountContestWinnerArgs
  }

  // Custom InputTypes
  /**
   * ContestPhotoCountOutputType without action
   */
  export type ContestPhotoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhotoCountOutputType
     */
    select?: ContestPhotoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContestPhotoCountOutputType without action
   */
  export type ContestPhotoCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
  }

  /**
   * ContestPhotoCountOutputType without action
   */
  export type ContestPhotoCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * ContestPhotoCountOutputType without action
   */
  export type ContestPhotoCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestAchievementWhereInput
  }

  /**
   * ContestPhotoCountOutputType without action
   */
  export type ContestPhotoCountOutputTypeCountContestWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestWinnerWhereInput
  }


  /**
   * Count Type ContestParticipantCountOutputType
   */

  export type ContestParticipantCountOutputType = {
    photos: number
    ContestWinner: number
    contestAchievement: number
  }

  export type ContestParticipantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | ContestParticipantCountOutputTypeCountPhotosArgs
    ContestWinner?: boolean | ContestParticipantCountOutputTypeCountContestWinnerArgs
    contestAchievement?: boolean | ContestParticipantCountOutputTypeCountContestAchievementArgs
  }

  // Custom InputTypes
  /**
   * ContestParticipantCountOutputType without action
   */
  export type ContestParticipantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipantCountOutputType
     */
    select?: ContestParticipantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContestParticipantCountOutputType without action
   */
  export type ContestParticipantCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestPhotoWhereInput
  }

  /**
   * ContestParticipantCountOutputType without action
   */
  export type ContestParticipantCountOutputTypeCountContestWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestWinnerWhereInput
  }

  /**
   * ContestParticipantCountOutputType without action
   */
  export type ContestParticipantCountOutputTypeCountContestAchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestAchievementWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    members: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | TeamCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdTeam: number
    createdContests: number
    commentProvides: number
    followers: number
    followings: number
    votes: number
    likes: number
    userPhotos: number
    ContestParticipant: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdTeam?: boolean | UserCountOutputTypeCountCreatedTeamArgs
    createdContests?: boolean | UserCountOutputTypeCountCreatedContestsArgs
    commentProvides?: boolean | UserCountOutputTypeCountCommentProvidesArgs
    followers?: boolean | UserCountOutputTypeCountFollowersArgs
    followings?: boolean | UserCountOutputTypeCountFollowingsArgs
    votes?: boolean | UserCountOutputTypeCountVotesArgs
    likes?: boolean | UserCountOutputTypeCountLikesArgs
    userPhotos?: boolean | UserCountOutputTypeCountUserPhotosArgs
    ContestParticipant?: boolean | UserCountOutputTypeCountContestParticipantArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedContestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentProvidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPhotoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContestParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestParticipantWhereInput
  }


  /**
   * Count Type UserPhotoCountOutputType
   */

  export type UserPhotoCountOutputType = {
    contestUpload: number
    likes: number
  }

  export type UserPhotoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contestUpload?: boolean | UserPhotoCountOutputTypeCountContestUploadArgs
    likes?: boolean | UserPhotoCountOutputTypeCountLikesArgs
  }

  // Custom InputTypes
  /**
   * UserPhotoCountOutputType without action
   */
  export type UserPhotoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhotoCountOutputType
     */
    select?: UserPhotoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserPhotoCountOutputType without action
   */
  export type UserPhotoCountOutputTypeCountContestUploadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestPhotoWhereInput
  }

  /**
   * UserPhotoCountOutputType without action
   */
  export type UserPhotoCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model RecurringData
   */





  export type RecurringDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recurringType?: boolean
    previousOccurrence?: boolean
    nextOccurrence?: boolean
    duration?: boolean
  }, ExtArgs["result"]["recurringData"]>



  export type RecurringDataSelectScalar = {
    recurringType?: boolean
    previousOccurrence?: boolean
    nextOccurrence?: boolean
    duration?: boolean
  }

  export type RecurringDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"recurringType" | "previousOccurrence" | "nextOccurrence" | "duration", ExtArgs["result"]["recurringData"]>

  export type $RecurringDataPayload = {
    name: "RecurringData"
    objects: {}
    scalars: {
      recurringType: $Enums.RecurringType
      previousOccurrence: Date
      nextOccurrence: Date
      duration: number
    }
    composites: {}
  }

  type RecurringDataGetPayload<S extends boolean | null | undefined | RecurringDataDefaultArgs> = $Result.GetResult<Prisma.$RecurringDataPayload, S>





  /**
   * Fields of the RecurringData model
   */
  interface RecurringDataFieldRefs {
    readonly recurringType: FieldRef<"RecurringData", 'RecurringType'>
    readonly previousOccurrence: FieldRef<"RecurringData", 'DateTime'>
    readonly nextOccurrence: FieldRef<"RecurringData", 'DateTime'>
    readonly duration: FieldRef<"RecurringData", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RecurringData without action
   */
  export type RecurringDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringData
     */
    select?: RecurringDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringData
     */
    omit?: RecurringDataOmit<ExtArgs> | null
  }


  /**
   * Model PhotoStats
   */





  export type PhotoStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Composition?: boolean
    Content?: boolean
    Creativity?: boolean
    Technique?: boolean
  }, ExtArgs["result"]["photoStats"]>



  export type PhotoStatsSelectScalar = {
    Composition?: boolean
    Content?: boolean
    Creativity?: boolean
    Technique?: boolean
  }

  export type PhotoStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Composition" | "Content" | "Creativity" | "Technique", ExtArgs["result"]["photoStats"]>

  export type $PhotoStatsPayload = {
    name: "PhotoStats"
    objects: {}
    scalars: {
      Composition: number
      Content: number
      Creativity: number
      Technique: number
    }
    composites: {}
  }

  type PhotoStatsGetPayload<S extends boolean | null | undefined | PhotoStatsDefaultArgs> = $Result.GetResult<Prisma.$PhotoStatsPayload, S>





  /**
   * Fields of the PhotoStats model
   */
  interface PhotoStatsFieldRefs {
    readonly Composition: FieldRef<"PhotoStats", 'Int'>
    readonly Content: FieldRef<"PhotoStats", 'Int'>
    readonly Creativity: FieldRef<"PhotoStats", 'Int'>
    readonly Technique: FieldRef<"PhotoStats", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PhotoStats without action
   */
  export type PhotoStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoStats
     */
    select?: PhotoStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhotoStats
     */
    omit?: PhotoStatsOmit<ExtArgs> | null
  }


  /**
   * Model Contest
   */

  export type AggregateContest = {
    _count: ContestCountAggregateOutputType | null
    _avg: ContestAvgAggregateOutputType | null
    _sum: ContestSumAggregateOutputType | null
    _min: ContestMinAggregateOutputType | null
    _max: ContestMaxAggregateOutputType | null
  }

  export type ContestAvgAggregateOutputType = {
    maxUploads: number | null
    maxPrize: number | null
    minPrize: number | null
  }

  export type ContestSumAggregateOutputType = {
    maxUploads: number | null
    maxPrize: number | null
    minPrize: number | null
  }

  export type ContestMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    banner: string | null
    status: $Enums.ContestStatus | null
    maxUploads: number | null
    isMoneyContest: boolean | null
    maxPrize: number | null
    minPrize: number | null
    startDate: Date | null
    endDate: Date | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    banner: string | null
    status: $Enums.ContestStatus | null
    maxUploads: number | null
    isMoneyContest: boolean | null
    maxPrize: number | null
    minPrize: number | null
    startDate: Date | null
    endDate: Date | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestCountAggregateOutputType = {
    id: number
    title: number
    description: number
    banner: number
    status: number
    maxUploads: number
    isMoneyContest: number
    maxPrize: number
    minPrize: number
    startDate: number
    endDate: number
    creatorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContestAvgAggregateInputType = {
    maxUploads?: true
    maxPrize?: true
    minPrize?: true
  }

  export type ContestSumAggregateInputType = {
    maxUploads?: true
    maxPrize?: true
    minPrize?: true
  }

  export type ContestMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    banner?: true
    status?: true
    maxUploads?: true
    isMoneyContest?: true
    maxPrize?: true
    minPrize?: true
    startDate?: true
    endDate?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    banner?: true
    status?: true
    maxUploads?: true
    isMoneyContest?: true
    maxPrize?: true
    minPrize?: true
    startDate?: true
    endDate?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    banner?: true
    status?: true
    maxUploads?: true
    isMoneyContest?: true
    maxPrize?: true
    minPrize?: true
    startDate?: true
    endDate?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contest to aggregate.
     */
    where?: ContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contests to fetch.
     */
    orderBy?: ContestOrderByWithRelationInput | ContestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contests
    **/
    _count?: true | ContestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestMaxAggregateInputType
  }

  export type GetContestAggregateType<T extends ContestAggregateArgs> = {
        [P in keyof T & keyof AggregateContest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContest[P]>
      : GetScalarType<T[P], AggregateContest[P]>
  }




  export type ContestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestWhereInput
    orderBy?: ContestOrderByWithAggregationInput | ContestOrderByWithAggregationInput[]
    by: ContestScalarFieldEnum[] | ContestScalarFieldEnum
    having?: ContestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestCountAggregateInputType | true
    _avg?: ContestAvgAggregateInputType
    _sum?: ContestSumAggregateInputType
    _min?: ContestMinAggregateInputType
    _max?: ContestMaxAggregateInputType
  }

  export type ContestGroupByOutputType = {
    id: string
    title: string
    description: string
    banner: string | null
    status: $Enums.ContestStatus
    maxUploads: number | null
    isMoneyContest: boolean
    maxPrize: number | null
    minPrize: number | null
    startDate: Date
    endDate: Date
    creatorId: string
    createdAt: Date
    updatedAt: Date
    _count: ContestCountAggregateOutputType | null
    _avg: ContestAvgAggregateOutputType | null
    _sum: ContestSumAggregateOutputType | null
    _min: ContestMinAggregateOutputType | null
    _max: ContestMaxAggregateOutputType | null
  }

  type GetContestGroupByPayload<T extends ContestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestGroupByOutputType[P]>
            : GetScalarType<T[P], ContestGroupByOutputType[P]>
        }
      >
    >


  export type ContestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    banner?: boolean
    status?: boolean
    maxUploads?: boolean
    isMoneyContest?: boolean
    maxPrize?: boolean
    minPrize?: boolean
    startDate?: boolean
    endDate?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    participants?: boolean | Contest$participantsArgs<ExtArgs>
    votes?: boolean | Contest$votesArgs<ExtArgs>
    contestRules?: boolean | Contest$contestRulesArgs<ExtArgs>
    contestPrizes?: boolean | Contest$contestPrizesArgs<ExtArgs>
    recurringData?: boolean | Contest$recurringDataArgs<ExtArgs>
    _count?: boolean | ContestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contest"]>



  export type ContestSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    banner?: boolean
    status?: boolean
    maxUploads?: boolean
    isMoneyContest?: boolean
    maxPrize?: boolean
    minPrize?: boolean
    startDate?: boolean
    endDate?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "banner" | "status" | "maxUploads" | "isMoneyContest" | "maxPrize" | "minPrize" | "startDate" | "endDate" | "creatorId" | "createdAt" | "updatedAt", ExtArgs["result"]["contest"]>
  export type ContestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    participants?: boolean | Contest$participantsArgs<ExtArgs>
    votes?: boolean | Contest$votesArgs<ExtArgs>
    contestRules?: boolean | Contest$contestRulesArgs<ExtArgs>
    contestPrizes?: boolean | Contest$contestPrizesArgs<ExtArgs>
    recurringData?: boolean | Contest$recurringDataArgs<ExtArgs>
    _count?: boolean | ContestCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contest"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      participants: Prisma.$ContestParticipantPayload<ExtArgs>[]
      votes: Prisma.$VotePayload<ExtArgs>[]
      contestRules: Prisma.$ContestRulePayload<ExtArgs>[]
      contestPrizes: Prisma.$ContestPrizePayload<ExtArgs>[]
      recurringData: Prisma.$RecurringContestDataPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      banner: string | null
      status: $Enums.ContestStatus
      maxUploads: number | null
      isMoneyContest: boolean
      maxPrize: number | null
      minPrize: number | null
      startDate: Date
      endDate: Date
      creatorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contest"]>
    composites: {}
  }

  type ContestGetPayload<S extends boolean | null | undefined | ContestDefaultArgs> = $Result.GetResult<Prisma.$ContestPayload, S>

  type ContestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContestCountAggregateInputType | true
    }

  export interface ContestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contest'], meta: { name: 'Contest' } }
    /**
     * Find zero or one Contest that matches the filter.
     * @param {ContestFindUniqueArgs} args - Arguments to find a Contest
     * @example
     * // Get one Contest
     * const contest = await prisma.contest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContestFindUniqueArgs>(args: SelectSubset<T, ContestFindUniqueArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContestFindUniqueOrThrowArgs} args - Arguments to find a Contest
     * @example
     * // Get one Contest
     * const contest = await prisma.contest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContestFindUniqueOrThrowArgs>(args: SelectSubset<T, ContestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestFindFirstArgs} args - Arguments to find a Contest
     * @example
     * // Get one Contest
     * const contest = await prisma.contest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContestFindFirstArgs>(args?: SelectSubset<T, ContestFindFirstArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestFindFirstOrThrowArgs} args - Arguments to find a Contest
     * @example
     * // Get one Contest
     * const contest = await prisma.contest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContestFindFirstOrThrowArgs>(args?: SelectSubset<T, ContestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contests
     * const contests = await prisma.contest.findMany()
     * 
     * // Get first 10 Contests
     * const contests = await prisma.contest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contestWithIdOnly = await prisma.contest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContestFindManyArgs>(args?: SelectSubset<T, ContestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contest.
     * @param {ContestCreateArgs} args - Arguments to create a Contest.
     * @example
     * // Create one Contest
     * const Contest = await prisma.contest.create({
     *   data: {
     *     // ... data to create a Contest
     *   }
     * })
     * 
     */
    create<T extends ContestCreateArgs>(args: SelectSubset<T, ContestCreateArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contests.
     * @param {ContestCreateManyArgs} args - Arguments to create many Contests.
     * @example
     * // Create many Contests
     * const contest = await prisma.contest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContestCreateManyArgs>(args?: SelectSubset<T, ContestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contest.
     * @param {ContestDeleteArgs} args - Arguments to delete one Contest.
     * @example
     * // Delete one Contest
     * const Contest = await prisma.contest.delete({
     *   where: {
     *     // ... filter to delete one Contest
     *   }
     * })
     * 
     */
    delete<T extends ContestDeleteArgs>(args: SelectSubset<T, ContestDeleteArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contest.
     * @param {ContestUpdateArgs} args - Arguments to update one Contest.
     * @example
     * // Update one Contest
     * const contest = await prisma.contest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContestUpdateArgs>(args: SelectSubset<T, ContestUpdateArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contests.
     * @param {ContestDeleteManyArgs} args - Arguments to filter Contests to delete.
     * @example
     * // Delete a few Contests
     * const { count } = await prisma.contest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContestDeleteManyArgs>(args?: SelectSubset<T, ContestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contests
     * const contest = await prisma.contest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContestUpdateManyArgs>(args: SelectSubset<T, ContestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contest.
     * @param {ContestUpsertArgs} args - Arguments to update or create a Contest.
     * @example
     * // Update or create a Contest
     * const contest = await prisma.contest.upsert({
     *   create: {
     *     // ... data to create a Contest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contest we want to update
     *   }
     * })
     */
    upsert<T extends ContestUpsertArgs>(args: SelectSubset<T, ContestUpsertArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contests that matches the filter.
     * @param {ContestFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contest = await prisma.contest.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ContestFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Contest.
     * @param {ContestAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contest = await prisma.contest.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ContestAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Contests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestCountArgs} args - Arguments to filter Contests to count.
     * @example
     * // Count the number of Contests
     * const count = await prisma.contest.count({
     *   where: {
     *     // ... the filter for the Contests we want to count
     *   }
     * })
    **/
    count<T extends ContestCountArgs>(
      args?: Subset<T, ContestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestAggregateArgs>(args: Subset<T, ContestAggregateArgs>): Prisma.PrismaPromise<GetContestAggregateType<T>>

    /**
     * Group by Contest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContestGroupByArgs['orderBy'] }
        : { orderBy?: ContestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contest model
   */
  readonly fields: ContestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participants<T extends Contest$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Contest$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    votes<T extends Contest$votesArgs<ExtArgs> = {}>(args?: Subset<T, Contest$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contestRules<T extends Contest$contestRulesArgs<ExtArgs> = {}>(args?: Subset<T, Contest$contestRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contestPrizes<T extends Contest$contestPrizesArgs<ExtArgs> = {}>(args?: Subset<T, Contest$contestPrizesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestPrizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recurringData<T extends Contest$recurringDataArgs<ExtArgs> = {}>(args?: Subset<T, Contest$recurringDataArgs<ExtArgs>>): Prisma__RecurringContestDataClient<$Result.GetResult<Prisma.$RecurringContestDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contest model
   */
  interface ContestFieldRefs {
    readonly id: FieldRef<"Contest", 'String'>
    readonly title: FieldRef<"Contest", 'String'>
    readonly description: FieldRef<"Contest", 'String'>
    readonly banner: FieldRef<"Contest", 'String'>
    readonly status: FieldRef<"Contest", 'ContestStatus'>
    readonly maxUploads: FieldRef<"Contest", 'Int'>
    readonly isMoneyContest: FieldRef<"Contest", 'Boolean'>
    readonly maxPrize: FieldRef<"Contest", 'Int'>
    readonly minPrize: FieldRef<"Contest", 'Int'>
    readonly startDate: FieldRef<"Contest", 'DateTime'>
    readonly endDate: FieldRef<"Contest", 'DateTime'>
    readonly creatorId: FieldRef<"Contest", 'String'>
    readonly createdAt: FieldRef<"Contest", 'DateTime'>
    readonly updatedAt: FieldRef<"Contest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contest findUnique
   */
  export type ContestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * Filter, which Contest to fetch.
     */
    where: ContestWhereUniqueInput
  }

  /**
   * Contest findUniqueOrThrow
   */
  export type ContestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * Filter, which Contest to fetch.
     */
    where: ContestWhereUniqueInput
  }

  /**
   * Contest findFirst
   */
  export type ContestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * Filter, which Contest to fetch.
     */
    where?: ContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contests to fetch.
     */
    orderBy?: ContestOrderByWithRelationInput | ContestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contests.
     */
    cursor?: ContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contests.
     */
    distinct?: ContestScalarFieldEnum | ContestScalarFieldEnum[]
  }

  /**
   * Contest findFirstOrThrow
   */
  export type ContestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * Filter, which Contest to fetch.
     */
    where?: ContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contests to fetch.
     */
    orderBy?: ContestOrderByWithRelationInput | ContestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contests.
     */
    cursor?: ContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contests.
     */
    distinct?: ContestScalarFieldEnum | ContestScalarFieldEnum[]
  }

  /**
   * Contest findMany
   */
  export type ContestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * Filter, which Contests to fetch.
     */
    where?: ContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contests to fetch.
     */
    orderBy?: ContestOrderByWithRelationInput | ContestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contests.
     */
    cursor?: ContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contests.
     */
    skip?: number
    distinct?: ContestScalarFieldEnum | ContestScalarFieldEnum[]
  }

  /**
   * Contest create
   */
  export type ContestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * The data needed to create a Contest.
     */
    data: XOR<ContestCreateInput, ContestUncheckedCreateInput>
  }

  /**
   * Contest createMany
   */
  export type ContestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contests.
     */
    data: ContestCreateManyInput | ContestCreateManyInput[]
  }

  /**
   * Contest update
   */
  export type ContestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * The data needed to update a Contest.
     */
    data: XOR<ContestUpdateInput, ContestUncheckedUpdateInput>
    /**
     * Choose, which Contest to update.
     */
    where: ContestWhereUniqueInput
  }

  /**
   * Contest updateMany
   */
  export type ContestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contests.
     */
    data: XOR<ContestUpdateManyMutationInput, ContestUncheckedUpdateManyInput>
    /**
     * Filter which Contests to update
     */
    where?: ContestWhereInput
    /**
     * Limit how many Contests to update.
     */
    limit?: number
  }

  /**
   * Contest upsert
   */
  export type ContestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * The filter to search for the Contest to update in case it exists.
     */
    where: ContestWhereUniqueInput
    /**
     * In case the Contest found by the `where` argument doesn't exist, create a new Contest with this data.
     */
    create: XOR<ContestCreateInput, ContestUncheckedCreateInput>
    /**
     * In case the Contest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContestUpdateInput, ContestUncheckedUpdateInput>
  }

  /**
   * Contest delete
   */
  export type ContestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    /**
     * Filter which Contest to delete.
     */
    where: ContestWhereUniqueInput
  }

  /**
   * Contest deleteMany
   */
  export type ContestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contests to delete
     */
    where?: ContestWhereInput
    /**
     * Limit how many Contests to delete.
     */
    limit?: number
  }

  /**
   * Contest findRaw
   */
  export type ContestFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Contest aggregateRaw
   */
  export type ContestAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Contest.participants
   */
  export type Contest$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    where?: ContestParticipantWhereInput
    orderBy?: ContestParticipantOrderByWithRelationInput | ContestParticipantOrderByWithRelationInput[]
    cursor?: ContestParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestParticipantScalarFieldEnum | ContestParticipantScalarFieldEnum[]
  }

  /**
   * Contest.votes
   */
  export type Contest$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    cursor?: VoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Contest.contestRules
   */
  export type Contest$contestRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
    where?: ContestRuleWhereInput
    orderBy?: ContestRuleOrderByWithRelationInput | ContestRuleOrderByWithRelationInput[]
    cursor?: ContestRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestRuleScalarFieldEnum | ContestRuleScalarFieldEnum[]
  }

  /**
   * Contest.contestPrizes
   */
  export type Contest$contestPrizesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
    where?: ContestPrizeWhereInput
    orderBy?: ContestPrizeOrderByWithRelationInput | ContestPrizeOrderByWithRelationInput[]
    cursor?: ContestPrizeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestPrizeScalarFieldEnum | ContestPrizeScalarFieldEnum[]
  }

  /**
   * Contest.recurringData
   */
  export type Contest$recurringDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContestData
     */
    select?: RecurringContestDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContestData
     */
    omit?: RecurringContestDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestDataInclude<ExtArgs> | null
    where?: RecurringContestDataWhereInput
  }

  /**
   * Contest without action
   */
  export type ContestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
  }


  /**
   * Model ContestRule
   */

  export type AggregateContestRule = {
    _count: ContestRuleCountAggregateOutputType | null
    _min: ContestRuleMinAggregateOutputType | null
    _max: ContestRuleMaxAggregateOutputType | null
  }

  export type ContestRuleMinAggregateOutputType = {
    id: string | null
    icon: string | null
    name: string | null
    description: string | null
    contestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestRuleMaxAggregateOutputType = {
    id: string | null
    icon: string | null
    name: string | null
    description: string | null
    contestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestRuleCountAggregateOutputType = {
    id: number
    icon: number
    name: number
    description: number
    contestId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContestRuleMinAggregateInputType = {
    id?: true
    icon?: true
    name?: true
    description?: true
    contestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestRuleMaxAggregateInputType = {
    id?: true
    icon?: true
    name?: true
    description?: true
    contestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestRuleCountAggregateInputType = {
    id?: true
    icon?: true
    name?: true
    description?: true
    contestId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContestRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestRule to aggregate.
     */
    where?: ContestRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestRules to fetch.
     */
    orderBy?: ContestRuleOrderByWithRelationInput | ContestRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContestRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContestRules
    **/
    _count?: true | ContestRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestRuleMaxAggregateInputType
  }

  export type GetContestRuleAggregateType<T extends ContestRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateContestRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContestRule[P]>
      : GetScalarType<T[P], AggregateContestRule[P]>
  }




  export type ContestRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestRuleWhereInput
    orderBy?: ContestRuleOrderByWithAggregationInput | ContestRuleOrderByWithAggregationInput[]
    by: ContestRuleScalarFieldEnum[] | ContestRuleScalarFieldEnum
    having?: ContestRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestRuleCountAggregateInputType | true
    _min?: ContestRuleMinAggregateInputType
    _max?: ContestRuleMaxAggregateInputType
  }

  export type ContestRuleGroupByOutputType = {
    id: string
    icon: string | null
    name: string
    description: string
    contestId: string
    createdAt: Date
    updatedAt: Date
    _count: ContestRuleCountAggregateOutputType | null
    _min: ContestRuleMinAggregateOutputType | null
    _max: ContestRuleMaxAggregateOutputType | null
  }

  type GetContestRuleGroupByPayload<T extends ContestRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestRuleGroupByOutputType[P]>
            : GetScalarType<T[P], ContestRuleGroupByOutputType[P]>
        }
      >
    >


  export type ContestRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    icon?: boolean
    name?: boolean
    description?: boolean
    contestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contest?: boolean | ContestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contestRule"]>



  export type ContestRuleSelectScalar = {
    id?: boolean
    icon?: boolean
    name?: boolean
    description?: boolean
    contestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContestRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "icon" | "name" | "description" | "contestId" | "createdAt" | "updatedAt", ExtArgs["result"]["contestRule"]>
  export type ContestRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contest?: boolean | ContestDefaultArgs<ExtArgs>
  }

  export type $ContestRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContestRule"
    objects: {
      contest: Prisma.$ContestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      icon: string | null
      name: string
      description: string
      contestId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contestRule"]>
    composites: {}
  }

  type ContestRuleGetPayload<S extends boolean | null | undefined | ContestRuleDefaultArgs> = $Result.GetResult<Prisma.$ContestRulePayload, S>

  type ContestRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContestRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContestRuleCountAggregateInputType | true
    }

  export interface ContestRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContestRule'], meta: { name: 'ContestRule' } }
    /**
     * Find zero or one ContestRule that matches the filter.
     * @param {ContestRuleFindUniqueArgs} args - Arguments to find a ContestRule
     * @example
     * // Get one ContestRule
     * const contestRule = await prisma.contestRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContestRuleFindUniqueArgs>(args: SelectSubset<T, ContestRuleFindUniqueArgs<ExtArgs>>): Prisma__ContestRuleClient<$Result.GetResult<Prisma.$ContestRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContestRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContestRuleFindUniqueOrThrowArgs} args - Arguments to find a ContestRule
     * @example
     * // Get one ContestRule
     * const contestRule = await prisma.contestRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContestRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ContestRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContestRuleClient<$Result.GetResult<Prisma.$ContestRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestRuleFindFirstArgs} args - Arguments to find a ContestRule
     * @example
     * // Get one ContestRule
     * const contestRule = await prisma.contestRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContestRuleFindFirstArgs>(args?: SelectSubset<T, ContestRuleFindFirstArgs<ExtArgs>>): Prisma__ContestRuleClient<$Result.GetResult<Prisma.$ContestRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestRuleFindFirstOrThrowArgs} args - Arguments to find a ContestRule
     * @example
     * // Get one ContestRule
     * const contestRule = await prisma.contestRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContestRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ContestRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContestRuleClient<$Result.GetResult<Prisma.$ContestRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContestRules
     * const contestRules = await prisma.contestRule.findMany()
     * 
     * // Get first 10 ContestRules
     * const contestRules = await prisma.contestRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contestRuleWithIdOnly = await prisma.contestRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContestRuleFindManyArgs>(args?: SelectSubset<T, ContestRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContestRule.
     * @param {ContestRuleCreateArgs} args - Arguments to create a ContestRule.
     * @example
     * // Create one ContestRule
     * const ContestRule = await prisma.contestRule.create({
     *   data: {
     *     // ... data to create a ContestRule
     *   }
     * })
     * 
     */
    create<T extends ContestRuleCreateArgs>(args: SelectSubset<T, ContestRuleCreateArgs<ExtArgs>>): Prisma__ContestRuleClient<$Result.GetResult<Prisma.$ContestRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContestRules.
     * @param {ContestRuleCreateManyArgs} args - Arguments to create many ContestRules.
     * @example
     * // Create many ContestRules
     * const contestRule = await prisma.contestRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContestRuleCreateManyArgs>(args?: SelectSubset<T, ContestRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContestRule.
     * @param {ContestRuleDeleteArgs} args - Arguments to delete one ContestRule.
     * @example
     * // Delete one ContestRule
     * const ContestRule = await prisma.contestRule.delete({
     *   where: {
     *     // ... filter to delete one ContestRule
     *   }
     * })
     * 
     */
    delete<T extends ContestRuleDeleteArgs>(args: SelectSubset<T, ContestRuleDeleteArgs<ExtArgs>>): Prisma__ContestRuleClient<$Result.GetResult<Prisma.$ContestRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContestRule.
     * @param {ContestRuleUpdateArgs} args - Arguments to update one ContestRule.
     * @example
     * // Update one ContestRule
     * const contestRule = await prisma.contestRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContestRuleUpdateArgs>(args: SelectSubset<T, ContestRuleUpdateArgs<ExtArgs>>): Prisma__ContestRuleClient<$Result.GetResult<Prisma.$ContestRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContestRules.
     * @param {ContestRuleDeleteManyArgs} args - Arguments to filter ContestRules to delete.
     * @example
     * // Delete a few ContestRules
     * const { count } = await prisma.contestRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContestRuleDeleteManyArgs>(args?: SelectSubset<T, ContestRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContestRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContestRules
     * const contestRule = await prisma.contestRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContestRuleUpdateManyArgs>(args: SelectSubset<T, ContestRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContestRule.
     * @param {ContestRuleUpsertArgs} args - Arguments to update or create a ContestRule.
     * @example
     * // Update or create a ContestRule
     * const contestRule = await prisma.contestRule.upsert({
     *   create: {
     *     // ... data to create a ContestRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContestRule we want to update
     *   }
     * })
     */
    upsert<T extends ContestRuleUpsertArgs>(args: SelectSubset<T, ContestRuleUpsertArgs<ExtArgs>>): Prisma__ContestRuleClient<$Result.GetResult<Prisma.$ContestRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestRules that matches the filter.
     * @param {ContestRuleFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contestRule = await prisma.contestRule.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ContestRuleFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ContestRule.
     * @param {ContestRuleAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contestRule = await prisma.contestRule.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ContestRuleAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ContestRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestRuleCountArgs} args - Arguments to filter ContestRules to count.
     * @example
     * // Count the number of ContestRules
     * const count = await prisma.contestRule.count({
     *   where: {
     *     // ... the filter for the ContestRules we want to count
     *   }
     * })
    **/
    count<T extends ContestRuleCountArgs>(
      args?: Subset<T, ContestRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContestRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestRuleAggregateArgs>(args: Subset<T, ContestRuleAggregateArgs>): Prisma.PrismaPromise<GetContestRuleAggregateType<T>>

    /**
     * Group by ContestRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContestRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContestRuleGroupByArgs['orderBy'] }
        : { orderBy?: ContestRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContestRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContestRule model
   */
  readonly fields: ContestRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContestRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContestRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contest<T extends ContestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestDefaultArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContestRule model
   */
  interface ContestRuleFieldRefs {
    readonly id: FieldRef<"ContestRule", 'String'>
    readonly icon: FieldRef<"ContestRule", 'String'>
    readonly name: FieldRef<"ContestRule", 'String'>
    readonly description: FieldRef<"ContestRule", 'String'>
    readonly contestId: FieldRef<"ContestRule", 'String'>
    readonly createdAt: FieldRef<"ContestRule", 'DateTime'>
    readonly updatedAt: FieldRef<"ContestRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContestRule findUnique
   */
  export type ContestRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
    /**
     * Filter, which ContestRule to fetch.
     */
    where: ContestRuleWhereUniqueInput
  }

  /**
   * ContestRule findUniqueOrThrow
   */
  export type ContestRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
    /**
     * Filter, which ContestRule to fetch.
     */
    where: ContestRuleWhereUniqueInput
  }

  /**
   * ContestRule findFirst
   */
  export type ContestRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
    /**
     * Filter, which ContestRule to fetch.
     */
    where?: ContestRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestRules to fetch.
     */
    orderBy?: ContestRuleOrderByWithRelationInput | ContestRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestRules.
     */
    cursor?: ContestRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestRules.
     */
    distinct?: ContestRuleScalarFieldEnum | ContestRuleScalarFieldEnum[]
  }

  /**
   * ContestRule findFirstOrThrow
   */
  export type ContestRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
    /**
     * Filter, which ContestRule to fetch.
     */
    where?: ContestRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestRules to fetch.
     */
    orderBy?: ContestRuleOrderByWithRelationInput | ContestRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestRules.
     */
    cursor?: ContestRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestRules.
     */
    distinct?: ContestRuleScalarFieldEnum | ContestRuleScalarFieldEnum[]
  }

  /**
   * ContestRule findMany
   */
  export type ContestRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
    /**
     * Filter, which ContestRules to fetch.
     */
    where?: ContestRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestRules to fetch.
     */
    orderBy?: ContestRuleOrderByWithRelationInput | ContestRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContestRules.
     */
    cursor?: ContestRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestRules.
     */
    skip?: number
    distinct?: ContestRuleScalarFieldEnum | ContestRuleScalarFieldEnum[]
  }

  /**
   * ContestRule create
   */
  export type ContestRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a ContestRule.
     */
    data: XOR<ContestRuleCreateInput, ContestRuleUncheckedCreateInput>
  }

  /**
   * ContestRule createMany
   */
  export type ContestRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContestRules.
     */
    data: ContestRuleCreateManyInput | ContestRuleCreateManyInput[]
  }

  /**
   * ContestRule update
   */
  export type ContestRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a ContestRule.
     */
    data: XOR<ContestRuleUpdateInput, ContestRuleUncheckedUpdateInput>
    /**
     * Choose, which ContestRule to update.
     */
    where: ContestRuleWhereUniqueInput
  }

  /**
   * ContestRule updateMany
   */
  export type ContestRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContestRules.
     */
    data: XOR<ContestRuleUpdateManyMutationInput, ContestRuleUncheckedUpdateManyInput>
    /**
     * Filter which ContestRules to update
     */
    where?: ContestRuleWhereInput
    /**
     * Limit how many ContestRules to update.
     */
    limit?: number
  }

  /**
   * ContestRule upsert
   */
  export type ContestRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the ContestRule to update in case it exists.
     */
    where: ContestRuleWhereUniqueInput
    /**
     * In case the ContestRule found by the `where` argument doesn't exist, create a new ContestRule with this data.
     */
    create: XOR<ContestRuleCreateInput, ContestRuleUncheckedCreateInput>
    /**
     * In case the ContestRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContestRuleUpdateInput, ContestRuleUncheckedUpdateInput>
  }

  /**
   * ContestRule delete
   */
  export type ContestRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
    /**
     * Filter which ContestRule to delete.
     */
    where: ContestRuleWhereUniqueInput
  }

  /**
   * ContestRule deleteMany
   */
  export type ContestRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestRules to delete
     */
    where?: ContestRuleWhereInput
    /**
     * Limit how many ContestRules to delete.
     */
    limit?: number
  }

  /**
   * ContestRule findRaw
   */
  export type ContestRuleFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestRule aggregateRaw
   */
  export type ContestRuleAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestRule without action
   */
  export type ContestRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestRule
     */
    select?: ContestRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestRule
     */
    omit?: ContestRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestRuleInclude<ExtArgs> | null
  }


  /**
   * Model RecurringContestData
   */

  export type AggregateRecurringContestData = {
    _count: RecurringContestDataCountAggregateOutputType | null
    _min: RecurringContestDataMinAggregateOutputType | null
    _max: RecurringContestDataMaxAggregateOutputType | null
  }

  export type RecurringContestDataMinAggregateOutputType = {
    id: string | null
    constestId: string | null
    lastRunAt: Date | null
    nextRunAt: Date | null
  }

  export type RecurringContestDataMaxAggregateOutputType = {
    id: string | null
    constestId: string | null
    lastRunAt: Date | null
    nextRunAt: Date | null
  }

  export type RecurringContestDataCountAggregateOutputType = {
    id: number
    constestId: number
    lastRunAt: number
    nextRunAt: number
    _all: number
  }


  export type RecurringContestDataMinAggregateInputType = {
    id?: true
    constestId?: true
    lastRunAt?: true
    nextRunAt?: true
  }

  export type RecurringContestDataMaxAggregateInputType = {
    id?: true
    constestId?: true
    lastRunAt?: true
    nextRunAt?: true
  }

  export type RecurringContestDataCountAggregateInputType = {
    id?: true
    constestId?: true
    lastRunAt?: true
    nextRunAt?: true
    _all?: true
  }

  export type RecurringContestDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringContestData to aggregate.
     */
    where?: RecurringContestDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringContestData to fetch.
     */
    orderBy?: RecurringContestDataOrderByWithRelationInput | RecurringContestDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecurringContestDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringContestData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringContestData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecurringContestData
    **/
    _count?: true | RecurringContestDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecurringContestDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecurringContestDataMaxAggregateInputType
  }

  export type GetRecurringContestDataAggregateType<T extends RecurringContestDataAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurringContestData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurringContestData[P]>
      : GetScalarType<T[P], AggregateRecurringContestData[P]>
  }




  export type RecurringContestDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringContestDataWhereInput
    orderBy?: RecurringContestDataOrderByWithAggregationInput | RecurringContestDataOrderByWithAggregationInput[]
    by: RecurringContestDataScalarFieldEnum[] | RecurringContestDataScalarFieldEnum
    having?: RecurringContestDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecurringContestDataCountAggregateInputType | true
    _min?: RecurringContestDataMinAggregateInputType
    _max?: RecurringContestDataMaxAggregateInputType
  }

  export type RecurringContestDataGroupByOutputType = {
    id: string
    constestId: string
    lastRunAt: Date | null
    nextRunAt: Date
    _count: RecurringContestDataCountAggregateOutputType | null
    _min: RecurringContestDataMinAggregateOutputType | null
    _max: RecurringContestDataMaxAggregateOutputType | null
  }

  type GetRecurringContestDataGroupByPayload<T extends RecurringContestDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecurringContestDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecurringContestDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecurringContestDataGroupByOutputType[P]>
            : GetScalarType<T[P], RecurringContestDataGroupByOutputType[P]>
        }
      >
    >


  export type RecurringContestDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    constestId?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
    contest?: boolean | ContestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringContestData"]>



  export type RecurringContestDataSelectScalar = {
    id?: boolean
    constestId?: boolean
    lastRunAt?: boolean
    nextRunAt?: boolean
  }

  export type RecurringContestDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "constestId" | "lastRunAt" | "nextRunAt", ExtArgs["result"]["recurringContestData"]>
  export type RecurringContestDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contest?: boolean | ContestDefaultArgs<ExtArgs>
  }

  export type $RecurringContestDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecurringContestData"
    objects: {
      contest: Prisma.$ContestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      constestId: string
      lastRunAt: Date | null
      nextRunAt: Date
    }, ExtArgs["result"]["recurringContestData"]>
    composites: {}
  }

  type RecurringContestDataGetPayload<S extends boolean | null | undefined | RecurringContestDataDefaultArgs> = $Result.GetResult<Prisma.$RecurringContestDataPayload, S>

  type RecurringContestDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecurringContestDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecurringContestDataCountAggregateInputType | true
    }

  export interface RecurringContestDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecurringContestData'], meta: { name: 'RecurringContestData' } }
    /**
     * Find zero or one RecurringContestData that matches the filter.
     * @param {RecurringContestDataFindUniqueArgs} args - Arguments to find a RecurringContestData
     * @example
     * // Get one RecurringContestData
     * const recurringContestData = await prisma.recurringContestData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecurringContestDataFindUniqueArgs>(args: SelectSubset<T, RecurringContestDataFindUniqueArgs<ExtArgs>>): Prisma__RecurringContestDataClient<$Result.GetResult<Prisma.$RecurringContestDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecurringContestData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecurringContestDataFindUniqueOrThrowArgs} args - Arguments to find a RecurringContestData
     * @example
     * // Get one RecurringContestData
     * const recurringContestData = await prisma.recurringContestData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecurringContestDataFindUniqueOrThrowArgs>(args: SelectSubset<T, RecurringContestDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecurringContestDataClient<$Result.GetResult<Prisma.$RecurringContestDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringContestData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestDataFindFirstArgs} args - Arguments to find a RecurringContestData
     * @example
     * // Get one RecurringContestData
     * const recurringContestData = await prisma.recurringContestData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecurringContestDataFindFirstArgs>(args?: SelectSubset<T, RecurringContestDataFindFirstArgs<ExtArgs>>): Prisma__RecurringContestDataClient<$Result.GetResult<Prisma.$RecurringContestDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringContestData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestDataFindFirstOrThrowArgs} args - Arguments to find a RecurringContestData
     * @example
     * // Get one RecurringContestData
     * const recurringContestData = await prisma.recurringContestData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecurringContestDataFindFirstOrThrowArgs>(args?: SelectSubset<T, RecurringContestDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecurringContestDataClient<$Result.GetResult<Prisma.$RecurringContestDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecurringContestData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecurringContestData
     * const recurringContestData = await prisma.recurringContestData.findMany()
     * 
     * // Get first 10 RecurringContestData
     * const recurringContestData = await prisma.recurringContestData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recurringContestDataWithIdOnly = await prisma.recurringContestData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecurringContestDataFindManyArgs>(args?: SelectSubset<T, RecurringContestDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringContestDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecurringContestData.
     * @param {RecurringContestDataCreateArgs} args - Arguments to create a RecurringContestData.
     * @example
     * // Create one RecurringContestData
     * const RecurringContestData = await prisma.recurringContestData.create({
     *   data: {
     *     // ... data to create a RecurringContestData
     *   }
     * })
     * 
     */
    create<T extends RecurringContestDataCreateArgs>(args: SelectSubset<T, RecurringContestDataCreateArgs<ExtArgs>>): Prisma__RecurringContestDataClient<$Result.GetResult<Prisma.$RecurringContestDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecurringContestData.
     * @param {RecurringContestDataCreateManyArgs} args - Arguments to create many RecurringContestData.
     * @example
     * // Create many RecurringContestData
     * const recurringContestData = await prisma.recurringContestData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecurringContestDataCreateManyArgs>(args?: SelectSubset<T, RecurringContestDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RecurringContestData.
     * @param {RecurringContestDataDeleteArgs} args - Arguments to delete one RecurringContestData.
     * @example
     * // Delete one RecurringContestData
     * const RecurringContestData = await prisma.recurringContestData.delete({
     *   where: {
     *     // ... filter to delete one RecurringContestData
     *   }
     * })
     * 
     */
    delete<T extends RecurringContestDataDeleteArgs>(args: SelectSubset<T, RecurringContestDataDeleteArgs<ExtArgs>>): Prisma__RecurringContestDataClient<$Result.GetResult<Prisma.$RecurringContestDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecurringContestData.
     * @param {RecurringContestDataUpdateArgs} args - Arguments to update one RecurringContestData.
     * @example
     * // Update one RecurringContestData
     * const recurringContestData = await prisma.recurringContestData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecurringContestDataUpdateArgs>(args: SelectSubset<T, RecurringContestDataUpdateArgs<ExtArgs>>): Prisma__RecurringContestDataClient<$Result.GetResult<Prisma.$RecurringContestDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecurringContestData.
     * @param {RecurringContestDataDeleteManyArgs} args - Arguments to filter RecurringContestData to delete.
     * @example
     * // Delete a few RecurringContestData
     * const { count } = await prisma.recurringContestData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecurringContestDataDeleteManyArgs>(args?: SelectSubset<T, RecurringContestDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringContestData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecurringContestData
     * const recurringContestData = await prisma.recurringContestData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecurringContestDataUpdateManyArgs>(args: SelectSubset<T, RecurringContestDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecurringContestData.
     * @param {RecurringContestDataUpsertArgs} args - Arguments to update or create a RecurringContestData.
     * @example
     * // Update or create a RecurringContestData
     * const recurringContestData = await prisma.recurringContestData.upsert({
     *   create: {
     *     // ... data to create a RecurringContestData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecurringContestData we want to update
     *   }
     * })
     */
    upsert<T extends RecurringContestDataUpsertArgs>(args: SelectSubset<T, RecurringContestDataUpsertArgs<ExtArgs>>): Prisma__RecurringContestDataClient<$Result.GetResult<Prisma.$RecurringContestDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecurringContestData that matches the filter.
     * @param {RecurringContestDataFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const recurringContestData = await prisma.recurringContestData.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: RecurringContestDataFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a RecurringContestData.
     * @param {RecurringContestDataAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const recurringContestData = await prisma.recurringContestData.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: RecurringContestDataAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of RecurringContestData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestDataCountArgs} args - Arguments to filter RecurringContestData to count.
     * @example
     * // Count the number of RecurringContestData
     * const count = await prisma.recurringContestData.count({
     *   where: {
     *     // ... the filter for the RecurringContestData we want to count
     *   }
     * })
    **/
    count<T extends RecurringContestDataCountArgs>(
      args?: Subset<T, RecurringContestDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecurringContestDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecurringContestData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecurringContestDataAggregateArgs>(args: Subset<T, RecurringContestDataAggregateArgs>): Prisma.PrismaPromise<GetRecurringContestDataAggregateType<T>>

    /**
     * Group by RecurringContestData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecurringContestDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecurringContestDataGroupByArgs['orderBy'] }
        : { orderBy?: RecurringContestDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecurringContestDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecurringContestDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecurringContestData model
   */
  readonly fields: RecurringContestDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecurringContestData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecurringContestDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contest<T extends ContestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestDefaultArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecurringContestData model
   */
  interface RecurringContestDataFieldRefs {
    readonly id: FieldRef<"RecurringContestData", 'String'>
    readonly constestId: FieldRef<"RecurringContestData", 'String'>
    readonly lastRunAt: FieldRef<"RecurringContestData", 'DateTime'>
    readonly nextRunAt: FieldRef<"RecurringContestData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecurringContestData findUnique
   */
  export type RecurringContestDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContestData
     */
    select?: RecurringContestDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContestData
     */
    omit?: RecurringContestDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestDataInclude<ExtArgs> | null
    /**
     * Filter, which RecurringContestData to fetch.
     */
    where: RecurringContestDataWhereUniqueInput
  }

  /**
   * RecurringContestData findUniqueOrThrow
   */
  export type RecurringContestDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContestData
     */
    select?: RecurringContestDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContestData
     */
    omit?: RecurringContestDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestDataInclude<ExtArgs> | null
    /**
     * Filter, which RecurringContestData to fetch.
     */
    where: RecurringContestDataWhereUniqueInput
  }

  /**
   * RecurringContestData findFirst
   */
  export type RecurringContestDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContestData
     */
    select?: RecurringContestDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContestData
     */
    omit?: RecurringContestDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestDataInclude<ExtArgs> | null
    /**
     * Filter, which RecurringContestData to fetch.
     */
    where?: RecurringContestDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringContestData to fetch.
     */
    orderBy?: RecurringContestDataOrderByWithRelationInput | RecurringContestDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringContestData.
     */
    cursor?: RecurringContestDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringContestData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringContestData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringContestData.
     */
    distinct?: RecurringContestDataScalarFieldEnum | RecurringContestDataScalarFieldEnum[]
  }

  /**
   * RecurringContestData findFirstOrThrow
   */
  export type RecurringContestDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContestData
     */
    select?: RecurringContestDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContestData
     */
    omit?: RecurringContestDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestDataInclude<ExtArgs> | null
    /**
     * Filter, which RecurringContestData to fetch.
     */
    where?: RecurringContestDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringContestData to fetch.
     */
    orderBy?: RecurringContestDataOrderByWithRelationInput | RecurringContestDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringContestData.
     */
    cursor?: RecurringContestDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringContestData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringContestData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringContestData.
     */
    distinct?: RecurringContestDataScalarFieldEnum | RecurringContestDataScalarFieldEnum[]
  }

  /**
   * RecurringContestData findMany
   */
  export type RecurringContestDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContestData
     */
    select?: RecurringContestDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContestData
     */
    omit?: RecurringContestDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestDataInclude<ExtArgs> | null
    /**
     * Filter, which RecurringContestData to fetch.
     */
    where?: RecurringContestDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringContestData to fetch.
     */
    orderBy?: RecurringContestDataOrderByWithRelationInput | RecurringContestDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecurringContestData.
     */
    cursor?: RecurringContestDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringContestData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringContestData.
     */
    skip?: number
    distinct?: RecurringContestDataScalarFieldEnum | RecurringContestDataScalarFieldEnum[]
  }

  /**
   * RecurringContestData create
   */
  export type RecurringContestDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContestData
     */
    select?: RecurringContestDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContestData
     */
    omit?: RecurringContestDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestDataInclude<ExtArgs> | null
    /**
     * The data needed to create a RecurringContestData.
     */
    data: XOR<RecurringContestDataCreateInput, RecurringContestDataUncheckedCreateInput>
  }

  /**
   * RecurringContestData createMany
   */
  export type RecurringContestDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecurringContestData.
     */
    data: RecurringContestDataCreateManyInput | RecurringContestDataCreateManyInput[]
  }

  /**
   * RecurringContestData update
   */
  export type RecurringContestDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContestData
     */
    select?: RecurringContestDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContestData
     */
    omit?: RecurringContestDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestDataInclude<ExtArgs> | null
    /**
     * The data needed to update a RecurringContestData.
     */
    data: XOR<RecurringContestDataUpdateInput, RecurringContestDataUncheckedUpdateInput>
    /**
     * Choose, which RecurringContestData to update.
     */
    where: RecurringContestDataWhereUniqueInput
  }

  /**
   * RecurringContestData updateMany
   */
  export type RecurringContestDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecurringContestData.
     */
    data: XOR<RecurringContestDataUpdateManyMutationInput, RecurringContestDataUncheckedUpdateManyInput>
    /**
     * Filter which RecurringContestData to update
     */
    where?: RecurringContestDataWhereInput
    /**
     * Limit how many RecurringContestData to update.
     */
    limit?: number
  }

  /**
   * RecurringContestData upsert
   */
  export type RecurringContestDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContestData
     */
    select?: RecurringContestDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContestData
     */
    omit?: RecurringContestDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestDataInclude<ExtArgs> | null
    /**
     * The filter to search for the RecurringContestData to update in case it exists.
     */
    where: RecurringContestDataWhereUniqueInput
    /**
     * In case the RecurringContestData found by the `where` argument doesn't exist, create a new RecurringContestData with this data.
     */
    create: XOR<RecurringContestDataCreateInput, RecurringContestDataUncheckedCreateInput>
    /**
     * In case the RecurringContestData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecurringContestDataUpdateInput, RecurringContestDataUncheckedUpdateInput>
  }

  /**
   * RecurringContestData delete
   */
  export type RecurringContestDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContestData
     */
    select?: RecurringContestDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContestData
     */
    omit?: RecurringContestDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestDataInclude<ExtArgs> | null
    /**
     * Filter which RecurringContestData to delete.
     */
    where: RecurringContestDataWhereUniqueInput
  }

  /**
   * RecurringContestData deleteMany
   */
  export type RecurringContestDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringContestData to delete
     */
    where?: RecurringContestDataWhereInput
    /**
     * Limit how many RecurringContestData to delete.
     */
    limit?: number
  }

  /**
   * RecurringContestData findRaw
   */
  export type RecurringContestDataFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * RecurringContestData aggregateRaw
   */
  export type RecurringContestDataAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * RecurringContestData without action
   */
  export type RecurringContestDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContestData
     */
    select?: RecurringContestDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContestData
     */
    omit?: RecurringContestDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestDataInclude<ExtArgs> | null
  }


  /**
   * Model RecurringContest
   */

  export type AggregateRecurringContest = {
    _count: RecurringContestCountAggregateOutputType | null
    _avg: RecurringContestAvgAggregateOutputType | null
    _sum: RecurringContestSumAggregateOutputType | null
    _min: RecurringContestMinAggregateOutputType | null
    _max: RecurringContestMaxAggregateOutputType | null
  }

  export type RecurringContestAvgAggregateOutputType = {
    maxUploads: number | null
    maxPrize: number | null
    minPrize: number | null
  }

  export type RecurringContestSumAggregateOutputType = {
    maxUploads: number | null
    maxPrize: number | null
    minPrize: number | null
  }

  export type RecurringContestMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    title: string | null
    description: string | null
    banner: string | null
    maxUploads: number | null
    isMoneyContest: boolean | null
    maxPrize: number | null
    minPrize: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringContestMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    title: string | null
    description: string | null
    banner: string | null
    maxUploads: number | null
    isMoneyContest: boolean | null
    maxPrize: number | null
    minPrize: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecurringContestCountAggregateOutputType = {
    id: number
    creatorId: number
    title: number
    description: number
    banner: number
    maxUploads: number
    isMoneyContest: number
    maxPrize: number
    minPrize: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecurringContestAvgAggregateInputType = {
    maxUploads?: true
    maxPrize?: true
    minPrize?: true
  }

  export type RecurringContestSumAggregateInputType = {
    maxUploads?: true
    maxPrize?: true
    minPrize?: true
  }

  export type RecurringContestMinAggregateInputType = {
    id?: true
    creatorId?: true
    title?: true
    description?: true
    banner?: true
    maxUploads?: true
    isMoneyContest?: true
    maxPrize?: true
    minPrize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringContestMaxAggregateInputType = {
    id?: true
    creatorId?: true
    title?: true
    description?: true
    banner?: true
    maxUploads?: true
    isMoneyContest?: true
    maxPrize?: true
    minPrize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecurringContestCountAggregateInputType = {
    id?: true
    creatorId?: true
    title?: true
    description?: true
    banner?: true
    maxUploads?: true
    isMoneyContest?: true
    maxPrize?: true
    minPrize?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecurringContestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringContest to aggregate.
     */
    where?: RecurringContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringContests to fetch.
     */
    orderBy?: RecurringContestOrderByWithRelationInput | RecurringContestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecurringContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringContests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringContests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecurringContests
    **/
    _count?: true | RecurringContestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecurringContestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecurringContestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecurringContestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecurringContestMaxAggregateInputType
  }

  export type GetRecurringContestAggregateType<T extends RecurringContestAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurringContest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurringContest[P]>
      : GetScalarType<T[P], AggregateRecurringContest[P]>
  }




  export type RecurringContestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringContestWhereInput
    orderBy?: RecurringContestOrderByWithAggregationInput | RecurringContestOrderByWithAggregationInput[]
    by: RecurringContestScalarFieldEnum[] | RecurringContestScalarFieldEnum
    having?: RecurringContestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecurringContestCountAggregateInputType | true
    _avg?: RecurringContestAvgAggregateInputType
    _sum?: RecurringContestSumAggregateInputType
    _min?: RecurringContestMinAggregateInputType
    _max?: RecurringContestMaxAggregateInputType
  }

  export type RecurringContestGroupByOutputType = {
    id: string
    creatorId: string
    title: string
    description: string
    banner: string | null
    maxUploads: number | null
    isMoneyContest: boolean
    maxPrize: number | null
    minPrize: number | null
    createdAt: Date
    updatedAt: Date
    _count: RecurringContestCountAggregateOutputType | null
    _avg: RecurringContestAvgAggregateOutputType | null
    _sum: RecurringContestSumAggregateOutputType | null
    _min: RecurringContestMinAggregateOutputType | null
    _max: RecurringContestMaxAggregateOutputType | null
  }

  type GetRecurringContestGroupByPayload<T extends RecurringContestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecurringContestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecurringContestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecurringContestGroupByOutputType[P]>
            : GetScalarType<T[P], RecurringContestGroupByOutputType[P]>
        }
      >
    >


  export type RecurringContestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    banner?: boolean
    maxUploads?: boolean
    isMoneyContest?: boolean
    maxPrize?: boolean
    minPrize?: boolean
    recurringData?: boolean | RecurringDataDefaultArgs<ExtArgs>
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["recurringContest"]>



  export type RecurringContestSelectScalar = {
    id?: boolean
    creatorId?: boolean
    title?: boolean
    description?: boolean
    banner?: boolean
    maxUploads?: boolean
    isMoneyContest?: boolean
    maxPrize?: boolean
    minPrize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RecurringContestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creatorId" | "title" | "description" | "banner" | "maxUploads" | "isMoneyContest" | "maxPrize" | "minPrize" | "recurringData" | "createdAt" | "updatedAt", ExtArgs["result"]["recurringContest"]>
  export type RecurringContestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RecurringContestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecurringContest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string
      title: string
      description: string
      banner: string | null
      maxUploads: number | null
      isMoneyContest: boolean
      maxPrize: number | null
      minPrize: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recurringContest"]>
    composites: {
      recurringData: Prisma.$RecurringDataPayload
    }
  }

  type RecurringContestGetPayload<S extends boolean | null | undefined | RecurringContestDefaultArgs> = $Result.GetResult<Prisma.$RecurringContestPayload, S>

  type RecurringContestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecurringContestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecurringContestCountAggregateInputType | true
    }

  export interface RecurringContestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecurringContest'], meta: { name: 'RecurringContest' } }
    /**
     * Find zero or one RecurringContest that matches the filter.
     * @param {RecurringContestFindUniqueArgs} args - Arguments to find a RecurringContest
     * @example
     * // Get one RecurringContest
     * const recurringContest = await prisma.recurringContest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecurringContestFindUniqueArgs>(args: SelectSubset<T, RecurringContestFindUniqueArgs<ExtArgs>>): Prisma__RecurringContestClient<$Result.GetResult<Prisma.$RecurringContestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecurringContest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecurringContestFindUniqueOrThrowArgs} args - Arguments to find a RecurringContest
     * @example
     * // Get one RecurringContest
     * const recurringContest = await prisma.recurringContest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecurringContestFindUniqueOrThrowArgs>(args: SelectSubset<T, RecurringContestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecurringContestClient<$Result.GetResult<Prisma.$RecurringContestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringContest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestFindFirstArgs} args - Arguments to find a RecurringContest
     * @example
     * // Get one RecurringContest
     * const recurringContest = await prisma.recurringContest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecurringContestFindFirstArgs>(args?: SelectSubset<T, RecurringContestFindFirstArgs<ExtArgs>>): Prisma__RecurringContestClient<$Result.GetResult<Prisma.$RecurringContestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringContest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestFindFirstOrThrowArgs} args - Arguments to find a RecurringContest
     * @example
     * // Get one RecurringContest
     * const recurringContest = await prisma.recurringContest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecurringContestFindFirstOrThrowArgs>(args?: SelectSubset<T, RecurringContestFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecurringContestClient<$Result.GetResult<Prisma.$RecurringContestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecurringContests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecurringContests
     * const recurringContests = await prisma.recurringContest.findMany()
     * 
     * // Get first 10 RecurringContests
     * const recurringContests = await prisma.recurringContest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recurringContestWithIdOnly = await prisma.recurringContest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecurringContestFindManyArgs>(args?: SelectSubset<T, RecurringContestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringContestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecurringContest.
     * @param {RecurringContestCreateArgs} args - Arguments to create a RecurringContest.
     * @example
     * // Create one RecurringContest
     * const RecurringContest = await prisma.recurringContest.create({
     *   data: {
     *     // ... data to create a RecurringContest
     *   }
     * })
     * 
     */
    create<T extends RecurringContestCreateArgs>(args: SelectSubset<T, RecurringContestCreateArgs<ExtArgs>>): Prisma__RecurringContestClient<$Result.GetResult<Prisma.$RecurringContestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecurringContests.
     * @param {RecurringContestCreateManyArgs} args - Arguments to create many RecurringContests.
     * @example
     * // Create many RecurringContests
     * const recurringContest = await prisma.recurringContest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecurringContestCreateManyArgs>(args?: SelectSubset<T, RecurringContestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RecurringContest.
     * @param {RecurringContestDeleteArgs} args - Arguments to delete one RecurringContest.
     * @example
     * // Delete one RecurringContest
     * const RecurringContest = await prisma.recurringContest.delete({
     *   where: {
     *     // ... filter to delete one RecurringContest
     *   }
     * })
     * 
     */
    delete<T extends RecurringContestDeleteArgs>(args: SelectSubset<T, RecurringContestDeleteArgs<ExtArgs>>): Prisma__RecurringContestClient<$Result.GetResult<Prisma.$RecurringContestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecurringContest.
     * @param {RecurringContestUpdateArgs} args - Arguments to update one RecurringContest.
     * @example
     * // Update one RecurringContest
     * const recurringContest = await prisma.recurringContest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecurringContestUpdateArgs>(args: SelectSubset<T, RecurringContestUpdateArgs<ExtArgs>>): Prisma__RecurringContestClient<$Result.GetResult<Prisma.$RecurringContestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecurringContests.
     * @param {RecurringContestDeleteManyArgs} args - Arguments to filter RecurringContests to delete.
     * @example
     * // Delete a few RecurringContests
     * const { count } = await prisma.recurringContest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecurringContestDeleteManyArgs>(args?: SelectSubset<T, RecurringContestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringContests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecurringContests
     * const recurringContest = await prisma.recurringContest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecurringContestUpdateManyArgs>(args: SelectSubset<T, RecurringContestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecurringContest.
     * @param {RecurringContestUpsertArgs} args - Arguments to update or create a RecurringContest.
     * @example
     * // Update or create a RecurringContest
     * const recurringContest = await prisma.recurringContest.upsert({
     *   create: {
     *     // ... data to create a RecurringContest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecurringContest we want to update
     *   }
     * })
     */
    upsert<T extends RecurringContestUpsertArgs>(args: SelectSubset<T, RecurringContestUpsertArgs<ExtArgs>>): Prisma__RecurringContestClient<$Result.GetResult<Prisma.$RecurringContestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecurringContests that matches the filter.
     * @param {RecurringContestFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const recurringContest = await prisma.recurringContest.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: RecurringContestFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a RecurringContest.
     * @param {RecurringContestAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const recurringContest = await prisma.recurringContest.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: RecurringContestAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of RecurringContests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestCountArgs} args - Arguments to filter RecurringContests to count.
     * @example
     * // Count the number of RecurringContests
     * const count = await prisma.recurringContest.count({
     *   where: {
     *     // ... the filter for the RecurringContests we want to count
     *   }
     * })
    **/
    count<T extends RecurringContestCountArgs>(
      args?: Subset<T, RecurringContestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecurringContestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecurringContest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecurringContestAggregateArgs>(args: Subset<T, RecurringContestAggregateArgs>): Prisma.PrismaPromise<GetRecurringContestAggregateType<T>>

    /**
     * Group by RecurringContest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringContestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecurringContestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecurringContestGroupByArgs['orderBy'] }
        : { orderBy?: RecurringContestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecurringContestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecurringContestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecurringContest model
   */
  readonly fields: RecurringContestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecurringContest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecurringContestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecurringContest model
   */
  interface RecurringContestFieldRefs {
    readonly id: FieldRef<"RecurringContest", 'String'>
    readonly creatorId: FieldRef<"RecurringContest", 'String'>
    readonly title: FieldRef<"RecurringContest", 'String'>
    readonly description: FieldRef<"RecurringContest", 'String'>
    readonly banner: FieldRef<"RecurringContest", 'String'>
    readonly maxUploads: FieldRef<"RecurringContest", 'Int'>
    readonly isMoneyContest: FieldRef<"RecurringContest", 'Boolean'>
    readonly maxPrize: FieldRef<"RecurringContest", 'Int'>
    readonly minPrize: FieldRef<"RecurringContest", 'Int'>
    readonly createdAt: FieldRef<"RecurringContest", 'DateTime'>
    readonly updatedAt: FieldRef<"RecurringContest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecurringContest findUnique
   */
  export type RecurringContestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContest
     */
    select?: RecurringContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContest
     */
    omit?: RecurringContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestInclude<ExtArgs> | null
    /**
     * Filter, which RecurringContest to fetch.
     */
    where: RecurringContestWhereUniqueInput
  }

  /**
   * RecurringContest findUniqueOrThrow
   */
  export type RecurringContestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContest
     */
    select?: RecurringContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContest
     */
    omit?: RecurringContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestInclude<ExtArgs> | null
    /**
     * Filter, which RecurringContest to fetch.
     */
    where: RecurringContestWhereUniqueInput
  }

  /**
   * RecurringContest findFirst
   */
  export type RecurringContestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContest
     */
    select?: RecurringContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContest
     */
    omit?: RecurringContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestInclude<ExtArgs> | null
    /**
     * Filter, which RecurringContest to fetch.
     */
    where?: RecurringContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringContests to fetch.
     */
    orderBy?: RecurringContestOrderByWithRelationInput | RecurringContestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringContests.
     */
    cursor?: RecurringContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringContests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringContests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringContests.
     */
    distinct?: RecurringContestScalarFieldEnum | RecurringContestScalarFieldEnum[]
  }

  /**
   * RecurringContest findFirstOrThrow
   */
  export type RecurringContestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContest
     */
    select?: RecurringContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContest
     */
    omit?: RecurringContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestInclude<ExtArgs> | null
    /**
     * Filter, which RecurringContest to fetch.
     */
    where?: RecurringContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringContests to fetch.
     */
    orderBy?: RecurringContestOrderByWithRelationInput | RecurringContestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringContests.
     */
    cursor?: RecurringContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringContests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringContests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringContests.
     */
    distinct?: RecurringContestScalarFieldEnum | RecurringContestScalarFieldEnum[]
  }

  /**
   * RecurringContest findMany
   */
  export type RecurringContestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContest
     */
    select?: RecurringContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContest
     */
    omit?: RecurringContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestInclude<ExtArgs> | null
    /**
     * Filter, which RecurringContests to fetch.
     */
    where?: RecurringContestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringContests to fetch.
     */
    orderBy?: RecurringContestOrderByWithRelationInput | RecurringContestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecurringContests.
     */
    cursor?: RecurringContestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringContests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringContests.
     */
    skip?: number
    distinct?: RecurringContestScalarFieldEnum | RecurringContestScalarFieldEnum[]
  }

  /**
   * RecurringContest create
   */
  export type RecurringContestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContest
     */
    select?: RecurringContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContest
     */
    omit?: RecurringContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestInclude<ExtArgs> | null
    /**
     * The data needed to create a RecurringContest.
     */
    data: XOR<RecurringContestCreateInput, RecurringContestUncheckedCreateInput>
  }

  /**
   * RecurringContest createMany
   */
  export type RecurringContestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecurringContests.
     */
    data: RecurringContestCreateManyInput | RecurringContestCreateManyInput[]
  }

  /**
   * RecurringContest update
   */
  export type RecurringContestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContest
     */
    select?: RecurringContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContest
     */
    omit?: RecurringContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestInclude<ExtArgs> | null
    /**
     * The data needed to update a RecurringContest.
     */
    data: XOR<RecurringContestUpdateInput, RecurringContestUncheckedUpdateInput>
    /**
     * Choose, which RecurringContest to update.
     */
    where: RecurringContestWhereUniqueInput
  }

  /**
   * RecurringContest updateMany
   */
  export type RecurringContestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecurringContests.
     */
    data: XOR<RecurringContestUpdateManyMutationInput, RecurringContestUncheckedUpdateManyInput>
    /**
     * Filter which RecurringContests to update
     */
    where?: RecurringContestWhereInput
    /**
     * Limit how many RecurringContests to update.
     */
    limit?: number
  }

  /**
   * RecurringContest upsert
   */
  export type RecurringContestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContest
     */
    select?: RecurringContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContest
     */
    omit?: RecurringContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestInclude<ExtArgs> | null
    /**
     * The filter to search for the RecurringContest to update in case it exists.
     */
    where: RecurringContestWhereUniqueInput
    /**
     * In case the RecurringContest found by the `where` argument doesn't exist, create a new RecurringContest with this data.
     */
    create: XOR<RecurringContestCreateInput, RecurringContestUncheckedCreateInput>
    /**
     * In case the RecurringContest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecurringContestUpdateInput, RecurringContestUncheckedUpdateInput>
  }

  /**
   * RecurringContest delete
   */
  export type RecurringContestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContest
     */
    select?: RecurringContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContest
     */
    omit?: RecurringContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestInclude<ExtArgs> | null
    /**
     * Filter which RecurringContest to delete.
     */
    where: RecurringContestWhereUniqueInput
  }

  /**
   * RecurringContest deleteMany
   */
  export type RecurringContestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringContests to delete
     */
    where?: RecurringContestWhereInput
    /**
     * Limit how many RecurringContests to delete.
     */
    limit?: number
  }

  /**
   * RecurringContest findRaw
   */
  export type RecurringContestFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * RecurringContest aggregateRaw
   */
  export type RecurringContestAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * RecurringContest without action
   */
  export type RecurringContestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringContest
     */
    select?: RecurringContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringContest
     */
    omit?: RecurringContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringContestInclude<ExtArgs> | null
  }


  /**
   * Model ContestPhoto
   */

  export type AggregateContestPhoto = {
    _count: ContestPhotoCountAggregateOutputType | null
    _avg: ContestPhotoAvgAggregateOutputType | null
    _sum: ContestPhotoSumAggregateOutputType | null
    _min: ContestPhotoMinAggregateOutputType | null
    _max: ContestPhotoMaxAggregateOutputType | null
  }

  export type ContestPhotoAvgAggregateOutputType = {
    rank: number | null
  }

  export type ContestPhotoSumAggregateOutputType = {
    rank: number | null
  }

  export type ContestPhotoMinAggregateOutputType = {
    id: string | null
    title: string | null
    contestId: string | null
    participantId: string | null
    photoId: string | null
    rank: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestPhotoMaxAggregateOutputType = {
    id: string | null
    title: string | null
    contestId: string | null
    participantId: string | null
    photoId: string | null
    rank: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestPhotoCountAggregateOutputType = {
    id: number
    title: number
    contestId: number
    participantId: number
    photoId: number
    rank: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContestPhotoAvgAggregateInputType = {
    rank?: true
  }

  export type ContestPhotoSumAggregateInputType = {
    rank?: true
  }

  export type ContestPhotoMinAggregateInputType = {
    id?: true
    title?: true
    contestId?: true
    participantId?: true
    photoId?: true
    rank?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestPhotoMaxAggregateInputType = {
    id?: true
    title?: true
    contestId?: true
    participantId?: true
    photoId?: true
    rank?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestPhotoCountAggregateInputType = {
    id?: true
    title?: true
    contestId?: true
    participantId?: true
    photoId?: true
    rank?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContestPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestPhoto to aggregate.
     */
    where?: ContestPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestPhotos to fetch.
     */
    orderBy?: ContestPhotoOrderByWithRelationInput | ContestPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContestPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContestPhotos
    **/
    _count?: true | ContestPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContestPhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContestPhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestPhotoMaxAggregateInputType
  }

  export type GetContestPhotoAggregateType<T extends ContestPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateContestPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContestPhoto[P]>
      : GetScalarType<T[P], AggregateContestPhoto[P]>
  }




  export type ContestPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestPhotoWhereInput
    orderBy?: ContestPhotoOrderByWithAggregationInput | ContestPhotoOrderByWithAggregationInput[]
    by: ContestPhotoScalarFieldEnum[] | ContestPhotoScalarFieldEnum
    having?: ContestPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestPhotoCountAggregateInputType | true
    _avg?: ContestPhotoAvgAggregateInputType
    _sum?: ContestPhotoSumAggregateInputType
    _min?: ContestPhotoMinAggregateInputType
    _max?: ContestPhotoMaxAggregateInputType
  }

  export type ContestPhotoGroupByOutputType = {
    id: string
    title: string | null
    contestId: string
    participantId: string
    photoId: string
    rank: number | null
    createdAt: Date
    updatedAt: Date
    _count: ContestPhotoCountAggregateOutputType | null
    _avg: ContestPhotoAvgAggregateOutputType | null
    _sum: ContestPhotoSumAggregateOutputType | null
    _min: ContestPhotoMinAggregateOutputType | null
    _max: ContestPhotoMaxAggregateOutputType | null
  }

  type GetContestPhotoGroupByPayload<T extends ContestPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], ContestPhotoGroupByOutputType[P]>
        }
      >
    >


  export type ContestPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    contestId?: boolean
    participantId?: boolean
    photoId?: boolean
    rank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    participant?: boolean | ContestParticipantDefaultArgs<ExtArgs>
    votes?: boolean | ContestPhoto$votesArgs<ExtArgs>
    photo?: boolean | UserPhotoDefaultArgs<ExtArgs>
    comments?: boolean | ContestPhoto$commentsArgs<ExtArgs>
    achievements?: boolean | ContestPhoto$achievementsArgs<ExtArgs>
    ContestWinner?: boolean | ContestPhoto$ContestWinnerArgs<ExtArgs>
    _count?: boolean | ContestPhotoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contestPhoto"]>



  export type ContestPhotoSelectScalar = {
    id?: boolean
    title?: boolean
    contestId?: boolean
    participantId?: boolean
    photoId?: boolean
    rank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContestPhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "contestId" | "participantId" | "photoId" | "rank" | "createdAt" | "updatedAt", ExtArgs["result"]["contestPhoto"]>
  export type ContestPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | ContestParticipantDefaultArgs<ExtArgs>
    votes?: boolean | ContestPhoto$votesArgs<ExtArgs>
    photo?: boolean | UserPhotoDefaultArgs<ExtArgs>
    comments?: boolean | ContestPhoto$commentsArgs<ExtArgs>
    achievements?: boolean | ContestPhoto$achievementsArgs<ExtArgs>
    ContestWinner?: boolean | ContestPhoto$ContestWinnerArgs<ExtArgs>
    _count?: boolean | ContestPhotoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContestPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContestPhoto"
    objects: {
      participant: Prisma.$ContestParticipantPayload<ExtArgs>
      votes: Prisma.$VotePayload<ExtArgs>[]
      photo: Prisma.$UserPhotoPayload<ExtArgs>
      comments: Prisma.$CommentPayload<ExtArgs>[]
      achievements: Prisma.$ContestAchievementPayload<ExtArgs>[]
      ContestWinner: Prisma.$ContestWinnerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      contestId: string
      participantId: string
      photoId: string
      rank: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contestPhoto"]>
    composites: {}
  }

  type ContestPhotoGetPayload<S extends boolean | null | undefined | ContestPhotoDefaultArgs> = $Result.GetResult<Prisma.$ContestPhotoPayload, S>

  type ContestPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContestPhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContestPhotoCountAggregateInputType | true
    }

  export interface ContestPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContestPhoto'], meta: { name: 'ContestPhoto' } }
    /**
     * Find zero or one ContestPhoto that matches the filter.
     * @param {ContestPhotoFindUniqueArgs} args - Arguments to find a ContestPhoto
     * @example
     * // Get one ContestPhoto
     * const contestPhoto = await prisma.contestPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContestPhotoFindUniqueArgs>(args: SelectSubset<T, ContestPhotoFindUniqueArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContestPhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContestPhotoFindUniqueOrThrowArgs} args - Arguments to find a ContestPhoto
     * @example
     * // Get one ContestPhoto
     * const contestPhoto = await prisma.contestPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContestPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, ContestPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPhotoFindFirstArgs} args - Arguments to find a ContestPhoto
     * @example
     * // Get one ContestPhoto
     * const contestPhoto = await prisma.contestPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContestPhotoFindFirstArgs>(args?: SelectSubset<T, ContestPhotoFindFirstArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPhotoFindFirstOrThrowArgs} args - Arguments to find a ContestPhoto
     * @example
     * // Get one ContestPhoto
     * const contestPhoto = await prisma.contestPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContestPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, ContestPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContestPhotos
     * const contestPhotos = await prisma.contestPhoto.findMany()
     * 
     * // Get first 10 ContestPhotos
     * const contestPhotos = await prisma.contestPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contestPhotoWithIdOnly = await prisma.contestPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContestPhotoFindManyArgs>(args?: SelectSubset<T, ContestPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContestPhoto.
     * @param {ContestPhotoCreateArgs} args - Arguments to create a ContestPhoto.
     * @example
     * // Create one ContestPhoto
     * const ContestPhoto = await prisma.contestPhoto.create({
     *   data: {
     *     // ... data to create a ContestPhoto
     *   }
     * })
     * 
     */
    create<T extends ContestPhotoCreateArgs>(args: SelectSubset<T, ContestPhotoCreateArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContestPhotos.
     * @param {ContestPhotoCreateManyArgs} args - Arguments to create many ContestPhotos.
     * @example
     * // Create many ContestPhotos
     * const contestPhoto = await prisma.contestPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContestPhotoCreateManyArgs>(args?: SelectSubset<T, ContestPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContestPhoto.
     * @param {ContestPhotoDeleteArgs} args - Arguments to delete one ContestPhoto.
     * @example
     * // Delete one ContestPhoto
     * const ContestPhoto = await prisma.contestPhoto.delete({
     *   where: {
     *     // ... filter to delete one ContestPhoto
     *   }
     * })
     * 
     */
    delete<T extends ContestPhotoDeleteArgs>(args: SelectSubset<T, ContestPhotoDeleteArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContestPhoto.
     * @param {ContestPhotoUpdateArgs} args - Arguments to update one ContestPhoto.
     * @example
     * // Update one ContestPhoto
     * const contestPhoto = await prisma.contestPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContestPhotoUpdateArgs>(args: SelectSubset<T, ContestPhotoUpdateArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContestPhotos.
     * @param {ContestPhotoDeleteManyArgs} args - Arguments to filter ContestPhotos to delete.
     * @example
     * // Delete a few ContestPhotos
     * const { count } = await prisma.contestPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContestPhotoDeleteManyArgs>(args?: SelectSubset<T, ContestPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContestPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContestPhotos
     * const contestPhoto = await prisma.contestPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContestPhotoUpdateManyArgs>(args: SelectSubset<T, ContestPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContestPhoto.
     * @param {ContestPhotoUpsertArgs} args - Arguments to update or create a ContestPhoto.
     * @example
     * // Update or create a ContestPhoto
     * const contestPhoto = await prisma.contestPhoto.upsert({
     *   create: {
     *     // ... data to create a ContestPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContestPhoto we want to update
     *   }
     * })
     */
    upsert<T extends ContestPhotoUpsertArgs>(args: SelectSubset<T, ContestPhotoUpsertArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestPhotos that matches the filter.
     * @param {ContestPhotoFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contestPhoto = await prisma.contestPhoto.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ContestPhotoFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ContestPhoto.
     * @param {ContestPhotoAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contestPhoto = await prisma.contestPhoto.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ContestPhotoAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ContestPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPhotoCountArgs} args - Arguments to filter ContestPhotos to count.
     * @example
     * // Count the number of ContestPhotos
     * const count = await prisma.contestPhoto.count({
     *   where: {
     *     // ... the filter for the ContestPhotos we want to count
     *   }
     * })
    **/
    count<T extends ContestPhotoCountArgs>(
      args?: Subset<T, ContestPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContestPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestPhotoAggregateArgs>(args: Subset<T, ContestPhotoAggregateArgs>): Prisma.PrismaPromise<GetContestPhotoAggregateType<T>>

    /**
     * Group by ContestPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContestPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContestPhotoGroupByArgs['orderBy'] }
        : { orderBy?: ContestPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContestPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContestPhoto model
   */
  readonly fields: ContestPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContestPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContestPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participant<T extends ContestParticipantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestParticipantDefaultArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    votes<T extends ContestPhoto$votesArgs<ExtArgs> = {}>(args?: Subset<T, ContestPhoto$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photo<T extends UserPhotoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserPhotoDefaultArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comments<T extends ContestPhoto$commentsArgs<ExtArgs> = {}>(args?: Subset<T, ContestPhoto$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    achievements<T extends ContestPhoto$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, ContestPhoto$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ContestWinner<T extends ContestPhoto$ContestWinnerArgs<ExtArgs> = {}>(args?: Subset<T, ContestPhoto$ContestWinnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContestPhoto model
   */
  interface ContestPhotoFieldRefs {
    readonly id: FieldRef<"ContestPhoto", 'String'>
    readonly title: FieldRef<"ContestPhoto", 'String'>
    readonly contestId: FieldRef<"ContestPhoto", 'String'>
    readonly participantId: FieldRef<"ContestPhoto", 'String'>
    readonly photoId: FieldRef<"ContestPhoto", 'String'>
    readonly rank: FieldRef<"ContestPhoto", 'Int'>
    readonly createdAt: FieldRef<"ContestPhoto", 'DateTime'>
    readonly updatedAt: FieldRef<"ContestPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContestPhoto findUnique
   */
  export type ContestPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ContestPhoto to fetch.
     */
    where: ContestPhotoWhereUniqueInput
  }

  /**
   * ContestPhoto findUniqueOrThrow
   */
  export type ContestPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ContestPhoto to fetch.
     */
    where: ContestPhotoWhereUniqueInput
  }

  /**
   * ContestPhoto findFirst
   */
  export type ContestPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ContestPhoto to fetch.
     */
    where?: ContestPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestPhotos to fetch.
     */
    orderBy?: ContestPhotoOrderByWithRelationInput | ContestPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestPhotos.
     */
    cursor?: ContestPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestPhotos.
     */
    distinct?: ContestPhotoScalarFieldEnum | ContestPhotoScalarFieldEnum[]
  }

  /**
   * ContestPhoto findFirstOrThrow
   */
  export type ContestPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ContestPhoto to fetch.
     */
    where?: ContestPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestPhotos to fetch.
     */
    orderBy?: ContestPhotoOrderByWithRelationInput | ContestPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestPhotos.
     */
    cursor?: ContestPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestPhotos.
     */
    distinct?: ContestPhotoScalarFieldEnum | ContestPhotoScalarFieldEnum[]
  }

  /**
   * ContestPhoto findMany
   */
  export type ContestPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ContestPhotos to fetch.
     */
    where?: ContestPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestPhotos to fetch.
     */
    orderBy?: ContestPhotoOrderByWithRelationInput | ContestPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContestPhotos.
     */
    cursor?: ContestPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestPhotos.
     */
    skip?: number
    distinct?: ContestPhotoScalarFieldEnum | ContestPhotoScalarFieldEnum[]
  }

  /**
   * ContestPhoto create
   */
  export type ContestPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a ContestPhoto.
     */
    data: XOR<ContestPhotoCreateInput, ContestPhotoUncheckedCreateInput>
  }

  /**
   * ContestPhoto createMany
   */
  export type ContestPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContestPhotos.
     */
    data: ContestPhotoCreateManyInput | ContestPhotoCreateManyInput[]
  }

  /**
   * ContestPhoto update
   */
  export type ContestPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a ContestPhoto.
     */
    data: XOR<ContestPhotoUpdateInput, ContestPhotoUncheckedUpdateInput>
    /**
     * Choose, which ContestPhoto to update.
     */
    where: ContestPhotoWhereUniqueInput
  }

  /**
   * ContestPhoto updateMany
   */
  export type ContestPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContestPhotos.
     */
    data: XOR<ContestPhotoUpdateManyMutationInput, ContestPhotoUncheckedUpdateManyInput>
    /**
     * Filter which ContestPhotos to update
     */
    where?: ContestPhotoWhereInput
    /**
     * Limit how many ContestPhotos to update.
     */
    limit?: number
  }

  /**
   * ContestPhoto upsert
   */
  export type ContestPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the ContestPhoto to update in case it exists.
     */
    where: ContestPhotoWhereUniqueInput
    /**
     * In case the ContestPhoto found by the `where` argument doesn't exist, create a new ContestPhoto with this data.
     */
    create: XOR<ContestPhotoCreateInput, ContestPhotoUncheckedCreateInput>
    /**
     * In case the ContestPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContestPhotoUpdateInput, ContestPhotoUncheckedUpdateInput>
  }

  /**
   * ContestPhoto delete
   */
  export type ContestPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    /**
     * Filter which ContestPhoto to delete.
     */
    where: ContestPhotoWhereUniqueInput
  }

  /**
   * ContestPhoto deleteMany
   */
  export type ContestPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestPhotos to delete
     */
    where?: ContestPhotoWhereInput
    /**
     * Limit how many ContestPhotos to delete.
     */
    limit?: number
  }

  /**
   * ContestPhoto findRaw
   */
  export type ContestPhotoFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestPhoto aggregateRaw
   */
  export type ContestPhotoAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestPhoto.votes
   */
  export type ContestPhoto$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    cursor?: VoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * ContestPhoto.comments
   */
  export type ContestPhoto$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * ContestPhoto.achievements
   */
  export type ContestPhoto$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    where?: ContestAchievementWhereInput
    orderBy?: ContestAchievementOrderByWithRelationInput | ContestAchievementOrderByWithRelationInput[]
    cursor?: ContestAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestAchievementScalarFieldEnum | ContestAchievementScalarFieldEnum[]
  }

  /**
   * ContestPhoto.ContestWinner
   */
  export type ContestPhoto$ContestWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    where?: ContestWinnerWhereInput
    orderBy?: ContestWinnerOrderByWithRelationInput | ContestWinnerOrderByWithRelationInput[]
    cursor?: ContestWinnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestWinnerScalarFieldEnum | ContestWinnerScalarFieldEnum[]
  }

  /**
   * ContestPhoto without action
   */
  export type ContestPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
  }


  /**
   * Model ContestWinner
   */

  export type AggregateContestWinner = {
    _count: ContestWinnerCountAggregateOutputType | null
    _min: ContestWinnerMinAggregateOutputType | null
    _max: ContestWinnerMaxAggregateOutputType | null
  }

  export type ContestWinnerMinAggregateOutputType = {
    id: string | null
    participantId: string | null
    contestId: string | null
    contestPhotoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestWinnerMaxAggregateOutputType = {
    id: string | null
    participantId: string | null
    contestId: string | null
    contestPhotoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestWinnerCountAggregateOutputType = {
    id: number
    participantId: number
    contestId: number
    contestPhotoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContestWinnerMinAggregateInputType = {
    id?: true
    participantId?: true
    contestId?: true
    contestPhotoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestWinnerMaxAggregateInputType = {
    id?: true
    participantId?: true
    contestId?: true
    contestPhotoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestWinnerCountAggregateInputType = {
    id?: true
    participantId?: true
    contestId?: true
    contestPhotoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContestWinnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestWinner to aggregate.
     */
    where?: ContestWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestWinners to fetch.
     */
    orderBy?: ContestWinnerOrderByWithRelationInput | ContestWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContestWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContestWinners
    **/
    _count?: true | ContestWinnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestWinnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestWinnerMaxAggregateInputType
  }

  export type GetContestWinnerAggregateType<T extends ContestWinnerAggregateArgs> = {
        [P in keyof T & keyof AggregateContestWinner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContestWinner[P]>
      : GetScalarType<T[P], AggregateContestWinner[P]>
  }




  export type ContestWinnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestWinnerWhereInput
    orderBy?: ContestWinnerOrderByWithAggregationInput | ContestWinnerOrderByWithAggregationInput[]
    by: ContestWinnerScalarFieldEnum[] | ContestWinnerScalarFieldEnum
    having?: ContestWinnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestWinnerCountAggregateInputType | true
    _min?: ContestWinnerMinAggregateInputType
    _max?: ContestWinnerMaxAggregateInputType
  }

  export type ContestWinnerGroupByOutputType = {
    id: string
    participantId: string
    contestId: string
    contestPhotoId: string
    createdAt: Date
    updatedAt: Date
    _count: ContestWinnerCountAggregateOutputType | null
    _min: ContestWinnerMinAggregateOutputType | null
    _max: ContestWinnerMaxAggregateOutputType | null
  }

  type GetContestWinnerGroupByPayload<T extends ContestWinnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestWinnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestWinnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestWinnerGroupByOutputType[P]>
            : GetScalarType<T[P], ContestWinnerGroupByOutputType[P]>
        }
      >
    >


  export type ContestWinnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participantId?: boolean
    contestId?: boolean
    contestPhotoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    participant?: boolean | ContestParticipantDefaultArgs<ExtArgs>
    photo?: boolean | ContestPhotoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contestWinner"]>



  export type ContestWinnerSelectScalar = {
    id?: boolean
    participantId?: boolean
    contestId?: boolean
    contestPhotoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContestWinnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "participantId" | "contestId" | "contestPhotoId" | "createdAt" | "updatedAt", ExtArgs["result"]["contestWinner"]>
  export type ContestWinnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participant?: boolean | ContestParticipantDefaultArgs<ExtArgs>
    photo?: boolean | ContestPhotoDefaultArgs<ExtArgs>
  }

  export type $ContestWinnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContestWinner"
    objects: {
      participant: Prisma.$ContestParticipantPayload<ExtArgs>
      photo: Prisma.$ContestPhotoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      participantId: string
      contestId: string
      contestPhotoId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contestWinner"]>
    composites: {}
  }

  type ContestWinnerGetPayload<S extends boolean | null | undefined | ContestWinnerDefaultArgs> = $Result.GetResult<Prisma.$ContestWinnerPayload, S>

  type ContestWinnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContestWinnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContestWinnerCountAggregateInputType | true
    }

  export interface ContestWinnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContestWinner'], meta: { name: 'ContestWinner' } }
    /**
     * Find zero or one ContestWinner that matches the filter.
     * @param {ContestWinnerFindUniqueArgs} args - Arguments to find a ContestWinner
     * @example
     * // Get one ContestWinner
     * const contestWinner = await prisma.contestWinner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContestWinnerFindUniqueArgs>(args: SelectSubset<T, ContestWinnerFindUniqueArgs<ExtArgs>>): Prisma__ContestWinnerClient<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContestWinner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContestWinnerFindUniqueOrThrowArgs} args - Arguments to find a ContestWinner
     * @example
     * // Get one ContestWinner
     * const contestWinner = await prisma.contestWinner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContestWinnerFindUniqueOrThrowArgs>(args: SelectSubset<T, ContestWinnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContestWinnerClient<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestWinner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestWinnerFindFirstArgs} args - Arguments to find a ContestWinner
     * @example
     * // Get one ContestWinner
     * const contestWinner = await prisma.contestWinner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContestWinnerFindFirstArgs>(args?: SelectSubset<T, ContestWinnerFindFirstArgs<ExtArgs>>): Prisma__ContestWinnerClient<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestWinner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestWinnerFindFirstOrThrowArgs} args - Arguments to find a ContestWinner
     * @example
     * // Get one ContestWinner
     * const contestWinner = await prisma.contestWinner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContestWinnerFindFirstOrThrowArgs>(args?: SelectSubset<T, ContestWinnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContestWinnerClient<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestWinners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestWinnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContestWinners
     * const contestWinners = await prisma.contestWinner.findMany()
     * 
     * // Get first 10 ContestWinners
     * const contestWinners = await prisma.contestWinner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contestWinnerWithIdOnly = await prisma.contestWinner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContestWinnerFindManyArgs>(args?: SelectSubset<T, ContestWinnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContestWinner.
     * @param {ContestWinnerCreateArgs} args - Arguments to create a ContestWinner.
     * @example
     * // Create one ContestWinner
     * const ContestWinner = await prisma.contestWinner.create({
     *   data: {
     *     // ... data to create a ContestWinner
     *   }
     * })
     * 
     */
    create<T extends ContestWinnerCreateArgs>(args: SelectSubset<T, ContestWinnerCreateArgs<ExtArgs>>): Prisma__ContestWinnerClient<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContestWinners.
     * @param {ContestWinnerCreateManyArgs} args - Arguments to create many ContestWinners.
     * @example
     * // Create many ContestWinners
     * const contestWinner = await prisma.contestWinner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContestWinnerCreateManyArgs>(args?: SelectSubset<T, ContestWinnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContestWinner.
     * @param {ContestWinnerDeleteArgs} args - Arguments to delete one ContestWinner.
     * @example
     * // Delete one ContestWinner
     * const ContestWinner = await prisma.contestWinner.delete({
     *   where: {
     *     // ... filter to delete one ContestWinner
     *   }
     * })
     * 
     */
    delete<T extends ContestWinnerDeleteArgs>(args: SelectSubset<T, ContestWinnerDeleteArgs<ExtArgs>>): Prisma__ContestWinnerClient<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContestWinner.
     * @param {ContestWinnerUpdateArgs} args - Arguments to update one ContestWinner.
     * @example
     * // Update one ContestWinner
     * const contestWinner = await prisma.contestWinner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContestWinnerUpdateArgs>(args: SelectSubset<T, ContestWinnerUpdateArgs<ExtArgs>>): Prisma__ContestWinnerClient<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContestWinners.
     * @param {ContestWinnerDeleteManyArgs} args - Arguments to filter ContestWinners to delete.
     * @example
     * // Delete a few ContestWinners
     * const { count } = await prisma.contestWinner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContestWinnerDeleteManyArgs>(args?: SelectSubset<T, ContestWinnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContestWinners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestWinnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContestWinners
     * const contestWinner = await prisma.contestWinner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContestWinnerUpdateManyArgs>(args: SelectSubset<T, ContestWinnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContestWinner.
     * @param {ContestWinnerUpsertArgs} args - Arguments to update or create a ContestWinner.
     * @example
     * // Update or create a ContestWinner
     * const contestWinner = await prisma.contestWinner.upsert({
     *   create: {
     *     // ... data to create a ContestWinner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContestWinner we want to update
     *   }
     * })
     */
    upsert<T extends ContestWinnerUpsertArgs>(args: SelectSubset<T, ContestWinnerUpsertArgs<ExtArgs>>): Prisma__ContestWinnerClient<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestWinners that matches the filter.
     * @param {ContestWinnerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contestWinner = await prisma.contestWinner.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ContestWinnerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ContestWinner.
     * @param {ContestWinnerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contestWinner = await prisma.contestWinner.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ContestWinnerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ContestWinners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestWinnerCountArgs} args - Arguments to filter ContestWinners to count.
     * @example
     * // Count the number of ContestWinners
     * const count = await prisma.contestWinner.count({
     *   where: {
     *     // ... the filter for the ContestWinners we want to count
     *   }
     * })
    **/
    count<T extends ContestWinnerCountArgs>(
      args?: Subset<T, ContestWinnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestWinnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContestWinner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestWinnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestWinnerAggregateArgs>(args: Subset<T, ContestWinnerAggregateArgs>): Prisma.PrismaPromise<GetContestWinnerAggregateType<T>>

    /**
     * Group by ContestWinner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestWinnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContestWinnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContestWinnerGroupByArgs['orderBy'] }
        : { orderBy?: ContestWinnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContestWinnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestWinnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContestWinner model
   */
  readonly fields: ContestWinnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContestWinner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContestWinnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participant<T extends ContestParticipantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestParticipantDefaultArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    photo<T extends ContestPhotoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestPhotoDefaultArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContestWinner model
   */
  interface ContestWinnerFieldRefs {
    readonly id: FieldRef<"ContestWinner", 'String'>
    readonly participantId: FieldRef<"ContestWinner", 'String'>
    readonly contestId: FieldRef<"ContestWinner", 'String'>
    readonly contestPhotoId: FieldRef<"ContestWinner", 'String'>
    readonly createdAt: FieldRef<"ContestWinner", 'DateTime'>
    readonly updatedAt: FieldRef<"ContestWinner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContestWinner findUnique
   */
  export type ContestWinnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    /**
     * Filter, which ContestWinner to fetch.
     */
    where: ContestWinnerWhereUniqueInput
  }

  /**
   * ContestWinner findUniqueOrThrow
   */
  export type ContestWinnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    /**
     * Filter, which ContestWinner to fetch.
     */
    where: ContestWinnerWhereUniqueInput
  }

  /**
   * ContestWinner findFirst
   */
  export type ContestWinnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    /**
     * Filter, which ContestWinner to fetch.
     */
    where?: ContestWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestWinners to fetch.
     */
    orderBy?: ContestWinnerOrderByWithRelationInput | ContestWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestWinners.
     */
    cursor?: ContestWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestWinners.
     */
    distinct?: ContestWinnerScalarFieldEnum | ContestWinnerScalarFieldEnum[]
  }

  /**
   * ContestWinner findFirstOrThrow
   */
  export type ContestWinnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    /**
     * Filter, which ContestWinner to fetch.
     */
    where?: ContestWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestWinners to fetch.
     */
    orderBy?: ContestWinnerOrderByWithRelationInput | ContestWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestWinners.
     */
    cursor?: ContestWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestWinners.
     */
    distinct?: ContestWinnerScalarFieldEnum | ContestWinnerScalarFieldEnum[]
  }

  /**
   * ContestWinner findMany
   */
  export type ContestWinnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    /**
     * Filter, which ContestWinners to fetch.
     */
    where?: ContestWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestWinners to fetch.
     */
    orderBy?: ContestWinnerOrderByWithRelationInput | ContestWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContestWinners.
     */
    cursor?: ContestWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestWinners.
     */
    skip?: number
    distinct?: ContestWinnerScalarFieldEnum | ContestWinnerScalarFieldEnum[]
  }

  /**
   * ContestWinner create
   */
  export type ContestWinnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    /**
     * The data needed to create a ContestWinner.
     */
    data: XOR<ContestWinnerCreateInput, ContestWinnerUncheckedCreateInput>
  }

  /**
   * ContestWinner createMany
   */
  export type ContestWinnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContestWinners.
     */
    data: ContestWinnerCreateManyInput | ContestWinnerCreateManyInput[]
  }

  /**
   * ContestWinner update
   */
  export type ContestWinnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    /**
     * The data needed to update a ContestWinner.
     */
    data: XOR<ContestWinnerUpdateInput, ContestWinnerUncheckedUpdateInput>
    /**
     * Choose, which ContestWinner to update.
     */
    where: ContestWinnerWhereUniqueInput
  }

  /**
   * ContestWinner updateMany
   */
  export type ContestWinnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContestWinners.
     */
    data: XOR<ContestWinnerUpdateManyMutationInput, ContestWinnerUncheckedUpdateManyInput>
    /**
     * Filter which ContestWinners to update
     */
    where?: ContestWinnerWhereInput
    /**
     * Limit how many ContestWinners to update.
     */
    limit?: number
  }

  /**
   * ContestWinner upsert
   */
  export type ContestWinnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    /**
     * The filter to search for the ContestWinner to update in case it exists.
     */
    where: ContestWinnerWhereUniqueInput
    /**
     * In case the ContestWinner found by the `where` argument doesn't exist, create a new ContestWinner with this data.
     */
    create: XOR<ContestWinnerCreateInput, ContestWinnerUncheckedCreateInput>
    /**
     * In case the ContestWinner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContestWinnerUpdateInput, ContestWinnerUncheckedUpdateInput>
  }

  /**
   * ContestWinner delete
   */
  export type ContestWinnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    /**
     * Filter which ContestWinner to delete.
     */
    where: ContestWinnerWhereUniqueInput
  }

  /**
   * ContestWinner deleteMany
   */
  export type ContestWinnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestWinners to delete
     */
    where?: ContestWinnerWhereInput
    /**
     * Limit how many ContestWinners to delete.
     */
    limit?: number
  }

  /**
   * ContestWinner findRaw
   */
  export type ContestWinnerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestWinner aggregateRaw
   */
  export type ContestWinnerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestWinner without action
   */
  export type ContestWinnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
  }


  /**
   * Model ContestParticipant
   */

  export type AggregateContestParticipant = {
    _count: ContestParticipantCountAggregateOutputType | null
    _avg: ContestParticipantAvgAggregateOutputType | null
    _sum: ContestParticipantSumAggregateOutputType | null
    _min: ContestParticipantMinAggregateOutputType | null
    _max: ContestParticipantMaxAggregateOutputType | null
  }

  export type ContestParticipantAvgAggregateOutputType = {
    rank: number | null
  }

  export type ContestParticipantSumAggregateOutputType = {
    rank: number | null
  }

  export type ContestParticipantMinAggregateOutputType = {
    id: string | null
    status: $Enums.ContestParticipantStatus | null
    contestId: string | null
    userId: string | null
    level: $Enums.ContestLevel | null
    rank: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestParticipantMaxAggregateOutputType = {
    id: string | null
    status: $Enums.ContestParticipantStatus | null
    contestId: string | null
    userId: string | null
    level: $Enums.ContestLevel | null
    rank: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestParticipantCountAggregateOutputType = {
    id: number
    status: number
    contestId: number
    userId: number
    level: number
    rank: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContestParticipantAvgAggregateInputType = {
    rank?: true
  }

  export type ContestParticipantSumAggregateInputType = {
    rank?: true
  }

  export type ContestParticipantMinAggregateInputType = {
    id?: true
    status?: true
    contestId?: true
    userId?: true
    level?: true
    rank?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestParticipantMaxAggregateInputType = {
    id?: true
    status?: true
    contestId?: true
    userId?: true
    level?: true
    rank?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestParticipantCountAggregateInputType = {
    id?: true
    status?: true
    contestId?: true
    userId?: true
    level?: true
    rank?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContestParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestParticipant to aggregate.
     */
    where?: ContestParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestParticipants to fetch.
     */
    orderBy?: ContestParticipantOrderByWithRelationInput | ContestParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContestParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContestParticipants
    **/
    _count?: true | ContestParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContestParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContestParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestParticipantMaxAggregateInputType
  }

  export type GetContestParticipantAggregateType<T extends ContestParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateContestParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContestParticipant[P]>
      : GetScalarType<T[P], AggregateContestParticipant[P]>
  }




  export type ContestParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestParticipantWhereInput
    orderBy?: ContestParticipantOrderByWithAggregationInput | ContestParticipantOrderByWithAggregationInput[]
    by: ContestParticipantScalarFieldEnum[] | ContestParticipantScalarFieldEnum
    having?: ContestParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestParticipantCountAggregateInputType | true
    _avg?: ContestParticipantAvgAggregateInputType
    _sum?: ContestParticipantSumAggregateInputType
    _min?: ContestParticipantMinAggregateInputType
    _max?: ContestParticipantMaxAggregateInputType
  }

  export type ContestParticipantGroupByOutputType = {
    id: string
    status: $Enums.ContestParticipantStatus
    contestId: string
    userId: string
    level: $Enums.ContestLevel
    rank: number | null
    createdAt: Date
    updatedAt: Date
    _count: ContestParticipantCountAggregateOutputType | null
    _avg: ContestParticipantAvgAggregateOutputType | null
    _sum: ContestParticipantSumAggregateOutputType | null
    _min: ContestParticipantMinAggregateOutputType | null
    _max: ContestParticipantMaxAggregateOutputType | null
  }

  type GetContestParticipantGroupByPayload<T extends ContestParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ContestParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ContestParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    contestId?: boolean
    userId?: boolean
    level?: boolean
    rank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contest?: boolean | ContestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    photos?: boolean | ContestParticipant$photosArgs<ExtArgs>
    ContestWinner?: boolean | ContestParticipant$ContestWinnerArgs<ExtArgs>
    contestAchievement?: boolean | ContestParticipant$contestAchievementArgs<ExtArgs>
    _count?: boolean | ContestParticipantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contestParticipant"]>



  export type ContestParticipantSelectScalar = {
    id?: boolean
    status?: boolean
    contestId?: boolean
    userId?: boolean
    level?: boolean
    rank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContestParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "contestId" | "userId" | "level" | "rank" | "createdAt" | "updatedAt", ExtArgs["result"]["contestParticipant"]>
  export type ContestParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contest?: boolean | ContestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    photos?: boolean | ContestParticipant$photosArgs<ExtArgs>
    ContestWinner?: boolean | ContestParticipant$ContestWinnerArgs<ExtArgs>
    contestAchievement?: boolean | ContestParticipant$contestAchievementArgs<ExtArgs>
    _count?: boolean | ContestParticipantCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContestParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContestParticipant"
    objects: {
      contest: Prisma.$ContestPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      photos: Prisma.$ContestPhotoPayload<ExtArgs>[]
      ContestWinner: Prisma.$ContestWinnerPayload<ExtArgs>[]
      contestAchievement: Prisma.$ContestAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.ContestParticipantStatus
      contestId: string
      userId: string
      level: $Enums.ContestLevel
      rank: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contestParticipant"]>
    composites: {}
  }

  type ContestParticipantGetPayload<S extends boolean | null | undefined | ContestParticipantDefaultArgs> = $Result.GetResult<Prisma.$ContestParticipantPayload, S>

  type ContestParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContestParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContestParticipantCountAggregateInputType | true
    }

  export interface ContestParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContestParticipant'], meta: { name: 'ContestParticipant' } }
    /**
     * Find zero or one ContestParticipant that matches the filter.
     * @param {ContestParticipantFindUniqueArgs} args - Arguments to find a ContestParticipant
     * @example
     * // Get one ContestParticipant
     * const contestParticipant = await prisma.contestParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContestParticipantFindUniqueArgs>(args: SelectSubset<T, ContestParticipantFindUniqueArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContestParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContestParticipantFindUniqueOrThrowArgs} args - Arguments to find a ContestParticipant
     * @example
     * // Get one ContestParticipant
     * const contestParticipant = await prisma.contestParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContestParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ContestParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestParticipantFindFirstArgs} args - Arguments to find a ContestParticipant
     * @example
     * // Get one ContestParticipant
     * const contestParticipant = await prisma.contestParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContestParticipantFindFirstArgs>(args?: SelectSubset<T, ContestParticipantFindFirstArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestParticipantFindFirstOrThrowArgs} args - Arguments to find a ContestParticipant
     * @example
     * // Get one ContestParticipant
     * const contestParticipant = await prisma.contestParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContestParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ContestParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContestParticipants
     * const contestParticipants = await prisma.contestParticipant.findMany()
     * 
     * // Get first 10 ContestParticipants
     * const contestParticipants = await prisma.contestParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contestParticipantWithIdOnly = await prisma.contestParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContestParticipantFindManyArgs>(args?: SelectSubset<T, ContestParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContestParticipant.
     * @param {ContestParticipantCreateArgs} args - Arguments to create a ContestParticipant.
     * @example
     * // Create one ContestParticipant
     * const ContestParticipant = await prisma.contestParticipant.create({
     *   data: {
     *     // ... data to create a ContestParticipant
     *   }
     * })
     * 
     */
    create<T extends ContestParticipantCreateArgs>(args: SelectSubset<T, ContestParticipantCreateArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContestParticipants.
     * @param {ContestParticipantCreateManyArgs} args - Arguments to create many ContestParticipants.
     * @example
     * // Create many ContestParticipants
     * const contestParticipant = await prisma.contestParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContestParticipantCreateManyArgs>(args?: SelectSubset<T, ContestParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContestParticipant.
     * @param {ContestParticipantDeleteArgs} args - Arguments to delete one ContestParticipant.
     * @example
     * // Delete one ContestParticipant
     * const ContestParticipant = await prisma.contestParticipant.delete({
     *   where: {
     *     // ... filter to delete one ContestParticipant
     *   }
     * })
     * 
     */
    delete<T extends ContestParticipantDeleteArgs>(args: SelectSubset<T, ContestParticipantDeleteArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContestParticipant.
     * @param {ContestParticipantUpdateArgs} args - Arguments to update one ContestParticipant.
     * @example
     * // Update one ContestParticipant
     * const contestParticipant = await prisma.contestParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContestParticipantUpdateArgs>(args: SelectSubset<T, ContestParticipantUpdateArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContestParticipants.
     * @param {ContestParticipantDeleteManyArgs} args - Arguments to filter ContestParticipants to delete.
     * @example
     * // Delete a few ContestParticipants
     * const { count } = await prisma.contestParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContestParticipantDeleteManyArgs>(args?: SelectSubset<T, ContestParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContestParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContestParticipants
     * const contestParticipant = await prisma.contestParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContestParticipantUpdateManyArgs>(args: SelectSubset<T, ContestParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContestParticipant.
     * @param {ContestParticipantUpsertArgs} args - Arguments to update or create a ContestParticipant.
     * @example
     * // Update or create a ContestParticipant
     * const contestParticipant = await prisma.contestParticipant.upsert({
     *   create: {
     *     // ... data to create a ContestParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContestParticipant we want to update
     *   }
     * })
     */
    upsert<T extends ContestParticipantUpsertArgs>(args: SelectSubset<T, ContestParticipantUpsertArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestParticipants that matches the filter.
     * @param {ContestParticipantFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contestParticipant = await prisma.contestParticipant.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ContestParticipantFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ContestParticipant.
     * @param {ContestParticipantAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contestParticipant = await prisma.contestParticipant.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ContestParticipantAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ContestParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestParticipantCountArgs} args - Arguments to filter ContestParticipants to count.
     * @example
     * // Count the number of ContestParticipants
     * const count = await prisma.contestParticipant.count({
     *   where: {
     *     // ... the filter for the ContestParticipants we want to count
     *   }
     * })
    **/
    count<T extends ContestParticipantCountArgs>(
      args?: Subset<T, ContestParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContestParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestParticipantAggregateArgs>(args: Subset<T, ContestParticipantAggregateArgs>): Prisma.PrismaPromise<GetContestParticipantAggregateType<T>>

    /**
     * Group by ContestParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContestParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContestParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ContestParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContestParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContestParticipant model
   */
  readonly fields: ContestParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContestParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContestParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contest<T extends ContestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestDefaultArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    photos<T extends ContestParticipant$photosArgs<ExtArgs> = {}>(args?: Subset<T, ContestParticipant$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ContestWinner<T extends ContestParticipant$ContestWinnerArgs<ExtArgs> = {}>(args?: Subset<T, ContestParticipant$ContestWinnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestWinnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contestAchievement<T extends ContestParticipant$contestAchievementArgs<ExtArgs> = {}>(args?: Subset<T, ContestParticipant$contestAchievementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContestParticipant model
   */
  interface ContestParticipantFieldRefs {
    readonly id: FieldRef<"ContestParticipant", 'String'>
    readonly status: FieldRef<"ContestParticipant", 'ContestParticipantStatus'>
    readonly contestId: FieldRef<"ContestParticipant", 'String'>
    readonly userId: FieldRef<"ContestParticipant", 'String'>
    readonly level: FieldRef<"ContestParticipant", 'ContestLevel'>
    readonly rank: FieldRef<"ContestParticipant", 'Int'>
    readonly createdAt: FieldRef<"ContestParticipant", 'DateTime'>
    readonly updatedAt: FieldRef<"ContestParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContestParticipant findUnique
   */
  export type ContestParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ContestParticipant to fetch.
     */
    where: ContestParticipantWhereUniqueInput
  }

  /**
   * ContestParticipant findUniqueOrThrow
   */
  export type ContestParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ContestParticipant to fetch.
     */
    where: ContestParticipantWhereUniqueInput
  }

  /**
   * ContestParticipant findFirst
   */
  export type ContestParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ContestParticipant to fetch.
     */
    where?: ContestParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestParticipants to fetch.
     */
    orderBy?: ContestParticipantOrderByWithRelationInput | ContestParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestParticipants.
     */
    cursor?: ContestParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestParticipants.
     */
    distinct?: ContestParticipantScalarFieldEnum | ContestParticipantScalarFieldEnum[]
  }

  /**
   * ContestParticipant findFirstOrThrow
   */
  export type ContestParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ContestParticipant to fetch.
     */
    where?: ContestParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestParticipants to fetch.
     */
    orderBy?: ContestParticipantOrderByWithRelationInput | ContestParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestParticipants.
     */
    cursor?: ContestParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestParticipants.
     */
    distinct?: ContestParticipantScalarFieldEnum | ContestParticipantScalarFieldEnum[]
  }

  /**
   * ContestParticipant findMany
   */
  export type ContestParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ContestParticipants to fetch.
     */
    where?: ContestParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestParticipants to fetch.
     */
    orderBy?: ContestParticipantOrderByWithRelationInput | ContestParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContestParticipants.
     */
    cursor?: ContestParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestParticipants.
     */
    skip?: number
    distinct?: ContestParticipantScalarFieldEnum | ContestParticipantScalarFieldEnum[]
  }

  /**
   * ContestParticipant create
   */
  export type ContestParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a ContestParticipant.
     */
    data: XOR<ContestParticipantCreateInput, ContestParticipantUncheckedCreateInput>
  }

  /**
   * ContestParticipant createMany
   */
  export type ContestParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContestParticipants.
     */
    data: ContestParticipantCreateManyInput | ContestParticipantCreateManyInput[]
  }

  /**
   * ContestParticipant update
   */
  export type ContestParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a ContestParticipant.
     */
    data: XOR<ContestParticipantUpdateInput, ContestParticipantUncheckedUpdateInput>
    /**
     * Choose, which ContestParticipant to update.
     */
    where: ContestParticipantWhereUniqueInput
  }

  /**
   * ContestParticipant updateMany
   */
  export type ContestParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContestParticipants.
     */
    data: XOR<ContestParticipantUpdateManyMutationInput, ContestParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ContestParticipants to update
     */
    where?: ContestParticipantWhereInput
    /**
     * Limit how many ContestParticipants to update.
     */
    limit?: number
  }

  /**
   * ContestParticipant upsert
   */
  export type ContestParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the ContestParticipant to update in case it exists.
     */
    where: ContestParticipantWhereUniqueInput
    /**
     * In case the ContestParticipant found by the `where` argument doesn't exist, create a new ContestParticipant with this data.
     */
    create: XOR<ContestParticipantCreateInput, ContestParticipantUncheckedCreateInput>
    /**
     * In case the ContestParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContestParticipantUpdateInput, ContestParticipantUncheckedUpdateInput>
  }

  /**
   * ContestParticipant delete
   */
  export type ContestParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    /**
     * Filter which ContestParticipant to delete.
     */
    where: ContestParticipantWhereUniqueInput
  }

  /**
   * ContestParticipant deleteMany
   */
  export type ContestParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestParticipants to delete
     */
    where?: ContestParticipantWhereInput
    /**
     * Limit how many ContestParticipants to delete.
     */
    limit?: number
  }

  /**
   * ContestParticipant findRaw
   */
  export type ContestParticipantFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestParticipant aggregateRaw
   */
  export type ContestParticipantAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestParticipant.photos
   */
  export type ContestParticipant$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    where?: ContestPhotoWhereInput
    orderBy?: ContestPhotoOrderByWithRelationInput | ContestPhotoOrderByWithRelationInput[]
    cursor?: ContestPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestPhotoScalarFieldEnum | ContestPhotoScalarFieldEnum[]
  }

  /**
   * ContestParticipant.ContestWinner
   */
  export type ContestParticipant$ContestWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestWinner
     */
    select?: ContestWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestWinner
     */
    omit?: ContestWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestWinnerInclude<ExtArgs> | null
    where?: ContestWinnerWhereInput
    orderBy?: ContestWinnerOrderByWithRelationInput | ContestWinnerOrderByWithRelationInput[]
    cursor?: ContestWinnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestWinnerScalarFieldEnum | ContestWinnerScalarFieldEnum[]
  }

  /**
   * ContestParticipant.contestAchievement
   */
  export type ContestParticipant$contestAchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    where?: ContestAchievementWhereInput
    orderBy?: ContestAchievementOrderByWithRelationInput | ContestAchievementOrderByWithRelationInput[]
    cursor?: ContestAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestAchievementScalarFieldEnum | ContestAchievementScalarFieldEnum[]
  }

  /**
   * ContestParticipant without action
   */
  export type ContestParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
  }


  /**
   * Model ContestPrize
   */

  export type AggregateContestPrize = {
    _count: ContestPrizeCountAggregateOutputType | null
    _avg: ContestPrizeAvgAggregateOutputType | null
    _sum: ContestPrizeSumAggregateOutputType | null
    _min: ContestPrizeMinAggregateOutputType | null
    _max: ContestPrizeMaxAggregateOutputType | null
  }

  export type ContestPrizeAvgAggregateOutputType = {
    trades: number | null
    charges: number | null
    keys: number | null
  }

  export type ContestPrizeSumAggregateOutputType = {
    trades: number | null
    charges: number | null
    keys: number | null
  }

  export type ContestPrizeMinAggregateOutputType = {
    id: string | null
    category: $Enums.PrizeType | null
    trades: number | null
    charges: number | null
    keys: number | null
    contestId: string | null
  }

  export type ContestPrizeMaxAggregateOutputType = {
    id: string | null
    category: $Enums.PrizeType | null
    trades: number | null
    charges: number | null
    keys: number | null
    contestId: string | null
  }

  export type ContestPrizeCountAggregateOutputType = {
    id: number
    category: number
    trades: number
    charges: number
    keys: number
    contestId: number
    _all: number
  }


  export type ContestPrizeAvgAggregateInputType = {
    trades?: true
    charges?: true
    keys?: true
  }

  export type ContestPrizeSumAggregateInputType = {
    trades?: true
    charges?: true
    keys?: true
  }

  export type ContestPrizeMinAggregateInputType = {
    id?: true
    category?: true
    trades?: true
    charges?: true
    keys?: true
    contestId?: true
  }

  export type ContestPrizeMaxAggregateInputType = {
    id?: true
    category?: true
    trades?: true
    charges?: true
    keys?: true
    contestId?: true
  }

  export type ContestPrizeCountAggregateInputType = {
    id?: true
    category?: true
    trades?: true
    charges?: true
    keys?: true
    contestId?: true
    _all?: true
  }

  export type ContestPrizeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestPrize to aggregate.
     */
    where?: ContestPrizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestPrizes to fetch.
     */
    orderBy?: ContestPrizeOrderByWithRelationInput | ContestPrizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContestPrizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestPrizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestPrizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContestPrizes
    **/
    _count?: true | ContestPrizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContestPrizeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContestPrizeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestPrizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestPrizeMaxAggregateInputType
  }

  export type GetContestPrizeAggregateType<T extends ContestPrizeAggregateArgs> = {
        [P in keyof T & keyof AggregateContestPrize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContestPrize[P]>
      : GetScalarType<T[P], AggregateContestPrize[P]>
  }




  export type ContestPrizeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestPrizeWhereInput
    orderBy?: ContestPrizeOrderByWithAggregationInput | ContestPrizeOrderByWithAggregationInput[]
    by: ContestPrizeScalarFieldEnum[] | ContestPrizeScalarFieldEnum
    having?: ContestPrizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestPrizeCountAggregateInputType | true
    _avg?: ContestPrizeAvgAggregateInputType
    _sum?: ContestPrizeSumAggregateInputType
    _min?: ContestPrizeMinAggregateInputType
    _max?: ContestPrizeMaxAggregateInputType
  }

  export type ContestPrizeGroupByOutputType = {
    id: string
    category: $Enums.PrizeType
    trades: number
    charges: number
    keys: number
    contestId: string
    _count: ContestPrizeCountAggregateOutputType | null
    _avg: ContestPrizeAvgAggregateOutputType | null
    _sum: ContestPrizeSumAggregateOutputType | null
    _min: ContestPrizeMinAggregateOutputType | null
    _max: ContestPrizeMaxAggregateOutputType | null
  }

  type GetContestPrizeGroupByPayload<T extends ContestPrizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestPrizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestPrizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestPrizeGroupByOutputType[P]>
            : GetScalarType<T[P], ContestPrizeGroupByOutputType[P]>
        }
      >
    >


  export type ContestPrizeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    trades?: boolean
    charges?: boolean
    keys?: boolean
    contestId?: boolean
    contest?: boolean | ContestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contestPrize"]>



  export type ContestPrizeSelectScalar = {
    id?: boolean
    category?: boolean
    trades?: boolean
    charges?: boolean
    keys?: boolean
    contestId?: boolean
  }

  export type ContestPrizeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category" | "trades" | "charges" | "keys" | "contestId", ExtArgs["result"]["contestPrize"]>
  export type ContestPrizeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contest?: boolean | ContestDefaultArgs<ExtArgs>
  }

  export type $ContestPrizePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContestPrize"
    objects: {
      contest: Prisma.$ContestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: $Enums.PrizeType
      trades: number
      charges: number
      keys: number
      contestId: string
    }, ExtArgs["result"]["contestPrize"]>
    composites: {}
  }

  type ContestPrizeGetPayload<S extends boolean | null | undefined | ContestPrizeDefaultArgs> = $Result.GetResult<Prisma.$ContestPrizePayload, S>

  type ContestPrizeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContestPrizeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContestPrizeCountAggregateInputType | true
    }

  export interface ContestPrizeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContestPrize'], meta: { name: 'ContestPrize' } }
    /**
     * Find zero or one ContestPrize that matches the filter.
     * @param {ContestPrizeFindUniqueArgs} args - Arguments to find a ContestPrize
     * @example
     * // Get one ContestPrize
     * const contestPrize = await prisma.contestPrize.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContestPrizeFindUniqueArgs>(args: SelectSubset<T, ContestPrizeFindUniqueArgs<ExtArgs>>): Prisma__ContestPrizeClient<$Result.GetResult<Prisma.$ContestPrizePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContestPrize that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContestPrizeFindUniqueOrThrowArgs} args - Arguments to find a ContestPrize
     * @example
     * // Get one ContestPrize
     * const contestPrize = await prisma.contestPrize.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContestPrizeFindUniqueOrThrowArgs>(args: SelectSubset<T, ContestPrizeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContestPrizeClient<$Result.GetResult<Prisma.$ContestPrizePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestPrize that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPrizeFindFirstArgs} args - Arguments to find a ContestPrize
     * @example
     * // Get one ContestPrize
     * const contestPrize = await prisma.contestPrize.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContestPrizeFindFirstArgs>(args?: SelectSubset<T, ContestPrizeFindFirstArgs<ExtArgs>>): Prisma__ContestPrizeClient<$Result.GetResult<Prisma.$ContestPrizePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestPrize that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPrizeFindFirstOrThrowArgs} args - Arguments to find a ContestPrize
     * @example
     * // Get one ContestPrize
     * const contestPrize = await prisma.contestPrize.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContestPrizeFindFirstOrThrowArgs>(args?: SelectSubset<T, ContestPrizeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContestPrizeClient<$Result.GetResult<Prisma.$ContestPrizePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestPrizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPrizeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContestPrizes
     * const contestPrizes = await prisma.contestPrize.findMany()
     * 
     * // Get first 10 ContestPrizes
     * const contestPrizes = await prisma.contestPrize.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contestPrizeWithIdOnly = await prisma.contestPrize.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContestPrizeFindManyArgs>(args?: SelectSubset<T, ContestPrizeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestPrizePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContestPrize.
     * @param {ContestPrizeCreateArgs} args - Arguments to create a ContestPrize.
     * @example
     * // Create one ContestPrize
     * const ContestPrize = await prisma.contestPrize.create({
     *   data: {
     *     // ... data to create a ContestPrize
     *   }
     * })
     * 
     */
    create<T extends ContestPrizeCreateArgs>(args: SelectSubset<T, ContestPrizeCreateArgs<ExtArgs>>): Prisma__ContestPrizeClient<$Result.GetResult<Prisma.$ContestPrizePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContestPrizes.
     * @param {ContestPrizeCreateManyArgs} args - Arguments to create many ContestPrizes.
     * @example
     * // Create many ContestPrizes
     * const contestPrize = await prisma.contestPrize.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContestPrizeCreateManyArgs>(args?: SelectSubset<T, ContestPrizeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContestPrize.
     * @param {ContestPrizeDeleteArgs} args - Arguments to delete one ContestPrize.
     * @example
     * // Delete one ContestPrize
     * const ContestPrize = await prisma.contestPrize.delete({
     *   where: {
     *     // ... filter to delete one ContestPrize
     *   }
     * })
     * 
     */
    delete<T extends ContestPrizeDeleteArgs>(args: SelectSubset<T, ContestPrizeDeleteArgs<ExtArgs>>): Prisma__ContestPrizeClient<$Result.GetResult<Prisma.$ContestPrizePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContestPrize.
     * @param {ContestPrizeUpdateArgs} args - Arguments to update one ContestPrize.
     * @example
     * // Update one ContestPrize
     * const contestPrize = await prisma.contestPrize.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContestPrizeUpdateArgs>(args: SelectSubset<T, ContestPrizeUpdateArgs<ExtArgs>>): Prisma__ContestPrizeClient<$Result.GetResult<Prisma.$ContestPrizePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContestPrizes.
     * @param {ContestPrizeDeleteManyArgs} args - Arguments to filter ContestPrizes to delete.
     * @example
     * // Delete a few ContestPrizes
     * const { count } = await prisma.contestPrize.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContestPrizeDeleteManyArgs>(args?: SelectSubset<T, ContestPrizeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContestPrizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPrizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContestPrizes
     * const contestPrize = await prisma.contestPrize.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContestPrizeUpdateManyArgs>(args: SelectSubset<T, ContestPrizeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContestPrize.
     * @param {ContestPrizeUpsertArgs} args - Arguments to update or create a ContestPrize.
     * @example
     * // Update or create a ContestPrize
     * const contestPrize = await prisma.contestPrize.upsert({
     *   create: {
     *     // ... data to create a ContestPrize
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContestPrize we want to update
     *   }
     * })
     */
    upsert<T extends ContestPrizeUpsertArgs>(args: SelectSubset<T, ContestPrizeUpsertArgs<ExtArgs>>): Prisma__ContestPrizeClient<$Result.GetResult<Prisma.$ContestPrizePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestPrizes that matches the filter.
     * @param {ContestPrizeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contestPrize = await prisma.contestPrize.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ContestPrizeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ContestPrize.
     * @param {ContestPrizeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contestPrize = await prisma.contestPrize.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ContestPrizeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ContestPrizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPrizeCountArgs} args - Arguments to filter ContestPrizes to count.
     * @example
     * // Count the number of ContestPrizes
     * const count = await prisma.contestPrize.count({
     *   where: {
     *     // ... the filter for the ContestPrizes we want to count
     *   }
     * })
    **/
    count<T extends ContestPrizeCountArgs>(
      args?: Subset<T, ContestPrizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestPrizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContestPrize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPrizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestPrizeAggregateArgs>(args: Subset<T, ContestPrizeAggregateArgs>): Prisma.PrismaPromise<GetContestPrizeAggregateType<T>>

    /**
     * Group by ContestPrize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestPrizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContestPrizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContestPrizeGroupByArgs['orderBy'] }
        : { orderBy?: ContestPrizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContestPrizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestPrizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContestPrize model
   */
  readonly fields: ContestPrizeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContestPrize.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContestPrizeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contest<T extends ContestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestDefaultArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContestPrize model
   */
  interface ContestPrizeFieldRefs {
    readonly id: FieldRef<"ContestPrize", 'String'>
    readonly category: FieldRef<"ContestPrize", 'PrizeType'>
    readonly trades: FieldRef<"ContestPrize", 'Int'>
    readonly charges: FieldRef<"ContestPrize", 'Int'>
    readonly keys: FieldRef<"ContestPrize", 'Int'>
    readonly contestId: FieldRef<"ContestPrize", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContestPrize findUnique
   */
  export type ContestPrizeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
    /**
     * Filter, which ContestPrize to fetch.
     */
    where: ContestPrizeWhereUniqueInput
  }

  /**
   * ContestPrize findUniqueOrThrow
   */
  export type ContestPrizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
    /**
     * Filter, which ContestPrize to fetch.
     */
    where: ContestPrizeWhereUniqueInput
  }

  /**
   * ContestPrize findFirst
   */
  export type ContestPrizeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
    /**
     * Filter, which ContestPrize to fetch.
     */
    where?: ContestPrizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestPrizes to fetch.
     */
    orderBy?: ContestPrizeOrderByWithRelationInput | ContestPrizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestPrizes.
     */
    cursor?: ContestPrizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestPrizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestPrizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestPrizes.
     */
    distinct?: ContestPrizeScalarFieldEnum | ContestPrizeScalarFieldEnum[]
  }

  /**
   * ContestPrize findFirstOrThrow
   */
  export type ContestPrizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
    /**
     * Filter, which ContestPrize to fetch.
     */
    where?: ContestPrizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestPrizes to fetch.
     */
    orderBy?: ContestPrizeOrderByWithRelationInput | ContestPrizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestPrizes.
     */
    cursor?: ContestPrizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestPrizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestPrizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestPrizes.
     */
    distinct?: ContestPrizeScalarFieldEnum | ContestPrizeScalarFieldEnum[]
  }

  /**
   * ContestPrize findMany
   */
  export type ContestPrizeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
    /**
     * Filter, which ContestPrizes to fetch.
     */
    where?: ContestPrizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestPrizes to fetch.
     */
    orderBy?: ContestPrizeOrderByWithRelationInput | ContestPrizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContestPrizes.
     */
    cursor?: ContestPrizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestPrizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestPrizes.
     */
    skip?: number
    distinct?: ContestPrizeScalarFieldEnum | ContestPrizeScalarFieldEnum[]
  }

  /**
   * ContestPrize create
   */
  export type ContestPrizeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
    /**
     * The data needed to create a ContestPrize.
     */
    data: XOR<ContestPrizeCreateInput, ContestPrizeUncheckedCreateInput>
  }

  /**
   * ContestPrize createMany
   */
  export type ContestPrizeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContestPrizes.
     */
    data: ContestPrizeCreateManyInput | ContestPrizeCreateManyInput[]
  }

  /**
   * ContestPrize update
   */
  export type ContestPrizeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
    /**
     * The data needed to update a ContestPrize.
     */
    data: XOR<ContestPrizeUpdateInput, ContestPrizeUncheckedUpdateInput>
    /**
     * Choose, which ContestPrize to update.
     */
    where: ContestPrizeWhereUniqueInput
  }

  /**
   * ContestPrize updateMany
   */
  export type ContestPrizeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContestPrizes.
     */
    data: XOR<ContestPrizeUpdateManyMutationInput, ContestPrizeUncheckedUpdateManyInput>
    /**
     * Filter which ContestPrizes to update
     */
    where?: ContestPrizeWhereInput
    /**
     * Limit how many ContestPrizes to update.
     */
    limit?: number
  }

  /**
   * ContestPrize upsert
   */
  export type ContestPrizeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
    /**
     * The filter to search for the ContestPrize to update in case it exists.
     */
    where: ContestPrizeWhereUniqueInput
    /**
     * In case the ContestPrize found by the `where` argument doesn't exist, create a new ContestPrize with this data.
     */
    create: XOR<ContestPrizeCreateInput, ContestPrizeUncheckedCreateInput>
    /**
     * In case the ContestPrize was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContestPrizeUpdateInput, ContestPrizeUncheckedUpdateInput>
  }

  /**
   * ContestPrize delete
   */
  export type ContestPrizeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
    /**
     * Filter which ContestPrize to delete.
     */
    where: ContestPrizeWhereUniqueInput
  }

  /**
   * ContestPrize deleteMany
   */
  export type ContestPrizeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestPrizes to delete
     */
    where?: ContestPrizeWhereInput
    /**
     * Limit how many ContestPrizes to delete.
     */
    limit?: number
  }

  /**
   * ContestPrize findRaw
   */
  export type ContestPrizeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestPrize aggregateRaw
   */
  export type ContestPrizeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestPrize without action
   */
  export type ContestPrizeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPrize
     */
    select?: ContestPrizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPrize
     */
    omit?: ContestPrizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPrizeInclude<ExtArgs> | null
  }


  /**
   * Model ContestAchievement
   */

  export type AggregateContestAchievement = {
    _count: ContestAchievementCountAggregateOutputType | null
    _min: ContestAchievementMinAggregateOutputType | null
    _max: ContestAchievementMaxAggregateOutputType | null
  }

  export type ContestAchievementMinAggregateOutputType = {
    id: string | null
    category: $Enums.PrizeType | null
    photoId: string | null
    participantId: string | null
    contestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestAchievementMaxAggregateOutputType = {
    id: string | null
    category: $Enums.PrizeType | null
    photoId: string | null
    participantId: string | null
    contestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContestAchievementCountAggregateOutputType = {
    id: number
    category: number
    photoId: number
    participantId: number
    contestId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContestAchievementMinAggregateInputType = {
    id?: true
    category?: true
    photoId?: true
    participantId?: true
    contestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestAchievementMaxAggregateInputType = {
    id?: true
    category?: true
    photoId?: true
    participantId?: true
    contestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContestAchievementCountAggregateInputType = {
    id?: true
    category?: true
    photoId?: true
    participantId?: true
    contestId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContestAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestAchievement to aggregate.
     */
    where?: ContestAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestAchievements to fetch.
     */
    orderBy?: ContestAchievementOrderByWithRelationInput | ContestAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContestAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContestAchievements
    **/
    _count?: true | ContestAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContestAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContestAchievementMaxAggregateInputType
  }

  export type GetContestAchievementAggregateType<T extends ContestAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateContestAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContestAchievement[P]>
      : GetScalarType<T[P], AggregateContestAchievement[P]>
  }




  export type ContestAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContestAchievementWhereInput
    orderBy?: ContestAchievementOrderByWithAggregationInput | ContestAchievementOrderByWithAggregationInput[]
    by: ContestAchievementScalarFieldEnum[] | ContestAchievementScalarFieldEnum
    having?: ContestAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContestAchievementCountAggregateInputType | true
    _min?: ContestAchievementMinAggregateInputType
    _max?: ContestAchievementMaxAggregateInputType
  }

  export type ContestAchievementGroupByOutputType = {
    id: string
    category: $Enums.PrizeType
    photoId: string | null
    participantId: string | null
    contestId: string
    createdAt: Date
    updatedAt: Date
    _count: ContestAchievementCountAggregateOutputType | null
    _min: ContestAchievementMinAggregateOutputType | null
    _max: ContestAchievementMaxAggregateOutputType | null
  }

  type GetContestAchievementGroupByPayload<T extends ContestAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContestAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContestAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContestAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], ContestAchievementGroupByOutputType[P]>
        }
      >
    >


  export type ContestAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    photoId?: boolean
    participantId?: boolean
    contestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    photo?: boolean | ContestAchievement$photoArgs<ExtArgs>
    participant?: boolean | ContestAchievement$participantArgs<ExtArgs>
  }, ExtArgs["result"]["contestAchievement"]>



  export type ContestAchievementSelectScalar = {
    id?: boolean
    category?: boolean
    photoId?: boolean
    participantId?: boolean
    contestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContestAchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category" | "photoId" | "participantId" | "contestId" | "createdAt" | "updatedAt", ExtArgs["result"]["contestAchievement"]>
  export type ContestAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photo?: boolean | ContestAchievement$photoArgs<ExtArgs>
    participant?: boolean | ContestAchievement$participantArgs<ExtArgs>
  }

  export type $ContestAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContestAchievement"
    objects: {
      photo: Prisma.$ContestPhotoPayload<ExtArgs> | null
      participant: Prisma.$ContestParticipantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: $Enums.PrizeType
      photoId: string | null
      participantId: string | null
      contestId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contestAchievement"]>
    composites: {}
  }

  type ContestAchievementGetPayload<S extends boolean | null | undefined | ContestAchievementDefaultArgs> = $Result.GetResult<Prisma.$ContestAchievementPayload, S>

  type ContestAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContestAchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContestAchievementCountAggregateInputType | true
    }

  export interface ContestAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContestAchievement'], meta: { name: 'ContestAchievement' } }
    /**
     * Find zero or one ContestAchievement that matches the filter.
     * @param {ContestAchievementFindUniqueArgs} args - Arguments to find a ContestAchievement
     * @example
     * // Get one ContestAchievement
     * const contestAchievement = await prisma.contestAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContestAchievementFindUniqueArgs>(args: SelectSubset<T, ContestAchievementFindUniqueArgs<ExtArgs>>): Prisma__ContestAchievementClient<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContestAchievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContestAchievementFindUniqueOrThrowArgs} args - Arguments to find a ContestAchievement
     * @example
     * // Get one ContestAchievement
     * const contestAchievement = await prisma.contestAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContestAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, ContestAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContestAchievementClient<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAchievementFindFirstArgs} args - Arguments to find a ContestAchievement
     * @example
     * // Get one ContestAchievement
     * const contestAchievement = await prisma.contestAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContestAchievementFindFirstArgs>(args?: SelectSubset<T, ContestAchievementFindFirstArgs<ExtArgs>>): Prisma__ContestAchievementClient<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContestAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAchievementFindFirstOrThrowArgs} args - Arguments to find a ContestAchievement
     * @example
     * // Get one ContestAchievement
     * const contestAchievement = await prisma.contestAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContestAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, ContestAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContestAchievementClient<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContestAchievements
     * const contestAchievements = await prisma.contestAchievement.findMany()
     * 
     * // Get first 10 ContestAchievements
     * const contestAchievements = await prisma.contestAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contestAchievementWithIdOnly = await prisma.contestAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContestAchievementFindManyArgs>(args?: SelectSubset<T, ContestAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContestAchievement.
     * @param {ContestAchievementCreateArgs} args - Arguments to create a ContestAchievement.
     * @example
     * // Create one ContestAchievement
     * const ContestAchievement = await prisma.contestAchievement.create({
     *   data: {
     *     // ... data to create a ContestAchievement
     *   }
     * })
     * 
     */
    create<T extends ContestAchievementCreateArgs>(args: SelectSubset<T, ContestAchievementCreateArgs<ExtArgs>>): Prisma__ContestAchievementClient<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContestAchievements.
     * @param {ContestAchievementCreateManyArgs} args - Arguments to create many ContestAchievements.
     * @example
     * // Create many ContestAchievements
     * const contestAchievement = await prisma.contestAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContestAchievementCreateManyArgs>(args?: SelectSubset<T, ContestAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContestAchievement.
     * @param {ContestAchievementDeleteArgs} args - Arguments to delete one ContestAchievement.
     * @example
     * // Delete one ContestAchievement
     * const ContestAchievement = await prisma.contestAchievement.delete({
     *   where: {
     *     // ... filter to delete one ContestAchievement
     *   }
     * })
     * 
     */
    delete<T extends ContestAchievementDeleteArgs>(args: SelectSubset<T, ContestAchievementDeleteArgs<ExtArgs>>): Prisma__ContestAchievementClient<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContestAchievement.
     * @param {ContestAchievementUpdateArgs} args - Arguments to update one ContestAchievement.
     * @example
     * // Update one ContestAchievement
     * const contestAchievement = await prisma.contestAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContestAchievementUpdateArgs>(args: SelectSubset<T, ContestAchievementUpdateArgs<ExtArgs>>): Prisma__ContestAchievementClient<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContestAchievements.
     * @param {ContestAchievementDeleteManyArgs} args - Arguments to filter ContestAchievements to delete.
     * @example
     * // Delete a few ContestAchievements
     * const { count } = await prisma.contestAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContestAchievementDeleteManyArgs>(args?: SelectSubset<T, ContestAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContestAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContestAchievements
     * const contestAchievement = await prisma.contestAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContestAchievementUpdateManyArgs>(args: SelectSubset<T, ContestAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContestAchievement.
     * @param {ContestAchievementUpsertArgs} args - Arguments to update or create a ContestAchievement.
     * @example
     * // Update or create a ContestAchievement
     * const contestAchievement = await prisma.contestAchievement.upsert({
     *   create: {
     *     // ... data to create a ContestAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContestAchievement we want to update
     *   }
     * })
     */
    upsert<T extends ContestAchievementUpsertArgs>(args: SelectSubset<T, ContestAchievementUpsertArgs<ExtArgs>>): Prisma__ContestAchievementClient<$Result.GetResult<Prisma.$ContestAchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContestAchievements that matches the filter.
     * @param {ContestAchievementFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contestAchievement = await prisma.contestAchievement.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ContestAchievementFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ContestAchievement.
     * @param {ContestAchievementAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contestAchievement = await prisma.contestAchievement.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ContestAchievementAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ContestAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAchievementCountArgs} args - Arguments to filter ContestAchievements to count.
     * @example
     * // Count the number of ContestAchievements
     * const count = await prisma.contestAchievement.count({
     *   where: {
     *     // ... the filter for the ContestAchievements we want to count
     *   }
     * })
    **/
    count<T extends ContestAchievementCountArgs>(
      args?: Subset<T, ContestAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContestAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContestAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContestAchievementAggregateArgs>(args: Subset<T, ContestAchievementAggregateArgs>): Prisma.PrismaPromise<GetContestAchievementAggregateType<T>>

    /**
     * Group by ContestAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContestAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContestAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContestAchievementGroupByArgs['orderBy'] }
        : { orderBy?: ContestAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContestAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContestAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContestAchievement model
   */
  readonly fields: ContestAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContestAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContestAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photo<T extends ContestAchievement$photoArgs<ExtArgs> = {}>(args?: Subset<T, ContestAchievement$photoArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    participant<T extends ContestAchievement$participantArgs<ExtArgs> = {}>(args?: Subset<T, ContestAchievement$participantArgs<ExtArgs>>): Prisma__ContestParticipantClient<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContestAchievement model
   */
  interface ContestAchievementFieldRefs {
    readonly id: FieldRef<"ContestAchievement", 'String'>
    readonly category: FieldRef<"ContestAchievement", 'PrizeType'>
    readonly photoId: FieldRef<"ContestAchievement", 'String'>
    readonly participantId: FieldRef<"ContestAchievement", 'String'>
    readonly contestId: FieldRef<"ContestAchievement", 'String'>
    readonly createdAt: FieldRef<"ContestAchievement", 'DateTime'>
    readonly updatedAt: FieldRef<"ContestAchievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContestAchievement findUnique
   */
  export type ContestAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    /**
     * Filter, which ContestAchievement to fetch.
     */
    where: ContestAchievementWhereUniqueInput
  }

  /**
   * ContestAchievement findUniqueOrThrow
   */
  export type ContestAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    /**
     * Filter, which ContestAchievement to fetch.
     */
    where: ContestAchievementWhereUniqueInput
  }

  /**
   * ContestAchievement findFirst
   */
  export type ContestAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    /**
     * Filter, which ContestAchievement to fetch.
     */
    where?: ContestAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestAchievements to fetch.
     */
    orderBy?: ContestAchievementOrderByWithRelationInput | ContestAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestAchievements.
     */
    cursor?: ContestAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestAchievements.
     */
    distinct?: ContestAchievementScalarFieldEnum | ContestAchievementScalarFieldEnum[]
  }

  /**
   * ContestAchievement findFirstOrThrow
   */
  export type ContestAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    /**
     * Filter, which ContestAchievement to fetch.
     */
    where?: ContestAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestAchievements to fetch.
     */
    orderBy?: ContestAchievementOrderByWithRelationInput | ContestAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContestAchievements.
     */
    cursor?: ContestAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContestAchievements.
     */
    distinct?: ContestAchievementScalarFieldEnum | ContestAchievementScalarFieldEnum[]
  }

  /**
   * ContestAchievement findMany
   */
  export type ContestAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    /**
     * Filter, which ContestAchievements to fetch.
     */
    where?: ContestAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContestAchievements to fetch.
     */
    orderBy?: ContestAchievementOrderByWithRelationInput | ContestAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContestAchievements.
     */
    cursor?: ContestAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContestAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContestAchievements.
     */
    skip?: number
    distinct?: ContestAchievementScalarFieldEnum | ContestAchievementScalarFieldEnum[]
  }

  /**
   * ContestAchievement create
   */
  export type ContestAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a ContestAchievement.
     */
    data: XOR<ContestAchievementCreateInput, ContestAchievementUncheckedCreateInput>
  }

  /**
   * ContestAchievement createMany
   */
  export type ContestAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContestAchievements.
     */
    data: ContestAchievementCreateManyInput | ContestAchievementCreateManyInput[]
  }

  /**
   * ContestAchievement update
   */
  export type ContestAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a ContestAchievement.
     */
    data: XOR<ContestAchievementUpdateInput, ContestAchievementUncheckedUpdateInput>
    /**
     * Choose, which ContestAchievement to update.
     */
    where: ContestAchievementWhereUniqueInput
  }

  /**
   * ContestAchievement updateMany
   */
  export type ContestAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContestAchievements.
     */
    data: XOR<ContestAchievementUpdateManyMutationInput, ContestAchievementUncheckedUpdateManyInput>
    /**
     * Filter which ContestAchievements to update
     */
    where?: ContestAchievementWhereInput
    /**
     * Limit how many ContestAchievements to update.
     */
    limit?: number
  }

  /**
   * ContestAchievement upsert
   */
  export type ContestAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the ContestAchievement to update in case it exists.
     */
    where: ContestAchievementWhereUniqueInput
    /**
     * In case the ContestAchievement found by the `where` argument doesn't exist, create a new ContestAchievement with this data.
     */
    create: XOR<ContestAchievementCreateInput, ContestAchievementUncheckedCreateInput>
    /**
     * In case the ContestAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContestAchievementUpdateInput, ContestAchievementUncheckedUpdateInput>
  }

  /**
   * ContestAchievement delete
   */
  export type ContestAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
    /**
     * Filter which ContestAchievement to delete.
     */
    where: ContestAchievementWhereUniqueInput
  }

  /**
   * ContestAchievement deleteMany
   */
  export type ContestAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContestAchievements to delete
     */
    where?: ContestAchievementWhereInput
    /**
     * Limit how many ContestAchievements to delete.
     */
    limit?: number
  }

  /**
   * ContestAchievement findRaw
   */
  export type ContestAchievementFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestAchievement aggregateRaw
   */
  export type ContestAchievementAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContestAchievement.photo
   */
  export type ContestAchievement$photoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    where?: ContestPhotoWhereInput
  }

  /**
   * ContestAchievement.participant
   */
  export type ContestAchievement$participantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    where?: ContestParticipantWhereInput
  }

  /**
   * ContestAchievement without action
   */
  export type ContestAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestAchievement
     */
    select?: ContestAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestAchievement
     */
    omit?: ContestAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestAchievementInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    level: string | null
    language: string | null
    country: string | null
    description: string | null
    accessibility: $Enums.TeamAccessibility | null
    badge: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    level: string | null
    language: string | null
    country: string | null
    description: string | null
    accessibility: $Enums.TeamAccessibility | null
    badge: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    level: number
    language: number
    country: number
    description: number
    accessibility: number
    badge: number
    creatorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    level?: true
    language?: true
    country?: true
    description?: true
    accessibility?: true
    badge?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    level?: true
    language?: true
    country?: true
    description?: true
    accessibility?: true
    badge?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    level?: true
    language?: true
    country?: true
    description?: true
    accessibility?: true
    badge?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility: $Enums.TeamAccessibility
    badge: string
    creatorId: string
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    language?: boolean
    country?: boolean
    description?: boolean
    accessibility?: boolean
    badge?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>



  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    level?: boolean
    language?: boolean
    country?: boolean
    description?: boolean
    accessibility?: boolean
    badge?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "level" | "language" | "country" | "description" | "accessibility" | "badge" | "creatorId" | "createdAt" | "updatedAt", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$TeamMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      level: string
      language: string
      country: string
      description: string
      accessibility: $Enums.TeamAccessibility
      badge: string
      creatorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * @param {TeamFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const team = await prisma.team.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TeamFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Team.
     * @param {TeamAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const team = await prisma.team.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TeamAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends Team$membersArgs<ExtArgs> = {}>(args?: Subset<T, Team$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly level: FieldRef<"Team", 'String'>
    readonly language: FieldRef<"Team", 'String'>
    readonly country: FieldRef<"Team", 'String'>
    readonly description: FieldRef<"Team", 'String'>
    readonly accessibility: FieldRef<"Team", 'TeamAccessibility'>
    readonly badge: FieldRef<"Team", 'String'>
    readonly creatorId: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team findRaw
   */
  export type TeamFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Team aggregateRaw
   */
  export type TeamAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Team.members
   */
  export type Team$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: string | null
    status: $Enums.TeamMemberStatus | null
    teamId: string | null
    memberId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: string | null
    status: $Enums.TeamMemberStatus | null
    teamId: string | null
    memberId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    status: number
    teamId: number
    memberId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMemberMinAggregateInputType = {
    id?: true
    status?: true
    teamId?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    status?: true
    teamId?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    status?: true
    teamId?: true
    memberId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    id: string
    status: $Enums.TeamMemberStatus
    teamId: string
    memberId: string
    createdAt: Date
    updatedAt: Date
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    teamId?: boolean
    memberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    member?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>



  export type TeamMemberSelectScalar = {
    id?: boolean
    status?: boolean
    teamId?: boolean
    memberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "teamId" | "memberId" | "createdAt" | "updatedAt", ExtArgs["result"]["teamMember"]>
  export type TeamMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    member?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMember"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      member: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.TeamMemberStatus
      teamId: string
      memberId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> = $Result.GetResult<Prisma.$TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMemberFindManyArgs>(args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
     */
    create<T extends TeamMemberCreateArgs>(args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMemberCreateManyArgs>(args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
     */
    delete<T extends TeamMemberDeleteArgs>(args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMemberUpdateArgs>(args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * @param {TeamMemberFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const teamMember = await prisma.teamMember.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TeamMemberFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TeamMember.
     * @param {TeamMemberAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const teamMember = await prisma.teamMember.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TeamMemberAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMember model
   */
  readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    member<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMember model
   */
  interface TeamMemberFieldRefs {
    readonly id: FieldRef<"TeamMember", 'String'>
    readonly status: FieldRef<"TeamMember", 'TeamMemberStatus'>
    readonly teamId: FieldRef<"TeamMember", 'String'>
    readonly memberId: FieldRef<"TeamMember", 'String'>
    readonly createdAt: FieldRef<"TeamMember", 'DateTime'>
    readonly updatedAt: FieldRef<"TeamMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
  }

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
  }

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to delete.
     */
    limit?: number
  }

  /**
   * TeamMember findRaw
   */
  export type TeamMemberFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TeamMember aggregateRaw
   */
  export type TeamMemberAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    cover: string | null
    avatar: string | null
    socialId: string | null
    socialProvider: string | null
    firstName: string | null
    lastName: string | null
    fullName: string | null
    username: string | null
    phone: string | null
    email: string | null
    location: string | null
    level: $Enums.UserLevel | null
    password: string | null
    role: $Enums.UserRole | null
    accessToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    cover: string | null
    avatar: string | null
    socialId: string | null
    socialProvider: string | null
    firstName: string | null
    lastName: string | null
    fullName: string | null
    username: string | null
    phone: string | null
    email: string | null
    location: string | null
    level: $Enums.UserLevel | null
    password: string | null
    role: $Enums.UserRole | null
    accessToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    cover: number
    avatar: number
    socialId: number
    socialProvider: number
    firstName: number
    lastName: number
    fullName: number
    username: number
    phone: number
    email: number
    location: number
    level: number
    password: number
    role: number
    accessToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    cover?: true
    avatar?: true
    socialId?: true
    socialProvider?: true
    firstName?: true
    lastName?: true
    fullName?: true
    username?: true
    phone?: true
    email?: true
    location?: true
    level?: true
    password?: true
    role?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    cover?: true
    avatar?: true
    socialId?: true
    socialProvider?: true
    firstName?: true
    lastName?: true
    fullName?: true
    username?: true
    phone?: true
    email?: true
    location?: true
    level?: true
    password?: true
    role?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    cover?: true
    avatar?: true
    socialId?: true
    socialProvider?: true
    firstName?: true
    lastName?: true
    fullName?: true
    username?: true
    phone?: true
    email?: true
    location?: true
    level?: true
    password?: true
    role?: true
    accessToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    cover: string | null
    avatar: string | null
    socialId: string | null
    socialProvider: string | null
    firstName: string | null
    lastName: string | null
    fullName: string | null
    username: string | null
    phone: string | null
    email: string
    location: string | null
    level: $Enums.UserLevel | null
    password: string | null
    role: $Enums.UserRole
    accessToken: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cover?: boolean
    avatar?: boolean
    socialId?: boolean
    socialProvider?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    username?: boolean
    phone?: boolean
    email?: boolean
    location?: boolean
    level?: boolean
    password?: boolean
    role?: boolean
    accessToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    otps?: boolean | User$otpsArgs<ExtArgs>
    createdTeam?: boolean | User$createdTeamArgs<ExtArgs>
    joinedTeam?: boolean | User$joinedTeamArgs<ExtArgs>
    createdContests?: boolean | User$createdContestsArgs<ExtArgs>
    commentProvides?: boolean | User$commentProvidesArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    followings?: boolean | User$followingsArgs<ExtArgs>
    votes?: boolean | User$votesArgs<ExtArgs>
    likes?: boolean | User$likesArgs<ExtArgs>
    userPhotos?: boolean | User$userPhotosArgs<ExtArgs>
    ContestParticipant?: boolean | User$ContestParticipantArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    cover?: boolean
    avatar?: boolean
    socialId?: boolean
    socialProvider?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    username?: boolean
    phone?: boolean
    email?: boolean
    location?: boolean
    level?: boolean
    password?: boolean
    role?: boolean
    accessToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cover" | "avatar" | "socialId" | "socialProvider" | "firstName" | "lastName" | "fullName" | "username" | "phone" | "email" | "location" | "level" | "password" | "role" | "accessToken" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    otps?: boolean | User$otpsArgs<ExtArgs>
    createdTeam?: boolean | User$createdTeamArgs<ExtArgs>
    joinedTeam?: boolean | User$joinedTeamArgs<ExtArgs>
    createdContests?: boolean | User$createdContestsArgs<ExtArgs>
    commentProvides?: boolean | User$commentProvidesArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    followings?: boolean | User$followingsArgs<ExtArgs>
    votes?: boolean | User$votesArgs<ExtArgs>
    likes?: boolean | User$likesArgs<ExtArgs>
    userPhotos?: boolean | User$userPhotosArgs<ExtArgs>
    ContestParticipant?: boolean | User$ContestParticipantArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      otps: Prisma.$OtpPayload<ExtArgs> | null
      createdTeam: Prisma.$TeamPayload<ExtArgs>[]
      joinedTeam: Prisma.$TeamMemberPayload<ExtArgs> | null
      createdContests: Prisma.$ContestPayload<ExtArgs>[]
      commentProvides: Prisma.$CommentPayload<ExtArgs>[]
      followers: Prisma.$FollowPayload<ExtArgs>[]
      followings: Prisma.$FollowPayload<ExtArgs>[]
      votes: Prisma.$VotePayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
      userPhotos: Prisma.$UserPhotoPayload<ExtArgs>[]
      ContestParticipant: Prisma.$ContestParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cover: string | null
      avatar: string | null
      socialId: string | null
      socialProvider: string | null
      firstName: string | null
      lastName: string | null
      fullName: string | null
      username: string | null
      phone: string | null
      email: string
      location: string | null
      level: $Enums.UserLevel | null
      password: string | null
      role: $Enums.UserRole
      accessToken: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    otps<T extends User$otpsArgs<ExtArgs> = {}>(args?: Subset<T, User$otpsArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdTeam<T extends User$createdTeamArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTeamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    joinedTeam<T extends User$joinedTeamArgs<ExtArgs> = {}>(args?: Subset<T, User$joinedTeamArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdContests<T extends User$createdContestsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdContestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commentProvides<T extends User$commentProvidesArgs<ExtArgs> = {}>(args?: Subset<T, User$commentProvidesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followers<T extends User$followersArgs<ExtArgs> = {}>(args?: Subset<T, User$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followings<T extends User$followingsArgs<ExtArgs> = {}>(args?: Subset<T, User$followingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    votes<T extends User$votesArgs<ExtArgs> = {}>(args?: Subset<T, User$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends User$likesArgs<ExtArgs> = {}>(args?: Subset<T, User$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userPhotos<T extends User$userPhotosArgs<ExtArgs> = {}>(args?: Subset<T, User$userPhotosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ContestParticipant<T extends User$ContestParticipantArgs<ExtArgs> = {}>(args?: Subset<T, User$ContestParticipantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly cover: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly socialId: FieldRef<"User", 'String'>
    readonly socialProvider: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly location: FieldRef<"User", 'String'>
    readonly level: FieldRef<"User", 'UserLevel'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly accessToken: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.otps
   */
  export type User$otpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    where?: OtpWhereInput
  }

  /**
   * User.createdTeam
   */
  export type User$createdTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * User.joinedTeam
   */
  export type User$joinedTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
  }

  /**
   * User.createdContests
   */
  export type User$createdContestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contest
     */
    select?: ContestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contest
     */
    omit?: ContestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestInclude<ExtArgs> | null
    where?: ContestWhereInput
    orderBy?: ContestOrderByWithRelationInput | ContestOrderByWithRelationInput[]
    cursor?: ContestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestScalarFieldEnum | ContestScalarFieldEnum[]
  }

  /**
   * User.commentProvides
   */
  export type User$commentProvidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.followers
   */
  export type User$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * User.followings
   */
  export type User$followingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * User.votes
   */
  export type User$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    cursor?: VoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * User.likes
   */
  export type User$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * User.userPhotos
   */
  export type User$userPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    where?: UserPhotoWhereInput
    orderBy?: UserPhotoOrderByWithRelationInput | UserPhotoOrderByWithRelationInput[]
    cursor?: UserPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPhotoScalarFieldEnum | UserPhotoScalarFieldEnum[]
  }

  /**
   * User.ContestParticipant
   */
  export type User$ContestParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestParticipant
     */
    select?: ContestParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestParticipant
     */
    omit?: ContestParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestParticipantInclude<ExtArgs> | null
    where?: ContestParticipantWhereInput
    orderBy?: ContestParticipantOrderByWithRelationInput | ContestParticipantOrderByWithRelationInput[]
    cursor?: ContestParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestParticipantScalarFieldEnum | ContestParticipantScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserPhoto
   */

  export type AggregateUserPhoto = {
    _count: UserPhotoCountAggregateOutputType | null
    _avg: UserPhotoAvgAggregateOutputType | null
    _sum: UserPhotoSumAggregateOutputType | null
    _min: UserPhotoMinAggregateOutputType | null
    _max: UserPhotoMaxAggregateOutputType | null
  }

  export type UserPhotoAvgAggregateOutputType = {
    views: number | null
  }

  export type UserPhotoSumAggregateOutputType = {
    views: number | null
  }

  export type UserPhotoMinAggregateOutputType = {
    id: string | null
    url: string | null
    userId: string | null
    views: number | null
    title: string | null
    description: string | null
    adult: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPhotoMaxAggregateOutputType = {
    id: string | null
    url: string | null
    userId: string | null
    views: number | null
    title: string | null
    description: string | null
    adult: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPhotoCountAggregateOutputType = {
    id: number
    url: number
    userId: number
    views: number
    labels: number
    title: number
    description: number
    adult: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPhotoAvgAggregateInputType = {
    views?: true
  }

  export type UserPhotoSumAggregateInputType = {
    views?: true
  }

  export type UserPhotoMinAggregateInputType = {
    id?: true
    url?: true
    userId?: true
    views?: true
    title?: true
    description?: true
    adult?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPhotoMaxAggregateInputType = {
    id?: true
    url?: true
    userId?: true
    views?: true
    title?: true
    description?: true
    adult?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPhotoCountAggregateInputType = {
    id?: true
    url?: true
    userId?: true
    views?: true
    labels?: true
    title?: true
    description?: true
    adult?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPhoto to aggregate.
     */
    where?: UserPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhotos to fetch.
     */
    orderBy?: UserPhotoOrderByWithRelationInput | UserPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPhotos
    **/
    _count?: true | UserPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPhotoMaxAggregateInputType
  }

  export type GetUserPhotoAggregateType<T extends UserPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPhoto[P]>
      : GetScalarType<T[P], AggregateUserPhoto[P]>
  }




  export type UserPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPhotoWhereInput
    orderBy?: UserPhotoOrderByWithAggregationInput | UserPhotoOrderByWithAggregationInput[]
    by: UserPhotoScalarFieldEnum[] | UserPhotoScalarFieldEnum
    having?: UserPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPhotoCountAggregateInputType | true
    _avg?: UserPhotoAvgAggregateInputType
    _sum?: UserPhotoSumAggregateInputType
    _min?: UserPhotoMinAggregateInputType
    _max?: UserPhotoMaxAggregateInputType
  }

  export type UserPhotoGroupByOutputType = {
    id: string
    url: string
    userId: string
    views: number
    labels: string[]
    title: string | null
    description: string | null
    adult: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserPhotoCountAggregateOutputType | null
    _avg: UserPhotoAvgAggregateOutputType | null
    _sum: UserPhotoSumAggregateOutputType | null
    _min: UserPhotoMinAggregateOutputType | null
    _max: UserPhotoMaxAggregateOutputType | null
  }

  type GetUserPhotoGroupByPayload<T extends UserPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], UserPhotoGroupByOutputType[P]>
        }
      >
    >


  export type UserPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    userId?: boolean
    states?: boolean | PhotoStatsDefaultArgs<ExtArgs>
    views?: boolean
    labels?: boolean
    title?: boolean
    description?: boolean
    adult?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contestUpload?: boolean | UserPhoto$contestUploadArgs<ExtArgs>
    likes?: boolean | UserPhoto$likesArgs<ExtArgs>
    _count?: boolean | UserPhotoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPhoto"]>



  export type UserPhotoSelectScalar = {
    id?: boolean
    url?: boolean
    userId?: boolean
    views?: boolean
    labels?: boolean
    title?: boolean
    description?: boolean
    adult?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "userId" | "states" | "views" | "labels" | "title" | "description" | "adult" | "createdAt" | "updatedAt", ExtArgs["result"]["userPhoto"]>
  export type UserPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contestUpload?: boolean | UserPhoto$contestUploadArgs<ExtArgs>
    likes?: boolean | UserPhoto$likesArgs<ExtArgs>
    _count?: boolean | UserPhotoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPhoto"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      contestUpload: Prisma.$ContestPhotoPayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      userId: string
      views: number
      labels: string[]
      title: string | null
      description: string | null
      adult: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPhoto"]>
    composites: {
      states: Prisma.$PhotoStatsPayload | null
    }
  }

  type UserPhotoGetPayload<S extends boolean | null | undefined | UserPhotoDefaultArgs> = $Result.GetResult<Prisma.$UserPhotoPayload, S>

  type UserPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPhotoCountAggregateInputType | true
    }

  export interface UserPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPhoto'], meta: { name: 'UserPhoto' } }
    /**
     * Find zero or one UserPhoto that matches the filter.
     * @param {UserPhotoFindUniqueArgs} args - Arguments to find a UserPhoto
     * @example
     * // Get one UserPhoto
     * const userPhoto = await prisma.userPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPhotoFindUniqueArgs>(args: SelectSubset<T, UserPhotoFindUniqueArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPhotoFindUniqueOrThrowArgs} args - Arguments to find a UserPhoto
     * @example
     * // Get one UserPhoto
     * const userPhoto = await prisma.userPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoFindFirstArgs} args - Arguments to find a UserPhoto
     * @example
     * // Get one UserPhoto
     * const userPhoto = await prisma.userPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPhotoFindFirstArgs>(args?: SelectSubset<T, UserPhotoFindFirstArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoFindFirstOrThrowArgs} args - Arguments to find a UserPhoto
     * @example
     * // Get one UserPhoto
     * const userPhoto = await prisma.userPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPhotos
     * const userPhotos = await prisma.userPhoto.findMany()
     * 
     * // Get first 10 UserPhotos
     * const userPhotos = await prisma.userPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPhotoWithIdOnly = await prisma.userPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPhotoFindManyArgs>(args?: SelectSubset<T, UserPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPhoto.
     * @param {UserPhotoCreateArgs} args - Arguments to create a UserPhoto.
     * @example
     * // Create one UserPhoto
     * const UserPhoto = await prisma.userPhoto.create({
     *   data: {
     *     // ... data to create a UserPhoto
     *   }
     * })
     * 
     */
    create<T extends UserPhotoCreateArgs>(args: SelectSubset<T, UserPhotoCreateArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPhotos.
     * @param {UserPhotoCreateManyArgs} args - Arguments to create many UserPhotos.
     * @example
     * // Create many UserPhotos
     * const userPhoto = await prisma.userPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPhotoCreateManyArgs>(args?: SelectSubset<T, UserPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserPhoto.
     * @param {UserPhotoDeleteArgs} args - Arguments to delete one UserPhoto.
     * @example
     * // Delete one UserPhoto
     * const UserPhoto = await prisma.userPhoto.delete({
     *   where: {
     *     // ... filter to delete one UserPhoto
     *   }
     * })
     * 
     */
    delete<T extends UserPhotoDeleteArgs>(args: SelectSubset<T, UserPhotoDeleteArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPhoto.
     * @param {UserPhotoUpdateArgs} args - Arguments to update one UserPhoto.
     * @example
     * // Update one UserPhoto
     * const userPhoto = await prisma.userPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPhotoUpdateArgs>(args: SelectSubset<T, UserPhotoUpdateArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPhotos.
     * @param {UserPhotoDeleteManyArgs} args - Arguments to filter UserPhotos to delete.
     * @example
     * // Delete a few UserPhotos
     * const { count } = await prisma.userPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPhotoDeleteManyArgs>(args?: SelectSubset<T, UserPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPhotos
     * const userPhoto = await prisma.userPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPhotoUpdateManyArgs>(args: SelectSubset<T, UserPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPhoto.
     * @param {UserPhotoUpsertArgs} args - Arguments to update or create a UserPhoto.
     * @example
     * // Update or create a UserPhoto
     * const userPhoto = await prisma.userPhoto.upsert({
     *   create: {
     *     // ... data to create a UserPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPhoto we want to update
     *   }
     * })
     */
    upsert<T extends UserPhotoUpsertArgs>(args: SelectSubset<T, UserPhotoUpsertArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPhotos that matches the filter.
     * @param {UserPhotoFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userPhoto = await prisma.userPhoto.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserPhotoFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserPhoto.
     * @param {UserPhotoAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userPhoto = await prisma.userPhoto.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserPhotoAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoCountArgs} args - Arguments to filter UserPhotos to count.
     * @example
     * // Count the number of UserPhotos
     * const count = await prisma.userPhoto.count({
     *   where: {
     *     // ... the filter for the UserPhotos we want to count
     *   }
     * })
    **/
    count<T extends UserPhotoCountArgs>(
      args?: Subset<T, UserPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPhotoAggregateArgs>(args: Subset<T, UserPhotoAggregateArgs>): Prisma.PrismaPromise<GetUserPhotoAggregateType<T>>

    /**
     * Group by UserPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPhotoGroupByArgs['orderBy'] }
        : { orderBy?: UserPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPhoto model
   */
  readonly fields: UserPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contestUpload<T extends UserPhoto$contestUploadArgs<ExtArgs> = {}>(args?: Subset<T, UserPhoto$contestUploadArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends UserPhoto$likesArgs<ExtArgs> = {}>(args?: Subset<T, UserPhoto$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPhoto model
   */
  interface UserPhotoFieldRefs {
    readonly id: FieldRef<"UserPhoto", 'String'>
    readonly url: FieldRef<"UserPhoto", 'String'>
    readonly userId: FieldRef<"UserPhoto", 'String'>
    readonly views: FieldRef<"UserPhoto", 'Int'>
    readonly labels: FieldRef<"UserPhoto", 'String[]'>
    readonly title: FieldRef<"UserPhoto", 'String'>
    readonly description: FieldRef<"UserPhoto", 'String'>
    readonly adult: FieldRef<"UserPhoto", 'Boolean'>
    readonly createdAt: FieldRef<"UserPhoto", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPhoto findUnique
   */
  export type UserPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * Filter, which UserPhoto to fetch.
     */
    where: UserPhotoWhereUniqueInput
  }

  /**
   * UserPhoto findUniqueOrThrow
   */
  export type UserPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * Filter, which UserPhoto to fetch.
     */
    where: UserPhotoWhereUniqueInput
  }

  /**
   * UserPhoto findFirst
   */
  export type UserPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * Filter, which UserPhoto to fetch.
     */
    where?: UserPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhotos to fetch.
     */
    orderBy?: UserPhotoOrderByWithRelationInput | UserPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPhotos.
     */
    cursor?: UserPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPhotos.
     */
    distinct?: UserPhotoScalarFieldEnum | UserPhotoScalarFieldEnum[]
  }

  /**
   * UserPhoto findFirstOrThrow
   */
  export type UserPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * Filter, which UserPhoto to fetch.
     */
    where?: UserPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhotos to fetch.
     */
    orderBy?: UserPhotoOrderByWithRelationInput | UserPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPhotos.
     */
    cursor?: UserPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPhotos.
     */
    distinct?: UserPhotoScalarFieldEnum | UserPhotoScalarFieldEnum[]
  }

  /**
   * UserPhoto findMany
   */
  export type UserPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * Filter, which UserPhotos to fetch.
     */
    where?: UserPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhotos to fetch.
     */
    orderBy?: UserPhotoOrderByWithRelationInput | UserPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPhotos.
     */
    cursor?: UserPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhotos.
     */
    skip?: number
    distinct?: UserPhotoScalarFieldEnum | UserPhotoScalarFieldEnum[]
  }

  /**
   * UserPhoto create
   */
  export type UserPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPhoto.
     */
    data: XOR<UserPhotoCreateInput, UserPhotoUncheckedCreateInput>
  }

  /**
   * UserPhoto createMany
   */
  export type UserPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPhotos.
     */
    data: UserPhotoCreateManyInput | UserPhotoCreateManyInput[]
  }

  /**
   * UserPhoto update
   */
  export type UserPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPhoto.
     */
    data: XOR<UserPhotoUpdateInput, UserPhotoUncheckedUpdateInput>
    /**
     * Choose, which UserPhoto to update.
     */
    where: UserPhotoWhereUniqueInput
  }

  /**
   * UserPhoto updateMany
   */
  export type UserPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPhotos.
     */
    data: XOR<UserPhotoUpdateManyMutationInput, UserPhotoUncheckedUpdateManyInput>
    /**
     * Filter which UserPhotos to update
     */
    where?: UserPhotoWhereInput
    /**
     * Limit how many UserPhotos to update.
     */
    limit?: number
  }

  /**
   * UserPhoto upsert
   */
  export type UserPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPhoto to update in case it exists.
     */
    where: UserPhotoWhereUniqueInput
    /**
     * In case the UserPhoto found by the `where` argument doesn't exist, create a new UserPhoto with this data.
     */
    create: XOR<UserPhotoCreateInput, UserPhotoUncheckedCreateInput>
    /**
     * In case the UserPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPhotoUpdateInput, UserPhotoUncheckedUpdateInput>
  }

  /**
   * UserPhoto delete
   */
  export type UserPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
    /**
     * Filter which UserPhoto to delete.
     */
    where: UserPhotoWhereUniqueInput
  }

  /**
   * UserPhoto deleteMany
   */
  export type UserPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPhotos to delete
     */
    where?: UserPhotoWhereInput
    /**
     * Limit how many UserPhotos to delete.
     */
    limit?: number
  }

  /**
   * UserPhoto findRaw
   */
  export type UserPhotoFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserPhoto aggregateRaw
   */
  export type UserPhotoAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserPhoto.contestUpload
   */
  export type UserPhoto$contestUploadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContestPhoto
     */
    select?: ContestPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContestPhoto
     */
    omit?: ContestPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContestPhotoInclude<ExtArgs> | null
    where?: ContestPhotoWhereInput
    orderBy?: ContestPhotoOrderByWithRelationInput | ContestPhotoOrderByWithRelationInput[]
    cursor?: ContestPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContestPhotoScalarFieldEnum | ContestPhotoScalarFieldEnum[]
  }

  /**
   * UserPhoto.likes
   */
  export type UserPhoto$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * UserPhoto without action
   */
  export type UserPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoto
     */
    select?: UserPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoto
     */
    omit?: UserPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhotoInclude<ExtArgs> | null
  }


  /**
   * Model Like
   */

  export type AggregateLike = {
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  export type LikeMinAggregateOutputType = {
    id: string | null
    providerId: string | null
    photoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LikeMaxAggregateOutputType = {
    id: string | null
    providerId: string | null
    photoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LikeCountAggregateOutputType = {
    id: number
    providerId: number
    photoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LikeMinAggregateInputType = {
    id?: true
    providerId?: true
    photoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LikeMaxAggregateInputType = {
    id?: true
    providerId?: true
    photoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LikeCountAggregateInputType = {
    id?: true
    providerId?: true
    photoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Like to aggregate.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Likes
    **/
    _count?: true | LikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikeMaxAggregateInputType
  }

  export type GetLikeAggregateType<T extends LikeAggregateArgs> = {
        [P in keyof T & keyof AggregateLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLike[P]>
      : GetScalarType<T[P], AggregateLike[P]>
  }




  export type LikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithAggregationInput | LikeOrderByWithAggregationInput[]
    by: LikeScalarFieldEnum[] | LikeScalarFieldEnum
    having?: LikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikeCountAggregateInputType | true
    _min?: LikeMinAggregateInputType
    _max?: LikeMaxAggregateInputType
  }

  export type LikeGroupByOutputType = {
    id: string
    providerId: string
    photoId: string
    createdAt: Date
    updatedAt: Date
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  type GetLikeGroupByPayload<T extends LikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikeGroupByOutputType[P]>
            : GetScalarType<T[P], LikeGroupByOutputType[P]>
        }
      >
    >


  export type LikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    photoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | UserDefaultArgs<ExtArgs>
    photo?: boolean | UserPhotoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>



  export type LikeSelectScalar = {
    id?: boolean
    providerId?: boolean
    photoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "photoId" | "createdAt" | "updatedAt", ExtArgs["result"]["like"]>
  export type LikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | UserDefaultArgs<ExtArgs>
    photo?: boolean | UserPhotoDefaultArgs<ExtArgs>
  }

  export type $LikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Like"
    objects: {
      provider: Prisma.$UserPayload<ExtArgs>
      photo: Prisma.$UserPhotoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerId: string
      photoId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["like"]>
    composites: {}
  }

  type LikeGetPayload<S extends boolean | null | undefined | LikeDefaultArgs> = $Result.GetResult<Prisma.$LikePayload, S>

  type LikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LikeCountAggregateInputType | true
    }

  export interface LikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Like'], meta: { name: 'Like' } }
    /**
     * Find zero or one Like that matches the filter.
     * @param {LikeFindUniqueArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikeFindUniqueArgs>(args: SelectSubset<T, LikeFindUniqueArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Like that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LikeFindUniqueOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikeFindUniqueOrThrowArgs>(args: SelectSubset<T, LikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Like that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikeFindFirstArgs>(args?: SelectSubset<T, LikeFindFirstArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Like that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikeFindFirstOrThrowArgs>(args?: SelectSubset<T, LikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Likes
     * const likes = await prisma.like.findMany()
     * 
     * // Get first 10 Likes
     * const likes = await prisma.like.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likeWithIdOnly = await prisma.like.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LikeFindManyArgs>(args?: SelectSubset<T, LikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Like.
     * @param {LikeCreateArgs} args - Arguments to create a Like.
     * @example
     * // Create one Like
     * const Like = await prisma.like.create({
     *   data: {
     *     // ... data to create a Like
     *   }
     * })
     * 
     */
    create<T extends LikeCreateArgs>(args: SelectSubset<T, LikeCreateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Likes.
     * @param {LikeCreateManyArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikeCreateManyArgs>(args?: SelectSubset<T, LikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Like.
     * @param {LikeDeleteArgs} args - Arguments to delete one Like.
     * @example
     * // Delete one Like
     * const Like = await prisma.like.delete({
     *   where: {
     *     // ... filter to delete one Like
     *   }
     * })
     * 
     */
    delete<T extends LikeDeleteArgs>(args: SelectSubset<T, LikeDeleteArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Like.
     * @param {LikeUpdateArgs} args - Arguments to update one Like.
     * @example
     * // Update one Like
     * const like = await prisma.like.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikeUpdateArgs>(args: SelectSubset<T, LikeUpdateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Likes.
     * @param {LikeDeleteManyArgs} args - Arguments to filter Likes to delete.
     * @example
     * // Delete a few Likes
     * const { count } = await prisma.like.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikeDeleteManyArgs>(args?: SelectSubset<T, LikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikeUpdateManyArgs>(args: SelectSubset<T, LikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Like.
     * @param {LikeUpsertArgs} args - Arguments to update or create a Like.
     * @example
     * // Update or create a Like
     * const like = await prisma.like.upsert({
     *   create: {
     *     // ... data to create a Like
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Like we want to update
     *   }
     * })
     */
    upsert<T extends LikeUpsertArgs>(args: SelectSubset<T, LikeUpsertArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Likes that matches the filter.
     * @param {LikeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const like = await prisma.like.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: LikeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Like.
     * @param {LikeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const like = await prisma.like.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LikeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCountArgs} args - Arguments to filter Likes to count.
     * @example
     * // Count the number of Likes
     * const count = await prisma.like.count({
     *   where: {
     *     // ... the filter for the Likes we want to count
     *   }
     * })
    **/
    count<T extends LikeCountArgs>(
      args?: Subset<T, LikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikeAggregateArgs>(args: Subset<T, LikeAggregateArgs>): Prisma.PrismaPromise<GetLikeAggregateType<T>>

    /**
     * Group by Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikeGroupByArgs['orderBy'] }
        : { orderBy?: LikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Like model
   */
  readonly fields: LikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Like.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    photo<T extends UserPhotoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserPhotoDefaultArgs<ExtArgs>>): Prisma__UserPhotoClient<$Result.GetResult<Prisma.$UserPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Like model
   */
  interface LikeFieldRefs {
    readonly id: FieldRef<"Like", 'String'>
    readonly providerId: FieldRef<"Like", 'String'>
    readonly photoId: FieldRef<"Like", 'String'>
    readonly createdAt: FieldRef<"Like", 'DateTime'>
    readonly updatedAt: FieldRef<"Like", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Like findUnique
   */
  export type LikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findUniqueOrThrow
   */
  export type LikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findFirst
   */
  export type LikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findFirstOrThrow
   */
  export type LikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findMany
   */
  export type LikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like create
   */
  export type LikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to create a Like.
     */
    data: XOR<LikeCreateInput, LikeUncheckedCreateInput>
  }

  /**
   * Like createMany
   */
  export type LikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
  }

  /**
   * Like update
   */
  export type LikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to update a Like.
     */
    data: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
    /**
     * Choose, which Like to update.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like updateMany
   */
  export type LikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
    /**
     * Limit how many Likes to update.
     */
    limit?: number
  }

  /**
   * Like upsert
   */
  export type LikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The filter to search for the Like to update in case it exists.
     */
    where: LikeWhereUniqueInput
    /**
     * In case the Like found by the `where` argument doesn't exist, create a new Like with this data.
     */
    create: XOR<LikeCreateInput, LikeUncheckedCreateInput>
    /**
     * In case the Like was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
  }

  /**
   * Like delete
   */
  export type LikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter which Like to delete.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like deleteMany
   */
  export type LikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Likes to delete
     */
    where?: LikeWhereInput
    /**
     * Limit how many Likes to delete.
     */
    limit?: number
  }

  /**
   * Like findRaw
   */
  export type LikeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Like aggregateRaw
   */
  export type LikeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Like without action
   */
  export type LikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
  }


  /**
   * Model Otp
   */

  export type AggregateOtp = {
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  export type OtpMinAggregateOutputType = {
    id: string | null
    code: string | null
    expires_in: Date | null
    userId: string | null
    otpStatus: $Enums.OtpStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
  }

  export type OtpMaxAggregateOutputType = {
    id: string | null
    code: string | null
    expires_in: Date | null
    userId: string | null
    otpStatus: $Enums.OtpStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
  }

  export type OtpCountAggregateOutputType = {
    id: number
    code: number
    expires_in: number
    userId: number
    otpStatus: number
    createdAt: number
    updatedAt: number
    expiresAt: number
    _all: number
  }


  export type OtpMinAggregateInputType = {
    id?: true
    code?: true
    expires_in?: true
    userId?: true
    otpStatus?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
  }

  export type OtpMaxAggregateInputType = {
    id?: true
    code?: true
    expires_in?: true
    userId?: true
    otpStatus?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
  }

  export type OtpCountAggregateInputType = {
    id?: true
    code?: true
    expires_in?: true
    userId?: true
    otpStatus?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    _all?: true
  }

  export type OtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otp to aggregate.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Otps
    **/
    _count?: true | OtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpMaxAggregateInputType
  }

  export type GetOtpAggregateType<T extends OtpAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp[P]>
      : GetScalarType<T[P], AggregateOtp[P]>
  }




  export type OtpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
    orderBy?: OtpOrderByWithAggregationInput | OtpOrderByWithAggregationInput[]
    by: OtpScalarFieldEnum[] | OtpScalarFieldEnum
    having?: OtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCountAggregateInputType | true
    _min?: OtpMinAggregateInputType
    _max?: OtpMaxAggregateInputType
  }

  export type OtpGroupByOutputType = {
    id: string
    code: string
    expires_in: Date
    userId: string
    otpStatus: $Enums.OtpStatus
    createdAt: Date
    updatedAt: Date
    expiresAt: Date
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  type GetOtpGroupByPayload<T extends OtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpGroupByOutputType[P]>
            : GetScalarType<T[P], OtpGroupByOutputType[P]>
        }
      >
    >


  export type OtpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    expires_in?: boolean
    userId?: boolean
    otpStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["otp"]>



  export type OtpSelectScalar = {
    id?: boolean
    code?: boolean
    expires_in?: boolean
    userId?: boolean
    otpStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
  }

  export type OtpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "expires_in" | "userId" | "otpStatus" | "createdAt" | "updatedAt" | "expiresAt", ExtArgs["result"]["otp"]>
  export type OtpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OtpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Otp"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      expires_in: Date
      userId: string
      otpStatus: $Enums.OtpStatus
      createdAt: Date
      updatedAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["otp"]>
    composites: {}
  }

  type OtpGetPayload<S extends boolean | null | undefined | OtpDefaultArgs> = $Result.GetResult<Prisma.$OtpPayload, S>

  type OtpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OtpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OtpCountAggregateInputType | true
    }

  export interface OtpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Otp'], meta: { name: 'Otp' } }
    /**
     * Find zero or one Otp that matches the filter.
     * @param {OtpFindUniqueArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtpFindUniqueArgs>(args: SelectSubset<T, OtpFindUniqueArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Otp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OtpFindUniqueOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtpFindUniqueOrThrowArgs>(args: SelectSubset<T, OtpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtpFindFirstArgs>(args?: SelectSubset<T, OtpFindFirstArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtpFindFirstOrThrowArgs>(args?: SelectSubset<T, OtpFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otp.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpWithIdOnly = await prisma.otp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtpFindManyArgs>(args?: SelectSubset<T, OtpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Otp.
     * @param {OtpCreateArgs} args - Arguments to create a Otp.
     * @example
     * // Create one Otp
     * const Otp = await prisma.otp.create({
     *   data: {
     *     // ... data to create a Otp
     *   }
     * })
     * 
     */
    create<T extends OtpCreateArgs>(args: SelectSubset<T, OtpCreateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Otps.
     * @param {OtpCreateManyArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtpCreateManyArgs>(args?: SelectSubset<T, OtpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Otp.
     * @param {OtpDeleteArgs} args - Arguments to delete one Otp.
     * @example
     * // Delete one Otp
     * const Otp = await prisma.otp.delete({
     *   where: {
     *     // ... filter to delete one Otp
     *   }
     * })
     * 
     */
    delete<T extends OtpDeleteArgs>(args: SelectSubset<T, OtpDeleteArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Otp.
     * @param {OtpUpdateArgs} args - Arguments to update one Otp.
     * @example
     * // Update one Otp
     * const otp = await prisma.otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtpUpdateArgs>(args: SelectSubset<T, OtpUpdateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Otps.
     * @param {OtpDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtpDeleteManyArgs>(args?: SelectSubset<T, OtpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtpUpdateManyArgs>(args: SelectSubset<T, OtpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Otp.
     * @param {OtpUpsertArgs} args - Arguments to update or create a Otp.
     * @example
     * // Update or create a Otp
     * const otp = await prisma.otp.upsert({
     *   create: {
     *     // ... data to create a Otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp we want to update
     *   }
     * })
     */
    upsert<T extends OtpUpsertArgs>(args: SelectSubset<T, OtpUpsertArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Otps that matches the filter.
     * @param {OtpFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const otp = await prisma.otp.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: OtpFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Otp.
     * @param {OtpAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const otp = await prisma.otp.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: OtpAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otp.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends OtpCountArgs>(
      args?: Subset<T, OtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAggregateArgs>(args: Subset<T, OtpAggregateArgs>): Prisma.PrismaPromise<GetOtpAggregateType<T>>

    /**
     * Group by Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpGroupByArgs['orderBy'] }
        : { orderBy?: OtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Otp model
   */
  readonly fields: OtpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Otp model
   */
  interface OtpFieldRefs {
    readonly id: FieldRef<"Otp", 'String'>
    readonly code: FieldRef<"Otp", 'String'>
    readonly expires_in: FieldRef<"Otp", 'DateTime'>
    readonly userId: FieldRef<"Otp", 'String'>
    readonly otpStatus: FieldRef<"Otp", 'OtpStatus'>
    readonly createdAt: FieldRef<"Otp", 'DateTime'>
    readonly updatedAt: FieldRef<"Otp", 'DateTime'>
    readonly expiresAt: FieldRef<"Otp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Otp findUnique
   */
  export type OtpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findUniqueOrThrow
   */
  export type OtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findFirst
   */
  export type OtpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findFirstOrThrow
   */
  export type OtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findMany
   */
  export type OtpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter, which Otps to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp create
   */
  export type OtpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The data needed to create a Otp.
     */
    data: XOR<OtpCreateInput, OtpUncheckedCreateInput>
  }

  /**
   * Otp createMany
   */
  export type OtpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Otps.
     */
    data: OtpCreateManyInput | OtpCreateManyInput[]
  }

  /**
   * Otp update
   */
  export type OtpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The data needed to update a Otp.
     */
    data: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
    /**
     * Choose, which Otp to update.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp updateMany
   */
  export type OtpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to update.
     */
    limit?: number
  }

  /**
   * Otp upsert
   */
  export type OtpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * The filter to search for the Otp to update in case it exists.
     */
    where: OtpWhereUniqueInput
    /**
     * In case the Otp found by the `where` argument doesn't exist, create a new Otp with this data.
     */
    create: XOR<OtpCreateInput, OtpUncheckedCreateInput>
    /**
     * In case the Otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
  }

  /**
   * Otp delete
   */
  export type OtpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
    /**
     * Filter which Otp to delete.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp deleteMany
   */
  export type OtpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otps to delete
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to delete.
     */
    limit?: number
  }

  /**
   * Otp findRaw
   */
  export type OtpFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Otp aggregateRaw
   */
  export type OtpAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Otp without action
   */
  export type OtpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OtpInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    text: string | null
    providerId: string | null
    receiverId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    text: string | null
    providerId: string | null
    receiverId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    text: number
    providerId: number
    receiverId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    text?: true
    providerId?: true
    receiverId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    text?: true
    providerId?: true
    receiverId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    text?: true
    providerId?: true
    receiverId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    text: string
    providerId: string
    receiverId: string
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    providerId?: boolean
    receiverId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | ContestPhotoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>



  export type CommentSelectScalar = {
    id?: boolean
    text?: boolean
    providerId?: boolean
    receiverId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "text" | "providerId" | "receiverId" | "createdAt" | "updatedAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | ContestPhotoDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      provider: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$ContestPhotoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      providerId: string
      receiverId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * @param {CommentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const comment = await prisma.comment.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CommentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Comment.
     * @param {CommentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const comment = await prisma.comment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CommentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receiver<T extends ContestPhotoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestPhotoDefaultArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly text: FieldRef<"Comment", 'String'>
    readonly providerId: FieldRef<"Comment", 'String'>
    readonly receiverId: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment findRaw
   */
  export type CommentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Comment aggregateRaw
   */
  export type CommentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Follow
   */

  export type AggregateFollow = {
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  export type FollowMinAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FollowMaxAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FollowCountAggregateOutputType = {
    id: number
    followerId: number
    followingId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FollowMinAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FollowMaxAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FollowCountAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follow to aggregate.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Follows
    **/
    _count?: true | FollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowMaxAggregateInputType
  }

  export type GetFollowAggregateType<T extends FollowAggregateArgs> = {
        [P in keyof T & keyof AggregateFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollow[P]>
      : GetScalarType<T[P], AggregateFollow[P]>
  }




  export type FollowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithAggregationInput | FollowOrderByWithAggregationInput[]
    by: FollowScalarFieldEnum[] | FollowScalarFieldEnum
    having?: FollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowCountAggregateInputType | true
    _min?: FollowMinAggregateInputType
    _max?: FollowMaxAggregateInputType
  }

  export type FollowGroupByOutputType = {
    id: string
    followerId: string
    followingId: string
    createdAt: Date
    updatedAt: Date
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  type GetFollowGroupByPayload<T extends FollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowGroupByOutputType[P]>
            : GetScalarType<T[P], FollowGroupByOutputType[P]>
        }
      >
    >


  export type FollowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>



  export type FollowSelectScalar = {
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FollowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "followerId" | "followingId" | "createdAt" | "updatedAt", ExtArgs["result"]["follow"]>
  export type FollowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UserDefaultArgs<ExtArgs>
    following?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FollowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Follow"
    objects: {
      follower: Prisma.$UserPayload<ExtArgs>
      following: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      followerId: string
      followingId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["follow"]>
    composites: {}
  }

  type FollowGetPayload<S extends boolean | null | undefined | FollowDefaultArgs> = $Result.GetResult<Prisma.$FollowPayload, S>

  type FollowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FollowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowCountAggregateInputType | true
    }

  export interface FollowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Follow'], meta: { name: 'Follow' } }
    /**
     * Find zero or one Follow that matches the filter.
     * @param {FollowFindUniqueArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowFindUniqueArgs>(args: SelectSubset<T, FollowFindUniqueArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Follow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowFindUniqueOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowFindFirstArgs>(args?: SelectSubset<T, FollowFindFirstArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follow.findMany()
     * 
     * // Get first 10 Follows
     * const follows = await prisma.follow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followWithIdOnly = await prisma.follow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowFindManyArgs>(args?: SelectSubset<T, FollowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Follow.
     * @param {FollowCreateArgs} args - Arguments to create a Follow.
     * @example
     * // Create one Follow
     * const Follow = await prisma.follow.create({
     *   data: {
     *     // ... data to create a Follow
     *   }
     * })
     * 
     */
    create<T extends FollowCreateArgs>(args: SelectSubset<T, FollowCreateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Follows.
     * @param {FollowCreateManyArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowCreateManyArgs>(args?: SelectSubset<T, FollowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Follow.
     * @param {FollowDeleteArgs} args - Arguments to delete one Follow.
     * @example
     * // Delete one Follow
     * const Follow = await prisma.follow.delete({
     *   where: {
     *     // ... filter to delete one Follow
     *   }
     * })
     * 
     */
    delete<T extends FollowDeleteArgs>(args: SelectSubset<T, FollowDeleteArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Follow.
     * @param {FollowUpdateArgs} args - Arguments to update one Follow.
     * @example
     * // Update one Follow
     * const follow = await prisma.follow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowUpdateArgs>(args: SelectSubset<T, FollowUpdateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Follows.
     * @param {FollowDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowDeleteManyArgs>(args?: SelectSubset<T, FollowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowUpdateManyArgs>(args: SelectSubset<T, FollowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Follow.
     * @param {FollowUpsertArgs} args - Arguments to update or create a Follow.
     * @example
     * // Update or create a Follow
     * const follow = await prisma.follow.upsert({
     *   create: {
     *     // ... data to create a Follow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follow we want to update
     *   }
     * })
     */
    upsert<T extends FollowUpsertArgs>(args: SelectSubset<T, FollowUpsertArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Follows that matches the filter.
     * @param {FollowFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const follow = await prisma.follow.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FollowFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Follow.
     * @param {FollowAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const follow = await prisma.follow.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FollowAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follow.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
    **/
    count<T extends FollowCountArgs>(
      args?: Subset<T, FollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowAggregateArgs>(args: Subset<T, FollowAggregateArgs>): Prisma.PrismaPromise<GetFollowAggregateType<T>>

    /**
     * Group by Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowGroupByArgs['orderBy'] }
        : { orderBy?: FollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Follow model
   */
  readonly fields: FollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Follow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    follower<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    following<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Follow model
   */
  interface FollowFieldRefs {
    readonly id: FieldRef<"Follow", 'String'>
    readonly followerId: FieldRef<"Follow", 'String'>
    readonly followingId: FieldRef<"Follow", 'String'>
    readonly createdAt: FieldRef<"Follow", 'DateTime'>
    readonly updatedAt: FieldRef<"Follow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Follow findUnique
   */
  export type FollowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findUniqueOrThrow
   */
  export type FollowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findFirst
   */
  export type FollowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findFirstOrThrow
   */
  export type FollowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findMany
   */
  export type FollowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow create
   */
  export type FollowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to create a Follow.
     */
    data: XOR<FollowCreateInput, FollowUncheckedCreateInput>
  }

  /**
   * Follow createMany
   */
  export type FollowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
  }

  /**
   * Follow update
   */
  export type FollowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to update a Follow.
     */
    data: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
    /**
     * Choose, which Follow to update.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow updateMany
   */
  export type FollowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to update.
     */
    limit?: number
  }

  /**
   * Follow upsert
   */
  export type FollowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The filter to search for the Follow to update in case it exists.
     */
    where: FollowWhereUniqueInput
    /**
     * In case the Follow found by the `where` argument doesn't exist, create a new Follow with this data.
     */
    create: XOR<FollowCreateInput, FollowUncheckedCreateInput>
    /**
     * In case the Follow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
  }

  /**
   * Follow delete
   */
  export type FollowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter which Follow to delete.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow deleteMany
   */
  export type FollowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follows to delete
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to delete.
     */
    limit?: number
  }

  /**
   * Follow findRaw
   */
  export type FollowFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Follow aggregateRaw
   */
  export type FollowAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Follow without action
   */
  export type FollowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
  }


  /**
   * Model Vote
   */

  export type AggregateVote = {
    _count: VoteCountAggregateOutputType | null
    _min: VoteMinAggregateOutputType | null
    _max: VoteMaxAggregateOutputType | null
  }

  export type VoteMinAggregateOutputType = {
    id: string | null
    providerId: string | null
    photoId: string | null
    contestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoteMaxAggregateOutputType = {
    id: string | null
    providerId: string | null
    photoId: string | null
    contestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoteCountAggregateOutputType = {
    id: number
    providerId: number
    photoId: number
    contestId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VoteMinAggregateInputType = {
    id?: true
    providerId?: true
    photoId?: true
    contestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoteMaxAggregateInputType = {
    id?: true
    providerId?: true
    photoId?: true
    contestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoteCountAggregateInputType = {
    id?: true
    providerId?: true
    photoId?: true
    contestId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vote to aggregate.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Votes
    **/
    _count?: true | VoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoteMaxAggregateInputType
  }

  export type GetVoteAggregateType<T extends VoteAggregateArgs> = {
        [P in keyof T & keyof AggregateVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVote[P]>
      : GetScalarType<T[P], AggregateVote[P]>
  }




  export type VoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithAggregationInput | VoteOrderByWithAggregationInput[]
    by: VoteScalarFieldEnum[] | VoteScalarFieldEnum
    having?: VoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoteCountAggregateInputType | true
    _min?: VoteMinAggregateInputType
    _max?: VoteMaxAggregateInputType
  }

  export type VoteGroupByOutputType = {
    id: string
    providerId: string
    photoId: string
    contestId: string
    createdAt: Date
    updatedAt: Date
    _count: VoteCountAggregateOutputType | null
    _min: VoteMinAggregateOutputType | null
    _max: VoteMaxAggregateOutputType | null
  }

  type GetVoteGroupByPayload<T extends VoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoteGroupByOutputType[P]>
            : GetScalarType<T[P], VoteGroupByOutputType[P]>
        }
      >
    >


  export type VoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    photoId?: boolean
    contestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | UserDefaultArgs<ExtArgs>
    photo?: boolean | ContestPhotoDefaultArgs<ExtArgs>
    contest?: boolean | ContestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>



  export type VoteSelectScalar = {
    id?: boolean
    providerId?: boolean
    photoId?: boolean
    contestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "photoId" | "contestId" | "createdAt" | "updatedAt", ExtArgs["result"]["vote"]>
  export type VoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | UserDefaultArgs<ExtArgs>
    photo?: boolean | ContestPhotoDefaultArgs<ExtArgs>
    contest?: boolean | ContestDefaultArgs<ExtArgs>
  }

  export type $VotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vote"
    objects: {
      provider: Prisma.$UserPayload<ExtArgs>
      photo: Prisma.$ContestPhotoPayload<ExtArgs>
      contest: Prisma.$ContestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerId: string
      photoId: string
      contestId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vote"]>
    composites: {}
  }

  type VoteGetPayload<S extends boolean | null | undefined | VoteDefaultArgs> = $Result.GetResult<Prisma.$VotePayload, S>

  type VoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoteCountAggregateInputType | true
    }

  export interface VoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vote'], meta: { name: 'Vote' } }
    /**
     * Find zero or one Vote that matches the filter.
     * @param {VoteFindUniqueArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoteFindUniqueArgs>(args: SelectSubset<T, VoteFindUniqueArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoteFindUniqueOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoteFindUniqueOrThrowArgs>(args: SelectSubset<T, VoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoteFindFirstArgs>(args?: SelectSubset<T, VoteFindFirstArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoteFindFirstOrThrowArgs>(args?: SelectSubset<T, VoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Votes
     * const votes = await prisma.vote.findMany()
     * 
     * // Get first 10 Votes
     * const votes = await prisma.vote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voteWithIdOnly = await prisma.vote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoteFindManyArgs>(args?: SelectSubset<T, VoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vote.
     * @param {VoteCreateArgs} args - Arguments to create a Vote.
     * @example
     * // Create one Vote
     * const Vote = await prisma.vote.create({
     *   data: {
     *     // ... data to create a Vote
     *   }
     * })
     * 
     */
    create<T extends VoteCreateArgs>(args: SelectSubset<T, VoteCreateArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Votes.
     * @param {VoteCreateManyArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const vote = await prisma.vote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoteCreateManyArgs>(args?: SelectSubset<T, VoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vote.
     * @param {VoteDeleteArgs} args - Arguments to delete one Vote.
     * @example
     * // Delete one Vote
     * const Vote = await prisma.vote.delete({
     *   where: {
     *     // ... filter to delete one Vote
     *   }
     * })
     * 
     */
    delete<T extends VoteDeleteArgs>(args: SelectSubset<T, VoteDeleteArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vote.
     * @param {VoteUpdateArgs} args - Arguments to update one Vote.
     * @example
     * // Update one Vote
     * const vote = await prisma.vote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoteUpdateArgs>(args: SelectSubset<T, VoteUpdateArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Votes.
     * @param {VoteDeleteManyArgs} args - Arguments to filter Votes to delete.
     * @example
     * // Delete a few Votes
     * const { count } = await prisma.vote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoteDeleteManyArgs>(args?: SelectSubset<T, VoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Votes
     * const vote = await prisma.vote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoteUpdateManyArgs>(args: SelectSubset<T, VoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vote.
     * @param {VoteUpsertArgs} args - Arguments to update or create a Vote.
     * @example
     * // Update or create a Vote
     * const vote = await prisma.vote.upsert({
     *   create: {
     *     // ... data to create a Vote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vote we want to update
     *   }
     * })
     */
    upsert<T extends VoteUpsertArgs>(args: SelectSubset<T, VoteUpsertArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Votes that matches the filter.
     * @param {VoteFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const vote = await prisma.vote.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: VoteFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Vote.
     * @param {VoteAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const vote = await prisma.vote.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: VoteAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteCountArgs} args - Arguments to filter Votes to count.
     * @example
     * // Count the number of Votes
     * const count = await prisma.vote.count({
     *   where: {
     *     // ... the filter for the Votes we want to count
     *   }
     * })
    **/
    count<T extends VoteCountArgs>(
      args?: Subset<T, VoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoteAggregateArgs>(args: Subset<T, VoteAggregateArgs>): Prisma.PrismaPromise<GetVoteAggregateType<T>>

    /**
     * Group by Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoteGroupByArgs['orderBy'] }
        : { orderBy?: VoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vote model
   */
  readonly fields: VoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    photo<T extends ContestPhotoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestPhotoDefaultArgs<ExtArgs>>): Prisma__ContestPhotoClient<$Result.GetResult<Prisma.$ContestPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contest<T extends ContestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContestDefaultArgs<ExtArgs>>): Prisma__ContestClient<$Result.GetResult<Prisma.$ContestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vote model
   */
  interface VoteFieldRefs {
    readonly id: FieldRef<"Vote", 'String'>
    readonly providerId: FieldRef<"Vote", 'String'>
    readonly photoId: FieldRef<"Vote", 'String'>
    readonly contestId: FieldRef<"Vote", 'String'>
    readonly createdAt: FieldRef<"Vote", 'DateTime'>
    readonly updatedAt: FieldRef<"Vote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vote findUnique
   */
  export type VoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote findUniqueOrThrow
   */
  export type VoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote findFirst
   */
  export type VoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Votes.
     */
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote findFirstOrThrow
   */
  export type VoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Votes.
     */
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote findMany
   */
  export type VoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Votes to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote create
   */
  export type VoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Vote.
     */
    data: XOR<VoteCreateInput, VoteUncheckedCreateInput>
  }

  /**
   * Vote createMany
   */
  export type VoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Votes.
     */
    data: VoteCreateManyInput | VoteCreateManyInput[]
  }

  /**
   * Vote update
   */
  export type VoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Vote.
     */
    data: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>
    /**
     * Choose, which Vote to update.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote updateMany
   */
  export type VoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Votes.
     */
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyInput>
    /**
     * Filter which Votes to update
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to update.
     */
    limit?: number
  }

  /**
   * Vote upsert
   */
  export type VoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Vote to update in case it exists.
     */
    where: VoteWhereUniqueInput
    /**
     * In case the Vote found by the `where` argument doesn't exist, create a new Vote with this data.
     */
    create: XOR<VoteCreateInput, VoteUncheckedCreateInput>
    /**
     * In case the Vote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>
  }

  /**
   * Vote delete
   */
  export type VoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter which Vote to delete.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote deleteMany
   */
  export type VoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Votes to delete
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to delete.
     */
    limit?: number
  }

  /**
   * Vote findRaw
   */
  export type VoteFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Vote aggregateRaw
   */
  export type VoteAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Vote without action
   */
  export type VoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const ContestScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    banner: 'banner',
    status: 'status',
    maxUploads: 'maxUploads',
    isMoneyContest: 'isMoneyContest',
    maxPrize: 'maxPrize',
    minPrize: 'minPrize',
    startDate: 'startDate',
    endDate: 'endDate',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContestScalarFieldEnum = (typeof ContestScalarFieldEnum)[keyof typeof ContestScalarFieldEnum]


  export const ContestRuleScalarFieldEnum: {
    id: 'id',
    icon: 'icon',
    name: 'name',
    description: 'description',
    contestId: 'contestId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContestRuleScalarFieldEnum = (typeof ContestRuleScalarFieldEnum)[keyof typeof ContestRuleScalarFieldEnum]


  export const RecurringContestDataScalarFieldEnum: {
    id: 'id',
    constestId: 'constestId',
    lastRunAt: 'lastRunAt',
    nextRunAt: 'nextRunAt'
  };

  export type RecurringContestDataScalarFieldEnum = (typeof RecurringContestDataScalarFieldEnum)[keyof typeof RecurringContestDataScalarFieldEnum]


  export const RecurringContestScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    title: 'title',
    description: 'description',
    banner: 'banner',
    maxUploads: 'maxUploads',
    isMoneyContest: 'isMoneyContest',
    maxPrize: 'maxPrize',
    minPrize: 'minPrize',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecurringContestScalarFieldEnum = (typeof RecurringContestScalarFieldEnum)[keyof typeof RecurringContestScalarFieldEnum]


  export const ContestPhotoScalarFieldEnum: {
    id: 'id',
    title: 'title',
    contestId: 'contestId',
    participantId: 'participantId',
    photoId: 'photoId',
    rank: 'rank',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContestPhotoScalarFieldEnum = (typeof ContestPhotoScalarFieldEnum)[keyof typeof ContestPhotoScalarFieldEnum]


  export const ContestWinnerScalarFieldEnum: {
    id: 'id',
    participantId: 'participantId',
    contestId: 'contestId',
    contestPhotoId: 'contestPhotoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContestWinnerScalarFieldEnum = (typeof ContestWinnerScalarFieldEnum)[keyof typeof ContestWinnerScalarFieldEnum]


  export const ContestParticipantScalarFieldEnum: {
    id: 'id',
    status: 'status',
    contestId: 'contestId',
    userId: 'userId',
    level: 'level',
    rank: 'rank',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContestParticipantScalarFieldEnum = (typeof ContestParticipantScalarFieldEnum)[keyof typeof ContestParticipantScalarFieldEnum]


  export const ContestPrizeScalarFieldEnum: {
    id: 'id',
    category: 'category',
    trades: 'trades',
    charges: 'charges',
    keys: 'keys',
    contestId: 'contestId'
  };

  export type ContestPrizeScalarFieldEnum = (typeof ContestPrizeScalarFieldEnum)[keyof typeof ContestPrizeScalarFieldEnum]


  export const ContestAchievementScalarFieldEnum: {
    id: 'id',
    category: 'category',
    photoId: 'photoId',
    participantId: 'participantId',
    contestId: 'contestId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContestAchievementScalarFieldEnum = (typeof ContestAchievementScalarFieldEnum)[keyof typeof ContestAchievementScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    level: 'level',
    language: 'language',
    country: 'country',
    description: 'description',
    accessibility: 'accessibility',
    badge: 'badge',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    status: 'status',
    teamId: 'teamId',
    memberId: 'memberId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    cover: 'cover',
    avatar: 'avatar',
    socialId: 'socialId',
    socialProvider: 'socialProvider',
    firstName: 'firstName',
    lastName: 'lastName',
    fullName: 'fullName',
    username: 'username',
    phone: 'phone',
    email: 'email',
    location: 'location',
    level: 'level',
    password: 'password',
    role: 'role',
    accessToken: 'accessToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserPhotoScalarFieldEnum: {
    id: 'id',
    url: 'url',
    userId: 'userId',
    views: 'views',
    labels: 'labels',
    title: 'title',
    description: 'description',
    adult: 'adult',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPhotoScalarFieldEnum = (typeof UserPhotoScalarFieldEnum)[keyof typeof UserPhotoScalarFieldEnum]


  export const LikeScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    photoId: 'photoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LikeScalarFieldEnum = (typeof LikeScalarFieldEnum)[keyof typeof LikeScalarFieldEnum]


  export const OtpScalarFieldEnum: {
    id: 'id',
    code: 'code',
    expires_in: 'expires_in',
    userId: 'userId',
    otpStatus: 'otpStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expiresAt: 'expiresAt'
  };

  export type OtpScalarFieldEnum = (typeof OtpScalarFieldEnum)[keyof typeof OtpScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    text: 'text',
    providerId: 'providerId',
    receiverId: 'receiverId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const FollowScalarFieldEnum: {
    id: 'id',
    followerId: 'followerId',
    followingId: 'followingId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FollowScalarFieldEnum = (typeof FollowScalarFieldEnum)[keyof typeof FollowScalarFieldEnum]


  export const VoteScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    photoId: 'photoId',
    contestId: 'contestId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VoteScalarFieldEnum = (typeof VoteScalarFieldEnum)[keyof typeof VoteScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'ContestStatus'
   */
  export type EnumContestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContestStatus'>
    


  /**
   * Reference to a field of type 'ContestStatus[]'
   */
  export type ListEnumContestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContestStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ContestParticipantStatus'
   */
  export type EnumContestParticipantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContestParticipantStatus'>
    


  /**
   * Reference to a field of type 'ContestParticipantStatus[]'
   */
  export type ListEnumContestParticipantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContestParticipantStatus[]'>
    


  /**
   * Reference to a field of type 'ContestLevel'
   */
  export type EnumContestLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContestLevel'>
    


  /**
   * Reference to a field of type 'ContestLevel[]'
   */
  export type ListEnumContestLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContestLevel[]'>
    


  /**
   * Reference to a field of type 'PrizeType'
   */
  export type EnumPrizeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrizeType'>
    


  /**
   * Reference to a field of type 'PrizeType[]'
   */
  export type ListEnumPrizeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrizeType[]'>
    


  /**
   * Reference to a field of type 'TeamAccessibility'
   */
  export type EnumTeamAccessibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamAccessibility'>
    


  /**
   * Reference to a field of type 'TeamAccessibility[]'
   */
  export type ListEnumTeamAccessibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamAccessibility[]'>
    


  /**
   * Reference to a field of type 'TeamMemberStatus'
   */
  export type EnumTeamMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamMemberStatus'>
    


  /**
   * Reference to a field of type 'TeamMemberStatus[]'
   */
  export type ListEnumTeamMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamMemberStatus[]'>
    


  /**
   * Reference to a field of type 'UserLevel'
   */
  export type EnumUserLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserLevel'>
    


  /**
   * Reference to a field of type 'UserLevel[]'
   */
  export type ListEnumUserLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserLevel[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'OtpStatus'
   */
  export type EnumOtpStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OtpStatus'>
    


  /**
   * Reference to a field of type 'OtpStatus[]'
   */
  export type ListEnumOtpStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OtpStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'RecurringType'
   */
  export type EnumRecurringTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurringType'>
    


  /**
   * Reference to a field of type 'RecurringType[]'
   */
  export type ListEnumRecurringTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurringType[]'>
    
  /**
   * Deep Input Types
   */


  export type ContestWhereInput = {
    AND?: ContestWhereInput | ContestWhereInput[]
    OR?: ContestWhereInput[]
    NOT?: ContestWhereInput | ContestWhereInput[]
    id?: StringFilter<"Contest"> | string
    title?: StringFilter<"Contest"> | string
    description?: StringFilter<"Contest"> | string
    banner?: StringNullableFilter<"Contest"> | string | null
    status?: EnumContestStatusFilter<"Contest"> | $Enums.ContestStatus
    maxUploads?: IntNullableFilter<"Contest"> | number | null
    isMoneyContest?: BoolFilter<"Contest"> | boolean
    maxPrize?: IntNullableFilter<"Contest"> | number | null
    minPrize?: IntNullableFilter<"Contest"> | number | null
    startDate?: DateTimeFilter<"Contest"> | Date | string
    endDate?: DateTimeFilter<"Contest"> | Date | string
    creatorId?: StringFilter<"Contest"> | string
    createdAt?: DateTimeFilter<"Contest"> | Date | string
    updatedAt?: DateTimeFilter<"Contest"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    participants?: ContestParticipantListRelationFilter
    votes?: VoteListRelationFilter
    contestRules?: ContestRuleListRelationFilter
    contestPrizes?: ContestPrizeListRelationFilter
    recurringData?: XOR<RecurringContestDataNullableScalarRelationFilter, RecurringContestDataWhereInput> | null
  }

  export type ContestOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    status?: SortOrder
    maxUploads?: SortOrder
    isMoneyContest?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    participants?: ContestParticipantOrderByRelationAggregateInput
    votes?: VoteOrderByRelationAggregateInput
    contestRules?: ContestRuleOrderByRelationAggregateInput
    contestPrizes?: ContestPrizeOrderByRelationAggregateInput
    recurringData?: RecurringContestDataOrderByWithRelationInput
  }

  export type ContestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContestWhereInput | ContestWhereInput[]
    OR?: ContestWhereInput[]
    NOT?: ContestWhereInput | ContestWhereInput[]
    title?: StringFilter<"Contest"> | string
    description?: StringFilter<"Contest"> | string
    banner?: StringNullableFilter<"Contest"> | string | null
    status?: EnumContestStatusFilter<"Contest"> | $Enums.ContestStatus
    maxUploads?: IntNullableFilter<"Contest"> | number | null
    isMoneyContest?: BoolFilter<"Contest"> | boolean
    maxPrize?: IntNullableFilter<"Contest"> | number | null
    minPrize?: IntNullableFilter<"Contest"> | number | null
    startDate?: DateTimeFilter<"Contest"> | Date | string
    endDate?: DateTimeFilter<"Contest"> | Date | string
    creatorId?: StringFilter<"Contest"> | string
    createdAt?: DateTimeFilter<"Contest"> | Date | string
    updatedAt?: DateTimeFilter<"Contest"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    participants?: ContestParticipantListRelationFilter
    votes?: VoteListRelationFilter
    contestRules?: ContestRuleListRelationFilter
    contestPrizes?: ContestPrizeListRelationFilter
    recurringData?: XOR<RecurringContestDataNullableScalarRelationFilter, RecurringContestDataWhereInput> | null
  }, "id">

  export type ContestOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    status?: SortOrder
    maxUploads?: SortOrder
    isMoneyContest?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContestCountOrderByAggregateInput
    _avg?: ContestAvgOrderByAggregateInput
    _max?: ContestMaxOrderByAggregateInput
    _min?: ContestMinOrderByAggregateInput
    _sum?: ContestSumOrderByAggregateInput
  }

  export type ContestScalarWhereWithAggregatesInput = {
    AND?: ContestScalarWhereWithAggregatesInput | ContestScalarWhereWithAggregatesInput[]
    OR?: ContestScalarWhereWithAggregatesInput[]
    NOT?: ContestScalarWhereWithAggregatesInput | ContestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contest"> | string
    title?: StringWithAggregatesFilter<"Contest"> | string
    description?: StringWithAggregatesFilter<"Contest"> | string
    banner?: StringNullableWithAggregatesFilter<"Contest"> | string | null
    status?: EnumContestStatusWithAggregatesFilter<"Contest"> | $Enums.ContestStatus
    maxUploads?: IntNullableWithAggregatesFilter<"Contest"> | number | null
    isMoneyContest?: BoolWithAggregatesFilter<"Contest"> | boolean
    maxPrize?: IntNullableWithAggregatesFilter<"Contest"> | number | null
    minPrize?: IntNullableWithAggregatesFilter<"Contest"> | number | null
    startDate?: DateTimeWithAggregatesFilter<"Contest"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Contest"> | Date | string
    creatorId?: StringWithAggregatesFilter<"Contest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Contest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contest"> | Date | string
  }

  export type ContestRuleWhereInput = {
    AND?: ContestRuleWhereInput | ContestRuleWhereInput[]
    OR?: ContestRuleWhereInput[]
    NOT?: ContestRuleWhereInput | ContestRuleWhereInput[]
    id?: StringFilter<"ContestRule"> | string
    icon?: StringNullableFilter<"ContestRule"> | string | null
    name?: StringFilter<"ContestRule"> | string
    description?: StringFilter<"ContestRule"> | string
    contestId?: StringFilter<"ContestRule"> | string
    createdAt?: DateTimeFilter<"ContestRule"> | Date | string
    updatedAt?: DateTimeFilter<"ContestRule"> | Date | string
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
  }

  export type ContestRuleOrderByWithRelationInput = {
    id?: SortOrder
    icon?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contest?: ContestOrderByWithRelationInput
  }

  export type ContestRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContestRuleWhereInput | ContestRuleWhereInput[]
    OR?: ContestRuleWhereInput[]
    NOT?: ContestRuleWhereInput | ContestRuleWhereInput[]
    icon?: StringNullableFilter<"ContestRule"> | string | null
    name?: StringFilter<"ContestRule"> | string
    description?: StringFilter<"ContestRule"> | string
    contestId?: StringFilter<"ContestRule"> | string
    createdAt?: DateTimeFilter<"ContestRule"> | Date | string
    updatedAt?: DateTimeFilter<"ContestRule"> | Date | string
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
  }, "id">

  export type ContestRuleOrderByWithAggregationInput = {
    id?: SortOrder
    icon?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContestRuleCountOrderByAggregateInput
    _max?: ContestRuleMaxOrderByAggregateInput
    _min?: ContestRuleMinOrderByAggregateInput
  }

  export type ContestRuleScalarWhereWithAggregatesInput = {
    AND?: ContestRuleScalarWhereWithAggregatesInput | ContestRuleScalarWhereWithAggregatesInput[]
    OR?: ContestRuleScalarWhereWithAggregatesInput[]
    NOT?: ContestRuleScalarWhereWithAggregatesInput | ContestRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContestRule"> | string
    icon?: StringNullableWithAggregatesFilter<"ContestRule"> | string | null
    name?: StringWithAggregatesFilter<"ContestRule"> | string
    description?: StringWithAggregatesFilter<"ContestRule"> | string
    contestId?: StringWithAggregatesFilter<"ContestRule"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContestRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContestRule"> | Date | string
  }

  export type RecurringContestDataWhereInput = {
    AND?: RecurringContestDataWhereInput | RecurringContestDataWhereInput[]
    OR?: RecurringContestDataWhereInput[]
    NOT?: RecurringContestDataWhereInput | RecurringContestDataWhereInput[]
    id?: StringFilter<"RecurringContestData"> | string
    constestId?: StringFilter<"RecurringContestData"> | string
    lastRunAt?: DateTimeNullableFilter<"RecurringContestData"> | Date | string | null
    nextRunAt?: DateTimeFilter<"RecurringContestData"> | Date | string
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
  }

  export type RecurringContestDataOrderByWithRelationInput = {
    id?: SortOrder
    constestId?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
    contest?: ContestOrderByWithRelationInput
  }

  export type RecurringContestDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    constestId?: string
    AND?: RecurringContestDataWhereInput | RecurringContestDataWhereInput[]
    OR?: RecurringContestDataWhereInput[]
    NOT?: RecurringContestDataWhereInput | RecurringContestDataWhereInput[]
    lastRunAt?: DateTimeNullableFilter<"RecurringContestData"> | Date | string | null
    nextRunAt?: DateTimeFilter<"RecurringContestData"> | Date | string
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
  }, "id" | "constestId">

  export type RecurringContestDataOrderByWithAggregationInput = {
    id?: SortOrder
    constestId?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
    _count?: RecurringContestDataCountOrderByAggregateInput
    _max?: RecurringContestDataMaxOrderByAggregateInput
    _min?: RecurringContestDataMinOrderByAggregateInput
  }

  export type RecurringContestDataScalarWhereWithAggregatesInput = {
    AND?: RecurringContestDataScalarWhereWithAggregatesInput | RecurringContestDataScalarWhereWithAggregatesInput[]
    OR?: RecurringContestDataScalarWhereWithAggregatesInput[]
    NOT?: RecurringContestDataScalarWhereWithAggregatesInput | RecurringContestDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecurringContestData"> | string
    constestId?: StringWithAggregatesFilter<"RecurringContestData"> | string
    lastRunAt?: DateTimeNullableWithAggregatesFilter<"RecurringContestData"> | Date | string | null
    nextRunAt?: DateTimeWithAggregatesFilter<"RecurringContestData"> | Date | string
  }

  export type RecurringContestWhereInput = {
    AND?: RecurringContestWhereInput | RecurringContestWhereInput[]
    OR?: RecurringContestWhereInput[]
    NOT?: RecurringContestWhereInput | RecurringContestWhereInput[]
    id?: StringFilter<"RecurringContest"> | string
    creatorId?: StringFilter<"RecurringContest"> | string
    title?: StringFilter<"RecurringContest"> | string
    description?: StringFilter<"RecurringContest"> | string
    banner?: StringNullableFilter<"RecurringContest"> | string | null
    maxUploads?: IntNullableFilter<"RecurringContest"> | number | null
    isMoneyContest?: BoolFilter<"RecurringContest"> | boolean
    maxPrize?: IntNullableFilter<"RecurringContest"> | number | null
    minPrize?: IntNullableFilter<"RecurringContest"> | number | null
    recurringData?: XOR<RecurringDataCompositeFilter, RecurringDataObjectEqualityInput>
    createdAt?: DateTimeFilter<"RecurringContest"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringContest"> | Date | string
  }

  export type RecurringContestOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    maxUploads?: SortOrder
    isMoneyContest?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    recurringData?: RecurringDataOrderByInput
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringContestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecurringContestWhereInput | RecurringContestWhereInput[]
    OR?: RecurringContestWhereInput[]
    NOT?: RecurringContestWhereInput | RecurringContestWhereInput[]
    creatorId?: StringFilter<"RecurringContest"> | string
    title?: StringFilter<"RecurringContest"> | string
    description?: StringFilter<"RecurringContest"> | string
    banner?: StringNullableFilter<"RecurringContest"> | string | null
    maxUploads?: IntNullableFilter<"RecurringContest"> | number | null
    isMoneyContest?: BoolFilter<"RecurringContest"> | boolean
    maxPrize?: IntNullableFilter<"RecurringContest"> | number | null
    minPrize?: IntNullableFilter<"RecurringContest"> | number | null
    recurringData?: XOR<RecurringDataCompositeFilter, RecurringDataObjectEqualityInput>
    createdAt?: DateTimeFilter<"RecurringContest"> | Date | string
    updatedAt?: DateTimeFilter<"RecurringContest"> | Date | string
  }, "id">

  export type RecurringContestOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    maxUploads?: SortOrder
    isMoneyContest?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecurringContestCountOrderByAggregateInput
    _avg?: RecurringContestAvgOrderByAggregateInput
    _max?: RecurringContestMaxOrderByAggregateInput
    _min?: RecurringContestMinOrderByAggregateInput
    _sum?: RecurringContestSumOrderByAggregateInput
  }

  export type RecurringContestScalarWhereWithAggregatesInput = {
    AND?: RecurringContestScalarWhereWithAggregatesInput | RecurringContestScalarWhereWithAggregatesInput[]
    OR?: RecurringContestScalarWhereWithAggregatesInput[]
    NOT?: RecurringContestScalarWhereWithAggregatesInput | RecurringContestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecurringContest"> | string
    creatorId?: StringWithAggregatesFilter<"RecurringContest"> | string
    title?: StringWithAggregatesFilter<"RecurringContest"> | string
    description?: StringWithAggregatesFilter<"RecurringContest"> | string
    banner?: StringNullableWithAggregatesFilter<"RecurringContest"> | string | null
    maxUploads?: IntNullableWithAggregatesFilter<"RecurringContest"> | number | null
    isMoneyContest?: BoolWithAggregatesFilter<"RecurringContest"> | boolean
    maxPrize?: IntNullableWithAggregatesFilter<"RecurringContest"> | number | null
    minPrize?: IntNullableWithAggregatesFilter<"RecurringContest"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"RecurringContest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RecurringContest"> | Date | string
  }

  export type ContestPhotoWhereInput = {
    AND?: ContestPhotoWhereInput | ContestPhotoWhereInput[]
    OR?: ContestPhotoWhereInput[]
    NOT?: ContestPhotoWhereInput | ContestPhotoWhereInput[]
    id?: StringFilter<"ContestPhoto"> | string
    title?: StringNullableFilter<"ContestPhoto"> | string | null
    contestId?: StringFilter<"ContestPhoto"> | string
    participantId?: StringFilter<"ContestPhoto"> | string
    photoId?: StringFilter<"ContestPhoto"> | string
    rank?: IntNullableFilter<"ContestPhoto"> | number | null
    createdAt?: DateTimeFilter<"ContestPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"ContestPhoto"> | Date | string
    participant?: XOR<ContestParticipantScalarRelationFilter, ContestParticipantWhereInput>
    votes?: VoteListRelationFilter
    photo?: XOR<UserPhotoScalarRelationFilter, UserPhotoWhereInput>
    comments?: CommentListRelationFilter
    achievements?: ContestAchievementListRelationFilter
    ContestWinner?: ContestWinnerListRelationFilter
  }

  export type ContestPhotoOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    contestId?: SortOrder
    participantId?: SortOrder
    photoId?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    participant?: ContestParticipantOrderByWithRelationInput
    votes?: VoteOrderByRelationAggregateInput
    photo?: UserPhotoOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    achievements?: ContestAchievementOrderByRelationAggregateInput
    ContestWinner?: ContestWinnerOrderByRelationAggregateInput
  }

  export type ContestPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContestPhotoWhereInput | ContestPhotoWhereInput[]
    OR?: ContestPhotoWhereInput[]
    NOT?: ContestPhotoWhereInput | ContestPhotoWhereInput[]
    title?: StringNullableFilter<"ContestPhoto"> | string | null
    contestId?: StringFilter<"ContestPhoto"> | string
    participantId?: StringFilter<"ContestPhoto"> | string
    photoId?: StringFilter<"ContestPhoto"> | string
    rank?: IntNullableFilter<"ContestPhoto"> | number | null
    createdAt?: DateTimeFilter<"ContestPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"ContestPhoto"> | Date | string
    participant?: XOR<ContestParticipantScalarRelationFilter, ContestParticipantWhereInput>
    votes?: VoteListRelationFilter
    photo?: XOR<UserPhotoScalarRelationFilter, UserPhotoWhereInput>
    comments?: CommentListRelationFilter
    achievements?: ContestAchievementListRelationFilter
    ContestWinner?: ContestWinnerListRelationFilter
  }, "id">

  export type ContestPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    contestId?: SortOrder
    participantId?: SortOrder
    photoId?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContestPhotoCountOrderByAggregateInput
    _avg?: ContestPhotoAvgOrderByAggregateInput
    _max?: ContestPhotoMaxOrderByAggregateInput
    _min?: ContestPhotoMinOrderByAggregateInput
    _sum?: ContestPhotoSumOrderByAggregateInput
  }

  export type ContestPhotoScalarWhereWithAggregatesInput = {
    AND?: ContestPhotoScalarWhereWithAggregatesInput | ContestPhotoScalarWhereWithAggregatesInput[]
    OR?: ContestPhotoScalarWhereWithAggregatesInput[]
    NOT?: ContestPhotoScalarWhereWithAggregatesInput | ContestPhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContestPhoto"> | string
    title?: StringNullableWithAggregatesFilter<"ContestPhoto"> | string | null
    contestId?: StringWithAggregatesFilter<"ContestPhoto"> | string
    participantId?: StringWithAggregatesFilter<"ContestPhoto"> | string
    photoId?: StringWithAggregatesFilter<"ContestPhoto"> | string
    rank?: IntNullableWithAggregatesFilter<"ContestPhoto"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ContestPhoto"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContestPhoto"> | Date | string
  }

  export type ContestWinnerWhereInput = {
    AND?: ContestWinnerWhereInput | ContestWinnerWhereInput[]
    OR?: ContestWinnerWhereInput[]
    NOT?: ContestWinnerWhereInput | ContestWinnerWhereInput[]
    id?: StringFilter<"ContestWinner"> | string
    participantId?: StringFilter<"ContestWinner"> | string
    contestId?: StringFilter<"ContestWinner"> | string
    contestPhotoId?: StringFilter<"ContestWinner"> | string
    createdAt?: DateTimeFilter<"ContestWinner"> | Date | string
    updatedAt?: DateTimeFilter<"ContestWinner"> | Date | string
    participant?: XOR<ContestParticipantScalarRelationFilter, ContestParticipantWhereInput>
    photo?: XOR<ContestPhotoScalarRelationFilter, ContestPhotoWhereInput>
  }

  export type ContestWinnerOrderByWithRelationInput = {
    id?: SortOrder
    participantId?: SortOrder
    contestId?: SortOrder
    contestPhotoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    participant?: ContestParticipantOrderByWithRelationInput
    photo?: ContestPhotoOrderByWithRelationInput
  }

  export type ContestWinnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContestWinnerWhereInput | ContestWinnerWhereInput[]
    OR?: ContestWinnerWhereInput[]
    NOT?: ContestWinnerWhereInput | ContestWinnerWhereInput[]
    participantId?: StringFilter<"ContestWinner"> | string
    contestId?: StringFilter<"ContestWinner"> | string
    contestPhotoId?: StringFilter<"ContestWinner"> | string
    createdAt?: DateTimeFilter<"ContestWinner"> | Date | string
    updatedAt?: DateTimeFilter<"ContestWinner"> | Date | string
    participant?: XOR<ContestParticipantScalarRelationFilter, ContestParticipantWhereInput>
    photo?: XOR<ContestPhotoScalarRelationFilter, ContestPhotoWhereInput>
  }, "id">

  export type ContestWinnerOrderByWithAggregationInput = {
    id?: SortOrder
    participantId?: SortOrder
    contestId?: SortOrder
    contestPhotoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContestWinnerCountOrderByAggregateInput
    _max?: ContestWinnerMaxOrderByAggregateInput
    _min?: ContestWinnerMinOrderByAggregateInput
  }

  export type ContestWinnerScalarWhereWithAggregatesInput = {
    AND?: ContestWinnerScalarWhereWithAggregatesInput | ContestWinnerScalarWhereWithAggregatesInput[]
    OR?: ContestWinnerScalarWhereWithAggregatesInput[]
    NOT?: ContestWinnerScalarWhereWithAggregatesInput | ContestWinnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContestWinner"> | string
    participantId?: StringWithAggregatesFilter<"ContestWinner"> | string
    contestId?: StringWithAggregatesFilter<"ContestWinner"> | string
    contestPhotoId?: StringWithAggregatesFilter<"ContestWinner"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContestWinner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContestWinner"> | Date | string
  }

  export type ContestParticipantWhereInput = {
    AND?: ContestParticipantWhereInput | ContestParticipantWhereInput[]
    OR?: ContestParticipantWhereInput[]
    NOT?: ContestParticipantWhereInput | ContestParticipantWhereInput[]
    id?: StringFilter<"ContestParticipant"> | string
    status?: EnumContestParticipantStatusFilter<"ContestParticipant"> | $Enums.ContestParticipantStatus
    contestId?: StringFilter<"ContestParticipant"> | string
    userId?: StringFilter<"ContestParticipant"> | string
    level?: EnumContestLevelFilter<"ContestParticipant"> | $Enums.ContestLevel
    rank?: IntNullableFilter<"ContestParticipant"> | number | null
    createdAt?: DateTimeFilter<"ContestParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"ContestParticipant"> | Date | string
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    photos?: ContestPhotoListRelationFilter
    ContestWinner?: ContestWinnerListRelationFilter
    contestAchievement?: ContestAchievementListRelationFilter
  }

  export type ContestParticipantOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    contestId?: SortOrder
    userId?: SortOrder
    level?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contest?: ContestOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    photos?: ContestPhotoOrderByRelationAggregateInput
    ContestWinner?: ContestWinnerOrderByRelationAggregateInput
    contestAchievement?: ContestAchievementOrderByRelationAggregateInput
  }

  export type ContestParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contestId_userId?: ContestParticipantContestIdUserIdCompoundUniqueInput
    AND?: ContestParticipantWhereInput | ContestParticipantWhereInput[]
    OR?: ContestParticipantWhereInput[]
    NOT?: ContestParticipantWhereInput | ContestParticipantWhereInput[]
    status?: EnumContestParticipantStatusFilter<"ContestParticipant"> | $Enums.ContestParticipantStatus
    contestId?: StringFilter<"ContestParticipant"> | string
    userId?: StringFilter<"ContestParticipant"> | string
    level?: EnumContestLevelFilter<"ContestParticipant"> | $Enums.ContestLevel
    rank?: IntNullableFilter<"ContestParticipant"> | number | null
    createdAt?: DateTimeFilter<"ContestParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"ContestParticipant"> | Date | string
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    photos?: ContestPhotoListRelationFilter
    ContestWinner?: ContestWinnerListRelationFilter
    contestAchievement?: ContestAchievementListRelationFilter
  }, "id" | "contestId_userId">

  export type ContestParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    contestId?: SortOrder
    userId?: SortOrder
    level?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContestParticipantCountOrderByAggregateInput
    _avg?: ContestParticipantAvgOrderByAggregateInput
    _max?: ContestParticipantMaxOrderByAggregateInput
    _min?: ContestParticipantMinOrderByAggregateInput
    _sum?: ContestParticipantSumOrderByAggregateInput
  }

  export type ContestParticipantScalarWhereWithAggregatesInput = {
    AND?: ContestParticipantScalarWhereWithAggregatesInput | ContestParticipantScalarWhereWithAggregatesInput[]
    OR?: ContestParticipantScalarWhereWithAggregatesInput[]
    NOT?: ContestParticipantScalarWhereWithAggregatesInput | ContestParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContestParticipant"> | string
    status?: EnumContestParticipantStatusWithAggregatesFilter<"ContestParticipant"> | $Enums.ContestParticipantStatus
    contestId?: StringWithAggregatesFilter<"ContestParticipant"> | string
    userId?: StringWithAggregatesFilter<"ContestParticipant"> | string
    level?: EnumContestLevelWithAggregatesFilter<"ContestParticipant"> | $Enums.ContestLevel
    rank?: IntNullableWithAggregatesFilter<"ContestParticipant"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ContestParticipant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContestParticipant"> | Date | string
  }

  export type ContestPrizeWhereInput = {
    AND?: ContestPrizeWhereInput | ContestPrizeWhereInput[]
    OR?: ContestPrizeWhereInput[]
    NOT?: ContestPrizeWhereInput | ContestPrizeWhereInput[]
    id?: StringFilter<"ContestPrize"> | string
    category?: EnumPrizeTypeFilter<"ContestPrize"> | $Enums.PrizeType
    trades?: IntFilter<"ContestPrize"> | number
    charges?: IntFilter<"ContestPrize"> | number
    keys?: IntFilter<"ContestPrize"> | number
    contestId?: StringFilter<"ContestPrize"> | string
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
  }

  export type ContestPrizeOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    trades?: SortOrder
    charges?: SortOrder
    keys?: SortOrder
    contestId?: SortOrder
    contest?: ContestOrderByWithRelationInput
  }

  export type ContestPrizeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContestPrizeWhereInput | ContestPrizeWhereInput[]
    OR?: ContestPrizeWhereInput[]
    NOT?: ContestPrizeWhereInput | ContestPrizeWhereInput[]
    category?: EnumPrizeTypeFilter<"ContestPrize"> | $Enums.PrizeType
    trades?: IntFilter<"ContestPrize"> | number
    charges?: IntFilter<"ContestPrize"> | number
    keys?: IntFilter<"ContestPrize"> | number
    contestId?: StringFilter<"ContestPrize"> | string
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
  }, "id">

  export type ContestPrizeOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    trades?: SortOrder
    charges?: SortOrder
    keys?: SortOrder
    contestId?: SortOrder
    _count?: ContestPrizeCountOrderByAggregateInput
    _avg?: ContestPrizeAvgOrderByAggregateInput
    _max?: ContestPrizeMaxOrderByAggregateInput
    _min?: ContestPrizeMinOrderByAggregateInput
    _sum?: ContestPrizeSumOrderByAggregateInput
  }

  export type ContestPrizeScalarWhereWithAggregatesInput = {
    AND?: ContestPrizeScalarWhereWithAggregatesInput | ContestPrizeScalarWhereWithAggregatesInput[]
    OR?: ContestPrizeScalarWhereWithAggregatesInput[]
    NOT?: ContestPrizeScalarWhereWithAggregatesInput | ContestPrizeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContestPrize"> | string
    category?: EnumPrizeTypeWithAggregatesFilter<"ContestPrize"> | $Enums.PrizeType
    trades?: IntWithAggregatesFilter<"ContestPrize"> | number
    charges?: IntWithAggregatesFilter<"ContestPrize"> | number
    keys?: IntWithAggregatesFilter<"ContestPrize"> | number
    contestId?: StringWithAggregatesFilter<"ContestPrize"> | string
  }

  export type ContestAchievementWhereInput = {
    AND?: ContestAchievementWhereInput | ContestAchievementWhereInput[]
    OR?: ContestAchievementWhereInput[]
    NOT?: ContestAchievementWhereInput | ContestAchievementWhereInput[]
    id?: StringFilter<"ContestAchievement"> | string
    category?: EnumPrizeTypeFilter<"ContestAchievement"> | $Enums.PrizeType
    photoId?: StringNullableFilter<"ContestAchievement"> | string | null
    participantId?: StringNullableFilter<"ContestAchievement"> | string | null
    contestId?: StringFilter<"ContestAchievement"> | string
    createdAt?: DateTimeFilter<"ContestAchievement"> | Date | string
    updatedAt?: DateTimeFilter<"ContestAchievement"> | Date | string
    photo?: XOR<ContestPhotoNullableScalarRelationFilter, ContestPhotoWhereInput> | null
    participant?: XOR<ContestParticipantNullableScalarRelationFilter, ContestParticipantWhereInput> | null
  }

  export type ContestAchievementOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    photoId?: SortOrder
    participantId?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    photo?: ContestPhotoOrderByWithRelationInput
    participant?: ContestParticipantOrderByWithRelationInput
  }

  export type ContestAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContestAchievementWhereInput | ContestAchievementWhereInput[]
    OR?: ContestAchievementWhereInput[]
    NOT?: ContestAchievementWhereInput | ContestAchievementWhereInput[]
    category?: EnumPrizeTypeFilter<"ContestAchievement"> | $Enums.PrizeType
    photoId?: StringNullableFilter<"ContestAchievement"> | string | null
    participantId?: StringNullableFilter<"ContestAchievement"> | string | null
    contestId?: StringFilter<"ContestAchievement"> | string
    createdAt?: DateTimeFilter<"ContestAchievement"> | Date | string
    updatedAt?: DateTimeFilter<"ContestAchievement"> | Date | string
    photo?: XOR<ContestPhotoNullableScalarRelationFilter, ContestPhotoWhereInput> | null
    participant?: XOR<ContestParticipantNullableScalarRelationFilter, ContestParticipantWhereInput> | null
  }, "id">

  export type ContestAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    photoId?: SortOrder
    participantId?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContestAchievementCountOrderByAggregateInput
    _max?: ContestAchievementMaxOrderByAggregateInput
    _min?: ContestAchievementMinOrderByAggregateInput
  }

  export type ContestAchievementScalarWhereWithAggregatesInput = {
    AND?: ContestAchievementScalarWhereWithAggregatesInput | ContestAchievementScalarWhereWithAggregatesInput[]
    OR?: ContestAchievementScalarWhereWithAggregatesInput[]
    NOT?: ContestAchievementScalarWhereWithAggregatesInput | ContestAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContestAchievement"> | string
    category?: EnumPrizeTypeWithAggregatesFilter<"ContestAchievement"> | $Enums.PrizeType
    photoId?: StringNullableWithAggregatesFilter<"ContestAchievement"> | string | null
    participantId?: StringNullableWithAggregatesFilter<"ContestAchievement"> | string | null
    contestId?: StringWithAggregatesFilter<"ContestAchievement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContestAchievement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContestAchievement"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    level?: StringFilter<"Team"> | string
    language?: StringFilter<"Team"> | string
    country?: StringFilter<"Team"> | string
    description?: StringFilter<"Team"> | string
    accessibility?: EnumTeamAccessibilityFilter<"Team"> | $Enums.TeamAccessibility
    badge?: StringFilter<"Team"> | string
    creatorId?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: TeamMemberListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    language?: SortOrder
    country?: SortOrder
    description?: SortOrder
    accessibility?: SortOrder
    badge?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    members?: TeamMemberOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    level?: StringFilter<"Team"> | string
    language?: StringFilter<"Team"> | string
    country?: StringFilter<"Team"> | string
    description?: StringFilter<"Team"> | string
    accessibility?: EnumTeamAccessibilityFilter<"Team"> | $Enums.TeamAccessibility
    badge?: StringFilter<"Team"> | string
    creatorId?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: TeamMemberListRelationFilter
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    language?: SortOrder
    country?: SortOrder
    description?: SortOrder
    accessibility?: SortOrder
    badge?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    level?: StringWithAggregatesFilter<"Team"> | string
    language?: StringWithAggregatesFilter<"Team"> | string
    country?: StringWithAggregatesFilter<"Team"> | string
    description?: StringWithAggregatesFilter<"Team"> | string
    accessibility?: EnumTeamAccessibilityWithAggregatesFilter<"Team"> | $Enums.TeamAccessibility
    badge?: StringWithAggregatesFilter<"Team"> | string
    creatorId?: StringWithAggregatesFilter<"Team"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    status?: EnumTeamMemberStatusFilter<"TeamMember"> | $Enums.TeamMemberStatus
    teamId?: StringFilter<"TeamMember"> | string
    memberId?: StringFilter<"TeamMember"> | string
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"TeamMember"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    member?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    teamId?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    member?: UserOrderByWithRelationInput
  }

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    memberId?: string
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    status?: EnumTeamMemberStatusFilter<"TeamMember"> | $Enums.TeamMemberStatus
    teamId?: StringFilter<"TeamMember"> | string
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"TeamMember"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    member?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "memberId">

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    teamId?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    OR?: TeamMemberScalarWhereWithAggregatesInput[]
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamMember"> | string
    status?: EnumTeamMemberStatusWithAggregatesFilter<"TeamMember"> | $Enums.TeamMemberStatus
    teamId?: StringWithAggregatesFilter<"TeamMember"> | string
    memberId?: StringWithAggregatesFilter<"TeamMember"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    cover?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    socialId?: StringNullableFilter<"User"> | string | null
    socialProvider?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    fullName?: StringNullableFilter<"User"> | string | null
    username?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    location?: StringNullableFilter<"User"> | string | null
    level?: EnumUserLevelNullableFilter<"User"> | $Enums.UserLevel | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    accessToken?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    otps?: XOR<OtpNullableScalarRelationFilter, OtpWhereInput> | null
    createdTeam?: TeamListRelationFilter
    joinedTeam?: XOR<TeamMemberNullableScalarRelationFilter, TeamMemberWhereInput> | null
    createdContests?: ContestListRelationFilter
    commentProvides?: CommentListRelationFilter
    followers?: FollowListRelationFilter
    followings?: FollowListRelationFilter
    votes?: VoteListRelationFilter
    likes?: LikeListRelationFilter
    userPhotos?: UserPhotoListRelationFilter
    ContestParticipant?: ContestParticipantListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    cover?: SortOrder
    avatar?: SortOrder
    socialId?: SortOrder
    socialProvider?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    location?: SortOrder
    level?: SortOrder
    password?: SortOrder
    role?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    otps?: OtpOrderByWithRelationInput
    createdTeam?: TeamOrderByRelationAggregateInput
    joinedTeam?: TeamMemberOrderByWithRelationInput
    createdContests?: ContestOrderByRelationAggregateInput
    commentProvides?: CommentOrderByRelationAggregateInput
    followers?: FollowOrderByRelationAggregateInput
    followings?: FollowOrderByRelationAggregateInput
    votes?: VoteOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
    userPhotos?: UserPhotoOrderByRelationAggregateInput
    ContestParticipant?: ContestParticipantOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    cover?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    socialId?: StringNullableFilter<"User"> | string | null
    socialProvider?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    fullName?: StringNullableFilter<"User"> | string | null
    username?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    location?: StringNullableFilter<"User"> | string | null
    level?: EnumUserLevelNullableFilter<"User"> | $Enums.UserLevel | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    accessToken?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    otps?: XOR<OtpNullableScalarRelationFilter, OtpWhereInput> | null
    createdTeam?: TeamListRelationFilter
    joinedTeam?: XOR<TeamMemberNullableScalarRelationFilter, TeamMemberWhereInput> | null
    createdContests?: ContestListRelationFilter
    commentProvides?: CommentListRelationFilter
    followers?: FollowListRelationFilter
    followings?: FollowListRelationFilter
    votes?: VoteListRelationFilter
    likes?: LikeListRelationFilter
    userPhotos?: UserPhotoListRelationFilter
    ContestParticipant?: ContestParticipantListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    cover?: SortOrder
    avatar?: SortOrder
    socialId?: SortOrder
    socialProvider?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    location?: SortOrder
    level?: SortOrder
    password?: SortOrder
    role?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    cover?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    socialId?: StringNullableWithAggregatesFilter<"User"> | string | null
    socialProvider?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    fullName?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    location?: StringNullableWithAggregatesFilter<"User"> | string | null
    level?: EnumUserLevelNullableWithAggregatesFilter<"User"> | $Enums.UserLevel | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    accessToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserPhotoWhereInput = {
    AND?: UserPhotoWhereInput | UserPhotoWhereInput[]
    OR?: UserPhotoWhereInput[]
    NOT?: UserPhotoWhereInput | UserPhotoWhereInput[]
    id?: StringFilter<"UserPhoto"> | string
    url?: StringFilter<"UserPhoto"> | string
    userId?: StringFilter<"UserPhoto"> | string
    states?: XOR<PhotoStatsNullableCompositeFilter, PhotoStatsObjectEqualityInput> | null
    views?: IntFilter<"UserPhoto"> | number
    labels?: StringNullableListFilter<"UserPhoto">
    title?: StringNullableFilter<"UserPhoto"> | string | null
    description?: StringNullableFilter<"UserPhoto"> | string | null
    adult?: BoolFilter<"UserPhoto"> | boolean
    createdAt?: DateTimeFilter<"UserPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"UserPhoto"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    contestUpload?: ContestPhotoListRelationFilter
    likes?: LikeListRelationFilter
  }

  export type UserPhotoOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    userId?: SortOrder
    states?: PhotoStatsOrderByInput
    views?: SortOrder
    labels?: SortOrder
    title?: SortOrder
    description?: SortOrder
    adult?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    contestUpload?: ContestPhotoOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
  }

  export type UserPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserPhotoWhereInput | UserPhotoWhereInput[]
    OR?: UserPhotoWhereInput[]
    NOT?: UserPhotoWhereInput | UserPhotoWhereInput[]
    url?: StringFilter<"UserPhoto"> | string
    userId?: StringFilter<"UserPhoto"> | string
    states?: XOR<PhotoStatsNullableCompositeFilter, PhotoStatsObjectEqualityInput> | null
    views?: IntFilter<"UserPhoto"> | number
    labels?: StringNullableListFilter<"UserPhoto">
    title?: StringNullableFilter<"UserPhoto"> | string | null
    description?: StringNullableFilter<"UserPhoto"> | string | null
    adult?: BoolFilter<"UserPhoto"> | boolean
    createdAt?: DateTimeFilter<"UserPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"UserPhoto"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    contestUpload?: ContestPhotoListRelationFilter
    likes?: LikeListRelationFilter
  }, "id">

  export type UserPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    userId?: SortOrder
    views?: SortOrder
    labels?: SortOrder
    title?: SortOrder
    description?: SortOrder
    adult?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPhotoCountOrderByAggregateInput
    _avg?: UserPhotoAvgOrderByAggregateInput
    _max?: UserPhotoMaxOrderByAggregateInput
    _min?: UserPhotoMinOrderByAggregateInput
    _sum?: UserPhotoSumOrderByAggregateInput
  }

  export type UserPhotoScalarWhereWithAggregatesInput = {
    AND?: UserPhotoScalarWhereWithAggregatesInput | UserPhotoScalarWhereWithAggregatesInput[]
    OR?: UserPhotoScalarWhereWithAggregatesInput[]
    NOT?: UserPhotoScalarWhereWithAggregatesInput | UserPhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPhoto"> | string
    url?: StringWithAggregatesFilter<"UserPhoto"> | string
    userId?: StringWithAggregatesFilter<"UserPhoto"> | string
    views?: IntWithAggregatesFilter<"UserPhoto"> | number
    labels?: StringNullableListFilter<"UserPhoto">
    title?: StringNullableWithAggregatesFilter<"UserPhoto"> | string | null
    description?: StringNullableWithAggregatesFilter<"UserPhoto"> | string | null
    adult?: BoolWithAggregatesFilter<"UserPhoto"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserPhoto"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPhoto"> | Date | string
  }

  export type LikeWhereInput = {
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    id?: StringFilter<"Like"> | string
    providerId?: StringFilter<"Like"> | string
    photoId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    updatedAt?: DateTimeFilter<"Like"> | Date | string
    provider?: XOR<UserScalarRelationFilter, UserWhereInput>
    photo?: XOR<UserPhotoScalarRelationFilter, UserPhotoWhereInput>
  }

  export type LikeOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: UserOrderByWithRelationInput
    photo?: UserPhotoOrderByWithRelationInput
  }

  export type LikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    photoId_providerId?: LikePhotoIdProviderIdCompoundUniqueInput
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    providerId?: StringFilter<"Like"> | string
    photoId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    updatedAt?: DateTimeFilter<"Like"> | Date | string
    provider?: XOR<UserScalarRelationFilter, UserWhereInput>
    photo?: XOR<UserPhotoScalarRelationFilter, UserPhotoWhereInput>
  }, "id" | "photoId_providerId">

  export type LikeOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LikeCountOrderByAggregateInput
    _max?: LikeMaxOrderByAggregateInput
    _min?: LikeMinOrderByAggregateInput
  }

  export type LikeScalarWhereWithAggregatesInput = {
    AND?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    OR?: LikeScalarWhereWithAggregatesInput[]
    NOT?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Like"> | string
    providerId?: StringWithAggregatesFilter<"Like"> | string
    photoId?: StringWithAggregatesFilter<"Like"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Like"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Like"> | Date | string
  }

  export type OtpWhereInput = {
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    id?: StringFilter<"Otp"> | string
    code?: StringFilter<"Otp"> | string
    expires_in?: DateTimeFilter<"Otp"> | Date | string
    userId?: StringFilter<"Otp"> | string
    otpStatus?: EnumOtpStatusFilter<"Otp"> | $Enums.OtpStatus
    createdAt?: DateTimeFilter<"Otp"> | Date | string
    updatedAt?: DateTimeFilter<"Otp"> | Date | string
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OtpOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    expires_in?: SortOrder
    userId?: SortOrder
    otpStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OtpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    code?: StringFilter<"Otp"> | string
    expires_in?: DateTimeFilter<"Otp"> | Date | string
    otpStatus?: EnumOtpStatusFilter<"Otp"> | $Enums.OtpStatus
    createdAt?: DateTimeFilter<"Otp"> | Date | string
    updatedAt?: DateTimeFilter<"Otp"> | Date | string
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type OtpOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    expires_in?: SortOrder
    userId?: SortOrder
    otpStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    _count?: OtpCountOrderByAggregateInput
    _max?: OtpMaxOrderByAggregateInput
    _min?: OtpMinOrderByAggregateInput
  }

  export type OtpScalarWhereWithAggregatesInput = {
    AND?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    OR?: OtpScalarWhereWithAggregatesInput[]
    NOT?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Otp"> | string
    code?: StringWithAggregatesFilter<"Otp"> | string
    expires_in?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
    userId?: StringWithAggregatesFilter<"Otp"> | string
    otpStatus?: EnumOtpStatusWithAggregatesFilter<"Otp"> | $Enums.OtpStatus
    createdAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    text?: StringFilter<"Comment"> | string
    providerId?: StringFilter<"Comment"> | string
    receiverId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    provider?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<ContestPhotoScalarRelationFilter, ContestPhotoWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    providerId?: SortOrder
    receiverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: UserOrderByWithRelationInput
    receiver?: ContestPhotoOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    text?: StringFilter<"Comment"> | string
    providerId?: StringFilter<"Comment"> | string
    receiverId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    provider?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<ContestPhotoScalarRelationFilter, ContestPhotoWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    providerId?: SortOrder
    receiverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    text?: StringWithAggregatesFilter<"Comment"> | string
    providerId?: StringWithAggregatesFilter<"Comment"> | string
    receiverId?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type FollowWhereInput = {
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    id?: StringFilter<"Follow"> | string
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    updatedAt?: DateTimeFilter<"Follow"> | Date | string
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    following?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FollowOrderByWithRelationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    follower?: UserOrderByWithRelationInput
    following?: UserOrderByWithRelationInput
  }

  export type FollowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    followerId_followingId?: FollowFollowerIdFollowingIdCompoundUniqueInput
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    updatedAt?: DateTimeFilter<"Follow"> | Date | string
    follower?: XOR<UserScalarRelationFilter, UserWhereInput>
    following?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "followerId_followingId">

  export type FollowOrderByWithAggregationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FollowCountOrderByAggregateInput
    _max?: FollowMaxOrderByAggregateInput
    _min?: FollowMinOrderByAggregateInput
  }

  export type FollowScalarWhereWithAggregatesInput = {
    AND?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    OR?: FollowScalarWhereWithAggregatesInput[]
    NOT?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Follow"> | string
    followerId?: StringWithAggregatesFilter<"Follow"> | string
    followingId?: StringWithAggregatesFilter<"Follow"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Follow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Follow"> | Date | string
  }

  export type VoteWhereInput = {
    AND?: VoteWhereInput | VoteWhereInput[]
    OR?: VoteWhereInput[]
    NOT?: VoteWhereInput | VoteWhereInput[]
    id?: StringFilter<"Vote"> | string
    providerId?: StringFilter<"Vote"> | string
    photoId?: StringFilter<"Vote"> | string
    contestId?: StringFilter<"Vote"> | string
    createdAt?: DateTimeFilter<"Vote"> | Date | string
    updatedAt?: DateTimeFilter<"Vote"> | Date | string
    provider?: XOR<UserScalarRelationFilter, UserWhereInput>
    photo?: XOR<ContestPhotoScalarRelationFilter, ContestPhotoWhereInput>
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
  }

  export type VoteOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    photoId?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: UserOrderByWithRelationInput
    photo?: ContestPhotoOrderByWithRelationInput
    contest?: ContestOrderByWithRelationInput
  }

  export type VoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VoteWhereInput | VoteWhereInput[]
    OR?: VoteWhereInput[]
    NOT?: VoteWhereInput | VoteWhereInput[]
    providerId?: StringFilter<"Vote"> | string
    photoId?: StringFilter<"Vote"> | string
    contestId?: StringFilter<"Vote"> | string
    createdAt?: DateTimeFilter<"Vote"> | Date | string
    updatedAt?: DateTimeFilter<"Vote"> | Date | string
    provider?: XOR<UserScalarRelationFilter, UserWhereInput>
    photo?: XOR<ContestPhotoScalarRelationFilter, ContestPhotoWhereInput>
    contest?: XOR<ContestScalarRelationFilter, ContestWhereInput>
  }, "id">

  export type VoteOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    photoId?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VoteCountOrderByAggregateInput
    _max?: VoteMaxOrderByAggregateInput
    _min?: VoteMinOrderByAggregateInput
  }

  export type VoteScalarWhereWithAggregatesInput = {
    AND?: VoteScalarWhereWithAggregatesInput | VoteScalarWhereWithAggregatesInput[]
    OR?: VoteScalarWhereWithAggregatesInput[]
    NOT?: VoteScalarWhereWithAggregatesInput | VoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vote"> | string
    providerId?: StringWithAggregatesFilter<"Vote"> | string
    photoId?: StringWithAggregatesFilter<"Vote"> | string
    contestId?: StringWithAggregatesFilter<"Vote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Vote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vote"> | Date | string
  }

  export type ContestCreateInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    maxUploads?: number | null
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedContestsInput
    participants?: ContestParticipantCreateNestedManyWithoutContestInput
    votes?: VoteCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeCreateNestedManyWithoutContestInput
    recurringData?: RecurringContestDataCreateNestedOneWithoutContestInput
  }

  export type ContestUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    maxUploads?: number | null
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ContestParticipantUncheckedCreateNestedManyWithoutContestInput
    votes?: VoteUncheckedCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleUncheckedCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeUncheckedCreateNestedManyWithoutContestInput
    recurringData?: RecurringContestDataUncheckedCreateNestedOneWithoutContestInput
  }

  export type ContestUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedContestsNestedInput
    participants?: ContestParticipantUpdateManyWithoutContestNestedInput
    votes?: VoteUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUpdateManyWithoutContestNestedInput
    recurringData?: RecurringContestDataUpdateOneWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ContestParticipantUncheckedUpdateManyWithoutContestNestedInput
    votes?: VoteUncheckedUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUncheckedUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUncheckedUpdateManyWithoutContestNestedInput
    recurringData?: RecurringContestDataUncheckedUpdateOneWithoutContestNestedInput
  }

  export type ContestCreateManyInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    maxUploads?: number | null
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestRuleCreateInput = {
    id?: string
    icon?: string | null
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contest: ContestCreateNestedOneWithoutContestRulesInput
  }

  export type ContestRuleUncheckedCreateInput = {
    id?: string
    icon?: string | null
    name: string
    description: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestRuleUpdateInput = {
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contest?: ContestUpdateOneRequiredWithoutContestRulesNestedInput
  }

  export type ContestRuleUncheckedUpdateInput = {
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestRuleCreateManyInput = {
    id?: string
    icon?: string | null
    name: string
    description: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestRuleUpdateManyMutationInput = {
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestRuleUncheckedUpdateManyInput = {
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringContestDataCreateInput = {
    id?: string
    lastRunAt?: Date | string | null
    nextRunAt: Date | string
    contest: ContestCreateNestedOneWithoutRecurringDataInput
  }

  export type RecurringContestDataUncheckedCreateInput = {
    id?: string
    constestId: string
    lastRunAt?: Date | string | null
    nextRunAt: Date | string
  }

  export type RecurringContestDataUpdateInput = {
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contest?: ContestUpdateOneRequiredWithoutRecurringDataNestedInput
  }

  export type RecurringContestDataUncheckedUpdateInput = {
    constestId?: StringFieldUpdateOperationsInput | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringContestDataCreateManyInput = {
    id?: string
    constestId: string
    lastRunAt?: Date | string | null
    nextRunAt: Date | string
  }

  export type RecurringContestDataUpdateManyMutationInput = {
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringContestDataUncheckedUpdateManyInput = {
    constestId?: StringFieldUpdateOperationsInput | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringContestCreateInput = {
    id?: string
    creatorId: string
    title: string
    description: string
    banner?: string | null
    maxUploads?: number | null
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    recurringData: XOR<RecurringDataCreateEnvelopeInput, RecurringDataCreateInput>
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringContestUncheckedCreateInput = {
    id?: string
    creatorId: string
    title: string
    description: string
    banner?: string | null
    maxUploads?: number | null
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    recurringData: XOR<RecurringDataCreateEnvelopeInput, RecurringDataCreateInput>
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringContestUpdateInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    recurringData?: XOR<RecurringDataUpdateEnvelopeInput, RecurringDataCreateInput>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringContestUncheckedUpdateInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    recurringData?: XOR<RecurringDataUpdateEnvelopeInput, RecurringDataCreateInput>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringContestCreateManyInput = {
    id?: string
    creatorId: string
    title: string
    description: string
    banner?: string | null
    maxUploads?: number | null
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    recurringData: XOR<RecurringDataCreateEnvelopeInput, RecurringDataCreateInput>
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecurringContestUpdateManyMutationInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    recurringData?: XOR<RecurringDataUpdateEnvelopeInput, RecurringDataCreateInput>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringContestUncheckedUpdateManyInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    recurringData?: XOR<RecurringDataUpdateEnvelopeInput, RecurringDataCreateInput>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestPhotoCreateInput = {
    id?: string
    title?: string | null
    contestId: string
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participant: ContestParticipantCreateNestedOneWithoutPhotosInput
    votes?: VoteCreateNestedManyWithoutPhotoInput
    photo: UserPhotoCreateNestedOneWithoutContestUploadInput
    comments?: CommentCreateNestedManyWithoutReceiverInput
    achievements?: ContestAchievementCreateNestedManyWithoutPhotoInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoUncheckedCreateInput = {
    id?: string
    title?: string | null
    contestId: string
    participantId: string
    photoId: string
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutPhotoInput
    comments?: CommentUncheckedCreateNestedManyWithoutReceiverInput
    achievements?: ContestAchievementUncheckedCreateNestedManyWithoutPhotoInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ContestParticipantUpdateOneRequiredWithoutPhotosNestedInput
    votes?: VoteUpdateManyWithoutPhotoNestedInput
    photo?: UserPhotoUpdateOneRequiredWithoutContestUploadNestedInput
    comments?: CommentUpdateManyWithoutReceiverNestedInput
    achievements?: ContestAchievementUpdateManyWithoutPhotoNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutPhotoNestedInput
  }

  export type ContestPhotoUncheckedUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutPhotoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutReceiverNestedInput
    achievements?: ContestAchievementUncheckedUpdateManyWithoutPhotoNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type ContestPhotoCreateManyInput = {
    id?: string
    title?: string | null
    contestId: string
    participantId: string
    photoId: string
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestPhotoUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestPhotoUncheckedUpdateManyInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestWinnerCreateInput = {
    id?: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participant: ContestParticipantCreateNestedOneWithoutContestWinnerInput
    photo: ContestPhotoCreateNestedOneWithoutContestWinnerInput
  }

  export type ContestWinnerUncheckedCreateInput = {
    id?: string
    participantId: string
    contestId: string
    contestPhotoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestWinnerUpdateInput = {
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ContestParticipantUpdateOneRequiredWithoutContestWinnerNestedInput
    photo?: ContestPhotoUpdateOneRequiredWithoutContestWinnerNestedInput
  }

  export type ContestWinnerUncheckedUpdateInput = {
    participantId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    contestPhotoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestWinnerCreateManyInput = {
    id?: string
    participantId: string
    contestId: string
    contestPhotoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestWinnerUpdateManyMutationInput = {
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestWinnerUncheckedUpdateManyInput = {
    participantId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    contestPhotoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestParticipantCreateInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    level?: $Enums.ContestLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contest: ContestCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutContestParticipantInput
    photos?: ContestPhotoCreateNestedManyWithoutParticipantInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantUncheckedCreateInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    contestId: string
    userId: string
    level?: $Enums.ContestLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ContestPhotoUncheckedCreateNestedManyWithoutParticipantInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantUpdateInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    level?: EnumContestLevelFieldUpdateOperationsInput | $Enums.ContestLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contest?: ContestUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutContestParticipantNestedInput
    photos?: ContestPhotoUpdateManyWithoutParticipantNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUpdateManyWithoutParticipantNestedInput
  }

  export type ContestParticipantUncheckedUpdateInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    contestId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    level?: EnumContestLevelFieldUpdateOperationsInput | $Enums.ContestLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ContestPhotoUncheckedUpdateManyWithoutParticipantNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type ContestParticipantCreateManyInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    contestId: string
    userId: string
    level?: $Enums.ContestLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestParticipantUpdateManyMutationInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    level?: EnumContestLevelFieldUpdateOperationsInput | $Enums.ContestLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestParticipantUncheckedUpdateManyInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    contestId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    level?: EnumContestLevelFieldUpdateOperationsInput | $Enums.ContestLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestPrizeCreateInput = {
    id?: string
    category: $Enums.PrizeType
    trades?: number
    charges?: number
    keys?: number
    contest: ContestCreateNestedOneWithoutContestPrizesInput
  }

  export type ContestPrizeUncheckedCreateInput = {
    id?: string
    category: $Enums.PrizeType
    trades?: number
    charges?: number
    keys?: number
    contestId: string
  }

  export type ContestPrizeUpdateInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    trades?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    keys?: IntFieldUpdateOperationsInput | number
    contest?: ContestUpdateOneRequiredWithoutContestPrizesNestedInput
  }

  export type ContestPrizeUncheckedUpdateInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    trades?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    keys?: IntFieldUpdateOperationsInput | number
    contestId?: StringFieldUpdateOperationsInput | string
  }

  export type ContestPrizeCreateManyInput = {
    id?: string
    category: $Enums.PrizeType
    trades?: number
    charges?: number
    keys?: number
    contestId: string
  }

  export type ContestPrizeUpdateManyMutationInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    trades?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    keys?: IntFieldUpdateOperationsInput | number
  }

  export type ContestPrizeUncheckedUpdateManyInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    trades?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    keys?: IntFieldUpdateOperationsInput | number
    contestId?: StringFieldUpdateOperationsInput | string
  }

  export type ContestAchievementCreateInput = {
    id?: string
    category: $Enums.PrizeType
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    photo?: ContestPhotoCreateNestedOneWithoutAchievementsInput
    participant?: ContestParticipantCreateNestedOneWithoutContestAchievementInput
  }

  export type ContestAchievementUncheckedCreateInput = {
    id?: string
    category: $Enums.PrizeType
    photoId?: string | null
    participantId?: string | null
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestAchievementUpdateInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: ContestPhotoUpdateOneWithoutAchievementsNestedInput
    participant?: ContestParticipantUpdateOneWithoutContestAchievementNestedInput
  }

  export type ContestAchievementUncheckedUpdateInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    photoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestAchievementCreateManyInput = {
    id?: string
    category: $Enums.PrizeType
    photoId?: string | null
    participantId?: string | null
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestAchievementUpdateManyMutationInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestAchievementUncheckedUpdateManyInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    photoId?: NullableStringFieldUpdateOperationsInput | string | null
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility: $Enums.TeamAccessibility
    badge: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedTeamInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility: $Enums.TeamAccessibility
    badge: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    badge?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedTeamNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    badge?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility: $Enums.TeamAccessibility
    badge: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    badge?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    badge?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateInput = {
    id?: string
    status?: $Enums.TeamMemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
    member: UserCreateNestedOneWithoutJoinedTeamInput
  }

  export type TeamMemberUncheckedCreateInput = {
    id?: string
    status?: $Enums.TeamMemberStatus
    teamId: string
    memberId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateInput = {
    status?: EnumTeamMemberStatusFieldUpdateOperationsInput | $Enums.TeamMemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
    member?: UserUpdateOneRequiredWithoutJoinedTeamNestedInput
  }

  export type TeamMemberUncheckedUpdateInput = {
    status?: EnumTeamMemberStatusFieldUpdateOperationsInput | $Enums.TeamMemberStatus
    teamId?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyInput = {
    id?: string
    status?: $Enums.TeamMemberStatus
    teamId: string
    memberId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateManyMutationInput = {
    status?: EnumTeamMemberStatusFieldUpdateOperationsInput | $Enums.TeamMemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyInput = {
    status?: EnumTeamMemberStatusFieldUpdateOperationsInput | $Enums.TeamMemberStatus
    teamId?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhotoCreateInput = {
    id?: string
    url: string
    states?: XOR<PhotoStatsNullableCreateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: number
    labels?: UserPhotoCreatelabelsInput | string[]
    title?: string | null
    description?: string | null
    adult?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserPhotosInput
    contestUpload?: ContestPhotoCreateNestedManyWithoutPhotoInput
    likes?: LikeCreateNestedManyWithoutPhotoInput
  }

  export type UserPhotoUncheckedCreateInput = {
    id?: string
    url: string
    userId: string
    states?: XOR<PhotoStatsNullableCreateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: number
    labels?: UserPhotoCreatelabelsInput | string[]
    title?: string | null
    description?: string | null
    adult?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contestUpload?: ContestPhotoUncheckedCreateNestedManyWithoutPhotoInput
    likes?: LikeUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type UserPhotoUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserPhotosNestedInput
    contestUpload?: ContestPhotoUpdateManyWithoutPhotoNestedInput
    likes?: LikeUpdateManyWithoutPhotoNestedInput
  }

  export type UserPhotoUncheckedUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contestUpload?: ContestPhotoUncheckedUpdateManyWithoutPhotoNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type UserPhotoCreateManyInput = {
    id?: string
    url: string
    userId: string
    states?: XOR<PhotoStatsNullableCreateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: number
    labels?: UserPhotoCreatelabelsInput | string[]
    title?: string | null
    description?: string | null
    adult?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPhotoUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhotoUncheckedUpdateManyInput = {
    url?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: UserCreateNestedOneWithoutLikesInput
    photo: UserPhotoCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateInput = {
    id?: string
    providerId: string
    photoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: UserUpdateOneRequiredWithoutLikesNestedInput
    photo?: UserPhotoUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateManyInput = {
    id?: string
    providerId: string
    photoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpCreateInput = {
    id?: string
    code: string
    expires_in: Date | string
    otpStatus?: $Enums.OtpStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutOtpsInput
  }

  export type OtpUncheckedCreateInput = {
    id?: string
    code: string
    expires_in: Date | string
    userId: string
    otpStatus?: $Enums.OtpStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
  }

  export type OtpUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    expires_in?: DateTimeFieldUpdateOperationsInput | Date | string
    otpStatus?: EnumOtpStatusFieldUpdateOperationsInput | $Enums.OtpStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOtpsNestedInput
  }

  export type OtpUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    expires_in?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    otpStatus?: EnumOtpStatusFieldUpdateOperationsInput | $Enums.OtpStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpCreateManyInput = {
    id?: string
    code: string
    expires_in: Date | string
    userId: string
    otpStatus?: $Enums.OtpStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
  }

  export type OtpUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    expires_in?: DateTimeFieldUpdateOperationsInput | Date | string
    otpStatus?: EnumOtpStatusFieldUpdateOperationsInput | $Enums.OtpStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    expires_in?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    otpStatus?: EnumOtpStatusFieldUpdateOperationsInput | $Enums.OtpStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: UserCreateNestedOneWithoutCommentProvidesInput
    receiver: ContestPhotoCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    text: string
    providerId: string
    receiverId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: UserUpdateOneRequiredWithoutCommentProvidesNestedInput
    receiver?: ContestPhotoUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: string
    text: string
    providerId: string
    receiverId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    text?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowersInput
    following: UserCreateNestedOneWithoutFollowingsInput
  }

  export type FollowUncheckedCreateInput = {
    id?: string
    followerId: string
    followingId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowersNestedInput
    following?: UserUpdateOneRequiredWithoutFollowingsNestedInput
  }

  export type FollowUncheckedUpdateInput = {
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowCreateManyInput = {
    id?: string
    followerId: string
    followingId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyInput = {
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: UserCreateNestedOneWithoutVotesInput
    photo: ContestPhotoCreateNestedOneWithoutVotesInput
    contest: ContestCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateInput = {
    id?: string
    providerId: string
    photoId: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: UserUpdateOneRequiredWithoutVotesNestedInput
    photo?: ContestPhotoUpdateOneRequiredWithoutVotesNestedInput
    contest?: ContestUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteCreateManyInput = {
    id?: string
    providerId: string
    photoId: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUncheckedUpdateManyInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type EnumContestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestStatus | EnumContestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContestStatus[] | ListEnumContestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestStatus[] | ListEnumContestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContestStatusFilter<$PrismaModel> | $Enums.ContestStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ContestParticipantListRelationFilter = {
    every?: ContestParticipantWhereInput
    some?: ContestParticipantWhereInput
    none?: ContestParticipantWhereInput
  }

  export type VoteListRelationFilter = {
    every?: VoteWhereInput
    some?: VoteWhereInput
    none?: VoteWhereInput
  }

  export type ContestRuleListRelationFilter = {
    every?: ContestRuleWhereInput
    some?: ContestRuleWhereInput
    none?: ContestRuleWhereInput
  }

  export type ContestPrizeListRelationFilter = {
    every?: ContestPrizeWhereInput
    some?: ContestPrizeWhereInput
    none?: ContestPrizeWhereInput
  }

  export type RecurringContestDataNullableScalarRelationFilter = {
    is?: RecurringContestDataWhereInput | null
    isNot?: RecurringContestDataWhereInput | null
  }

  export type ContestParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContestRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContestPrizeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContestCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    status?: SortOrder
    maxUploads?: SortOrder
    isMoneyContest?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestAvgOrderByAggregateInput = {
    maxUploads?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
  }

  export type ContestMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    status?: SortOrder
    maxUploads?: SortOrder
    isMoneyContest?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    status?: SortOrder
    maxUploads?: SortOrder
    isMoneyContest?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestSumOrderByAggregateInput = {
    maxUploads?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumContestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestStatus | EnumContestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContestStatus[] | ListEnumContestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestStatus[] | ListEnumContestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContestStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContestStatusFilter<$PrismaModel>
    _max?: NestedEnumContestStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ContestScalarRelationFilter = {
    is?: ContestWhereInput
    isNot?: ContestWhereInput
  }

  export type ContestRuleCountOrderByAggregateInput = {
    id?: SortOrder
    icon?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    icon?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestRuleMinOrderByAggregateInput = {
    id?: SortOrder
    icon?: SortOrder
    name?: SortOrder
    description?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type RecurringContestDataCountOrderByAggregateInput = {
    id?: SortOrder
    constestId?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
  }

  export type RecurringContestDataMaxOrderByAggregateInput = {
    id?: SortOrder
    constestId?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
  }

  export type RecurringContestDataMinOrderByAggregateInput = {
    id?: SortOrder
    constestId?: SortOrder
    lastRunAt?: SortOrder
    nextRunAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type RecurringDataCompositeFilter = {
    equals?: RecurringDataObjectEqualityInput
    is?: RecurringDataWhereInput
    isNot?: RecurringDataWhereInput
  }

  export type RecurringDataObjectEqualityInput = {
    recurringType: $Enums.RecurringType
    previousOccurrence: Date | string
    nextOccurrence: Date | string
    duration: number
  }

  export type RecurringDataOrderByInput = {
    recurringType?: SortOrder
    previousOccurrence?: SortOrder
    nextOccurrence?: SortOrder
    duration?: SortOrder
  }

  export type RecurringContestCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    maxUploads?: SortOrder
    isMoneyContest?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringContestAvgOrderByAggregateInput = {
    maxUploads?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
  }

  export type RecurringContestMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    maxUploads?: SortOrder
    isMoneyContest?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringContestMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    banner?: SortOrder
    maxUploads?: SortOrder
    isMoneyContest?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecurringContestSumOrderByAggregateInput = {
    maxUploads?: SortOrder
    maxPrize?: SortOrder
    minPrize?: SortOrder
  }

  export type ContestParticipantScalarRelationFilter = {
    is?: ContestParticipantWhereInput
    isNot?: ContestParticipantWhereInput
  }

  export type UserPhotoScalarRelationFilter = {
    is?: UserPhotoWhereInput
    isNot?: UserPhotoWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type ContestAchievementListRelationFilter = {
    every?: ContestAchievementWhereInput
    some?: ContestAchievementWhereInput
    none?: ContestAchievementWhereInput
  }

  export type ContestWinnerListRelationFilter = {
    every?: ContestWinnerWhereInput
    some?: ContestWinnerWhereInput
    none?: ContestWinnerWhereInput
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContestAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContestWinnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContestPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    contestId?: SortOrder
    participantId?: SortOrder
    photoId?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestPhotoAvgOrderByAggregateInput = {
    rank?: SortOrder
  }

  export type ContestPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    contestId?: SortOrder
    participantId?: SortOrder
    photoId?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    contestId?: SortOrder
    participantId?: SortOrder
    photoId?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestPhotoSumOrderByAggregateInput = {
    rank?: SortOrder
  }

  export type ContestPhotoScalarRelationFilter = {
    is?: ContestPhotoWhereInput
    isNot?: ContestPhotoWhereInput
  }

  export type ContestWinnerCountOrderByAggregateInput = {
    id?: SortOrder
    participantId?: SortOrder
    contestId?: SortOrder
    contestPhotoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestWinnerMaxOrderByAggregateInput = {
    id?: SortOrder
    participantId?: SortOrder
    contestId?: SortOrder
    contestPhotoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestWinnerMinOrderByAggregateInput = {
    id?: SortOrder
    participantId?: SortOrder
    contestId?: SortOrder
    contestPhotoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumContestParticipantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestParticipantStatus | EnumContestParticipantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContestParticipantStatus[] | ListEnumContestParticipantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestParticipantStatus[] | ListEnumContestParticipantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContestParticipantStatusFilter<$PrismaModel> | $Enums.ContestParticipantStatus
  }

  export type EnumContestLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestLevel | EnumContestLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ContestLevel[] | ListEnumContestLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestLevel[] | ListEnumContestLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumContestLevelFilter<$PrismaModel> | $Enums.ContestLevel
  }

  export type ContestPhotoListRelationFilter = {
    every?: ContestPhotoWhereInput
    some?: ContestPhotoWhereInput
    none?: ContestPhotoWhereInput
  }

  export type ContestPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContestParticipantContestIdUserIdCompoundUniqueInput = {
    contestId: string
    userId: string
  }

  export type ContestParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    contestId?: SortOrder
    userId?: SortOrder
    level?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestParticipantAvgOrderByAggregateInput = {
    rank?: SortOrder
  }

  export type ContestParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    contestId?: SortOrder
    userId?: SortOrder
    level?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    contestId?: SortOrder
    userId?: SortOrder
    level?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestParticipantSumOrderByAggregateInput = {
    rank?: SortOrder
  }

  export type EnumContestParticipantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestParticipantStatus | EnumContestParticipantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContestParticipantStatus[] | ListEnumContestParticipantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestParticipantStatus[] | ListEnumContestParticipantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContestParticipantStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContestParticipantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContestParticipantStatusFilter<$PrismaModel>
    _max?: NestedEnumContestParticipantStatusFilter<$PrismaModel>
  }

  export type EnumContestLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestLevel | EnumContestLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ContestLevel[] | ListEnumContestLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestLevel[] | ListEnumContestLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumContestLevelWithAggregatesFilter<$PrismaModel> | $Enums.ContestLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContestLevelFilter<$PrismaModel>
    _max?: NestedEnumContestLevelFilter<$PrismaModel>
  }

  export type EnumPrizeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PrizeType | EnumPrizeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PrizeType[] | ListEnumPrizeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrizeType[] | ListEnumPrizeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPrizeTypeFilter<$PrismaModel> | $Enums.PrizeType
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ContestPrizeCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    trades?: SortOrder
    charges?: SortOrder
    keys?: SortOrder
    contestId?: SortOrder
  }

  export type ContestPrizeAvgOrderByAggregateInput = {
    trades?: SortOrder
    charges?: SortOrder
    keys?: SortOrder
  }

  export type ContestPrizeMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    trades?: SortOrder
    charges?: SortOrder
    keys?: SortOrder
    contestId?: SortOrder
  }

  export type ContestPrizeMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    trades?: SortOrder
    charges?: SortOrder
    keys?: SortOrder
    contestId?: SortOrder
  }

  export type ContestPrizeSumOrderByAggregateInput = {
    trades?: SortOrder
    charges?: SortOrder
    keys?: SortOrder
  }

  export type EnumPrizeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrizeType | EnumPrizeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PrizeType[] | ListEnumPrizeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrizeType[] | ListEnumPrizeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPrizeTypeWithAggregatesFilter<$PrismaModel> | $Enums.PrizeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrizeTypeFilter<$PrismaModel>
    _max?: NestedEnumPrizeTypeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ContestPhotoNullableScalarRelationFilter = {
    is?: ContestPhotoWhereInput | null
    isNot?: ContestPhotoWhereInput | null
  }

  export type ContestParticipantNullableScalarRelationFilter = {
    is?: ContestParticipantWhereInput | null
    isNot?: ContestParticipantWhereInput | null
  }

  export type ContestAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    photoId?: SortOrder
    participantId?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    photoId?: SortOrder
    participantId?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContestAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    photoId?: SortOrder
    participantId?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTeamAccessibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamAccessibility | EnumTeamAccessibilityFieldRefInput<$PrismaModel>
    in?: $Enums.TeamAccessibility[] | ListEnumTeamAccessibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamAccessibility[] | ListEnumTeamAccessibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamAccessibilityFilter<$PrismaModel> | $Enums.TeamAccessibility
  }

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput
    some?: TeamMemberWhereInput
    none?: TeamMemberWhereInput
  }

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    language?: SortOrder
    country?: SortOrder
    description?: SortOrder
    accessibility?: SortOrder
    badge?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    language?: SortOrder
    country?: SortOrder
    description?: SortOrder
    accessibility?: SortOrder
    badge?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    language?: SortOrder
    country?: SortOrder
    description?: SortOrder
    accessibility?: SortOrder
    badge?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTeamAccessibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamAccessibility | EnumTeamAccessibilityFieldRefInput<$PrismaModel>
    in?: $Enums.TeamAccessibility[] | ListEnumTeamAccessibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamAccessibility[] | ListEnumTeamAccessibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamAccessibilityWithAggregatesFilter<$PrismaModel> | $Enums.TeamAccessibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamAccessibilityFilter<$PrismaModel>
    _max?: NestedEnumTeamAccessibilityFilter<$PrismaModel>
  }

  export type EnumTeamMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamMemberStatus | EnumTeamMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TeamMemberStatus[] | ListEnumTeamMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamMemberStatus[] | ListEnumTeamMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamMemberStatusFilter<$PrismaModel> | $Enums.TeamMemberStatus
  }

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    teamId?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    teamId?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    teamId?: SortOrder
    memberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTeamMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamMemberStatus | EnumTeamMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TeamMemberStatus[] | ListEnumTeamMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamMemberStatus[] | ListEnumTeamMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.TeamMemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumTeamMemberStatusFilter<$PrismaModel>
  }

  export type EnumUserLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserLevel | EnumUserLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserLevel[] | ListEnumUserLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserLevel[] | ListEnumUserLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserLevelNullableFilter<$PrismaModel> | $Enums.UserLevel | null
    isSet?: boolean
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type OtpNullableScalarRelationFilter = {
    is?: OtpWhereInput | null
    isNot?: OtpWhereInput | null
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type TeamMemberNullableScalarRelationFilter = {
    is?: TeamMemberWhereInput | null
    isNot?: TeamMemberWhereInput | null
  }

  export type ContestListRelationFilter = {
    every?: ContestWhereInput
    some?: ContestWhereInput
    none?: ContestWhereInput
  }

  export type FollowListRelationFilter = {
    every?: FollowWhereInput
    some?: FollowWhereInput
    none?: FollowWhereInput
  }

  export type LikeListRelationFilter = {
    every?: LikeWhereInput
    some?: LikeWhereInput
    none?: LikeWhereInput
  }

  export type UserPhotoListRelationFilter = {
    every?: UserPhotoWhereInput
    some?: UserPhotoWhereInput
    none?: UserPhotoWhereInput
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    cover?: SortOrder
    avatar?: SortOrder
    socialId?: SortOrder
    socialProvider?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    location?: SortOrder
    level?: SortOrder
    password?: SortOrder
    role?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    cover?: SortOrder
    avatar?: SortOrder
    socialId?: SortOrder
    socialProvider?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    location?: SortOrder
    level?: SortOrder
    password?: SortOrder
    role?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    cover?: SortOrder
    avatar?: SortOrder
    socialId?: SortOrder
    socialProvider?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    location?: SortOrder
    level?: SortOrder
    password?: SortOrder
    role?: SortOrder
    accessToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserLevel | EnumUserLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserLevel[] | ListEnumUserLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserLevel[] | ListEnumUserLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumUserLevelNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type PhotoStatsNullableCompositeFilter = {
    equals?: PhotoStatsObjectEqualityInput | null
    is?: PhotoStatsWhereInput | null
    isNot?: PhotoStatsWhereInput | null
    isSet?: boolean
  }

  export type PhotoStatsObjectEqualityInput = {
    Composition: number
    Content: number
    Creativity: number
    Technique: number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type PhotoStatsOrderByInput = {
    Composition?: SortOrder
    Content?: SortOrder
    Creativity?: SortOrder
    Technique?: SortOrder
  }

  export type UserPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    userId?: SortOrder
    views?: SortOrder
    labels?: SortOrder
    title?: SortOrder
    description?: SortOrder
    adult?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPhotoAvgOrderByAggregateInput = {
    views?: SortOrder
  }

  export type UserPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    userId?: SortOrder
    views?: SortOrder
    title?: SortOrder
    description?: SortOrder
    adult?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    userId?: SortOrder
    views?: SortOrder
    title?: SortOrder
    description?: SortOrder
    adult?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPhotoSumOrderByAggregateInput = {
    views?: SortOrder
  }

  export type LikePhotoIdProviderIdCompoundUniqueInput = {
    photoId: string
    providerId: string
  }

  export type LikeCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LikeMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LikeMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    photoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumOtpStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OtpStatus | EnumOtpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OtpStatus[] | ListEnumOtpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OtpStatus[] | ListEnumOtpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOtpStatusFilter<$PrismaModel> | $Enums.OtpStatus
  }

  export type OtpCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    expires_in?: SortOrder
    userId?: SortOrder
    otpStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type OtpMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    expires_in?: SortOrder
    userId?: SortOrder
    otpStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type OtpMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    expires_in?: SortOrder
    userId?: SortOrder
    otpStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EnumOtpStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OtpStatus | EnumOtpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OtpStatus[] | ListEnumOtpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OtpStatus[] | ListEnumOtpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOtpStatusWithAggregatesFilter<$PrismaModel> | $Enums.OtpStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOtpStatusFilter<$PrismaModel>
    _max?: NestedEnumOtpStatusFilter<$PrismaModel>
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    providerId?: SortOrder
    receiverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    providerId?: SortOrder
    receiverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    providerId?: SortOrder
    receiverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FollowFollowerIdFollowingIdCompoundUniqueInput = {
    followerId: string
    followingId: string
  }

  export type FollowCountOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FollowMaxOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FollowMinOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoteCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    photoId?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoteMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    photoId?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoteMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    photoId?: SortOrder
    contestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCreateNestedOneWithoutCreatedContestsInput = {
    create?: XOR<UserCreateWithoutCreatedContestsInput, UserUncheckedCreateWithoutCreatedContestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedContestsInput
    connect?: UserWhereUniqueInput
  }

  export type ContestParticipantCreateNestedManyWithoutContestInput = {
    create?: XOR<ContestParticipantCreateWithoutContestInput, ContestParticipantUncheckedCreateWithoutContestInput> | ContestParticipantCreateWithoutContestInput[] | ContestParticipantUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutContestInput | ContestParticipantCreateOrConnectWithoutContestInput[]
    createMany?: ContestParticipantCreateManyContestInputEnvelope
    connect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
  }

  export type VoteCreateNestedManyWithoutContestInput = {
    create?: XOR<VoteCreateWithoutContestInput, VoteUncheckedCreateWithoutContestInput> | VoteCreateWithoutContestInput[] | VoteUncheckedCreateWithoutContestInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutContestInput | VoteCreateOrConnectWithoutContestInput[]
    createMany?: VoteCreateManyContestInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type ContestRuleCreateNestedManyWithoutContestInput = {
    create?: XOR<ContestRuleCreateWithoutContestInput, ContestRuleUncheckedCreateWithoutContestInput> | ContestRuleCreateWithoutContestInput[] | ContestRuleUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestRuleCreateOrConnectWithoutContestInput | ContestRuleCreateOrConnectWithoutContestInput[]
    createMany?: ContestRuleCreateManyContestInputEnvelope
    connect?: ContestRuleWhereUniqueInput | ContestRuleWhereUniqueInput[]
  }

  export type ContestPrizeCreateNestedManyWithoutContestInput = {
    create?: XOR<ContestPrizeCreateWithoutContestInput, ContestPrizeUncheckedCreateWithoutContestInput> | ContestPrizeCreateWithoutContestInput[] | ContestPrizeUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestPrizeCreateOrConnectWithoutContestInput | ContestPrizeCreateOrConnectWithoutContestInput[]
    createMany?: ContestPrizeCreateManyContestInputEnvelope
    connect?: ContestPrizeWhereUniqueInput | ContestPrizeWhereUniqueInput[]
  }

  export type RecurringContestDataCreateNestedOneWithoutContestInput = {
    create?: XOR<RecurringContestDataCreateWithoutContestInput, RecurringContestDataUncheckedCreateWithoutContestInput>
    connectOrCreate?: RecurringContestDataCreateOrConnectWithoutContestInput
    connect?: RecurringContestDataWhereUniqueInput
  }

  export type ContestParticipantUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<ContestParticipantCreateWithoutContestInput, ContestParticipantUncheckedCreateWithoutContestInput> | ContestParticipantCreateWithoutContestInput[] | ContestParticipantUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutContestInput | ContestParticipantCreateOrConnectWithoutContestInput[]
    createMany?: ContestParticipantCreateManyContestInputEnvelope
    connect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
  }

  export type VoteUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<VoteCreateWithoutContestInput, VoteUncheckedCreateWithoutContestInput> | VoteCreateWithoutContestInput[] | VoteUncheckedCreateWithoutContestInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutContestInput | VoteCreateOrConnectWithoutContestInput[]
    createMany?: VoteCreateManyContestInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type ContestRuleUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<ContestRuleCreateWithoutContestInput, ContestRuleUncheckedCreateWithoutContestInput> | ContestRuleCreateWithoutContestInput[] | ContestRuleUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestRuleCreateOrConnectWithoutContestInput | ContestRuleCreateOrConnectWithoutContestInput[]
    createMany?: ContestRuleCreateManyContestInputEnvelope
    connect?: ContestRuleWhereUniqueInput | ContestRuleWhereUniqueInput[]
  }

  export type ContestPrizeUncheckedCreateNestedManyWithoutContestInput = {
    create?: XOR<ContestPrizeCreateWithoutContestInput, ContestPrizeUncheckedCreateWithoutContestInput> | ContestPrizeCreateWithoutContestInput[] | ContestPrizeUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestPrizeCreateOrConnectWithoutContestInput | ContestPrizeCreateOrConnectWithoutContestInput[]
    createMany?: ContestPrizeCreateManyContestInputEnvelope
    connect?: ContestPrizeWhereUniqueInput | ContestPrizeWhereUniqueInput[]
  }

  export type RecurringContestDataUncheckedCreateNestedOneWithoutContestInput = {
    create?: XOR<RecurringContestDataCreateWithoutContestInput, RecurringContestDataUncheckedCreateWithoutContestInput>
    connectOrCreate?: RecurringContestDataCreateOrConnectWithoutContestInput
    connect?: RecurringContestDataWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type EnumContestStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContestStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutCreatedContestsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedContestsInput, UserUncheckedCreateWithoutCreatedContestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedContestsInput
    upsert?: UserUpsertWithoutCreatedContestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedContestsInput, UserUpdateWithoutCreatedContestsInput>, UserUncheckedUpdateWithoutCreatedContestsInput>
  }

  export type ContestParticipantUpdateManyWithoutContestNestedInput = {
    create?: XOR<ContestParticipantCreateWithoutContestInput, ContestParticipantUncheckedCreateWithoutContestInput> | ContestParticipantCreateWithoutContestInput[] | ContestParticipantUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutContestInput | ContestParticipantCreateOrConnectWithoutContestInput[]
    upsert?: ContestParticipantUpsertWithWhereUniqueWithoutContestInput | ContestParticipantUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: ContestParticipantCreateManyContestInputEnvelope
    set?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    disconnect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    delete?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    connect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    update?: ContestParticipantUpdateWithWhereUniqueWithoutContestInput | ContestParticipantUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: ContestParticipantUpdateManyWithWhereWithoutContestInput | ContestParticipantUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: ContestParticipantScalarWhereInput | ContestParticipantScalarWhereInput[]
  }

  export type VoteUpdateManyWithoutContestNestedInput = {
    create?: XOR<VoteCreateWithoutContestInput, VoteUncheckedCreateWithoutContestInput> | VoteCreateWithoutContestInput[] | VoteUncheckedCreateWithoutContestInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutContestInput | VoteCreateOrConnectWithoutContestInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutContestInput | VoteUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: VoteCreateManyContestInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutContestInput | VoteUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutContestInput | VoteUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type ContestRuleUpdateManyWithoutContestNestedInput = {
    create?: XOR<ContestRuleCreateWithoutContestInput, ContestRuleUncheckedCreateWithoutContestInput> | ContestRuleCreateWithoutContestInput[] | ContestRuleUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestRuleCreateOrConnectWithoutContestInput | ContestRuleCreateOrConnectWithoutContestInput[]
    upsert?: ContestRuleUpsertWithWhereUniqueWithoutContestInput | ContestRuleUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: ContestRuleCreateManyContestInputEnvelope
    set?: ContestRuleWhereUniqueInput | ContestRuleWhereUniqueInput[]
    disconnect?: ContestRuleWhereUniqueInput | ContestRuleWhereUniqueInput[]
    delete?: ContestRuleWhereUniqueInput | ContestRuleWhereUniqueInput[]
    connect?: ContestRuleWhereUniqueInput | ContestRuleWhereUniqueInput[]
    update?: ContestRuleUpdateWithWhereUniqueWithoutContestInput | ContestRuleUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: ContestRuleUpdateManyWithWhereWithoutContestInput | ContestRuleUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: ContestRuleScalarWhereInput | ContestRuleScalarWhereInput[]
  }

  export type ContestPrizeUpdateManyWithoutContestNestedInput = {
    create?: XOR<ContestPrizeCreateWithoutContestInput, ContestPrizeUncheckedCreateWithoutContestInput> | ContestPrizeCreateWithoutContestInput[] | ContestPrizeUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestPrizeCreateOrConnectWithoutContestInput | ContestPrizeCreateOrConnectWithoutContestInput[]
    upsert?: ContestPrizeUpsertWithWhereUniqueWithoutContestInput | ContestPrizeUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: ContestPrizeCreateManyContestInputEnvelope
    set?: ContestPrizeWhereUniqueInput | ContestPrizeWhereUniqueInput[]
    disconnect?: ContestPrizeWhereUniqueInput | ContestPrizeWhereUniqueInput[]
    delete?: ContestPrizeWhereUniqueInput | ContestPrizeWhereUniqueInput[]
    connect?: ContestPrizeWhereUniqueInput | ContestPrizeWhereUniqueInput[]
    update?: ContestPrizeUpdateWithWhereUniqueWithoutContestInput | ContestPrizeUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: ContestPrizeUpdateManyWithWhereWithoutContestInput | ContestPrizeUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: ContestPrizeScalarWhereInput | ContestPrizeScalarWhereInput[]
  }

  export type RecurringContestDataUpdateOneWithoutContestNestedInput = {
    create?: XOR<RecurringContestDataCreateWithoutContestInput, RecurringContestDataUncheckedCreateWithoutContestInput>
    connectOrCreate?: RecurringContestDataCreateOrConnectWithoutContestInput
    upsert?: RecurringContestDataUpsertWithoutContestInput
    disconnect?: RecurringContestDataWhereInput | boolean
    delete?: RecurringContestDataWhereInput | boolean
    connect?: RecurringContestDataWhereUniqueInput
    update?: XOR<XOR<RecurringContestDataUpdateToOneWithWhereWithoutContestInput, RecurringContestDataUpdateWithoutContestInput>, RecurringContestDataUncheckedUpdateWithoutContestInput>
  }

  export type ContestParticipantUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<ContestParticipantCreateWithoutContestInput, ContestParticipantUncheckedCreateWithoutContestInput> | ContestParticipantCreateWithoutContestInput[] | ContestParticipantUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutContestInput | ContestParticipantCreateOrConnectWithoutContestInput[]
    upsert?: ContestParticipantUpsertWithWhereUniqueWithoutContestInput | ContestParticipantUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: ContestParticipantCreateManyContestInputEnvelope
    set?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    disconnect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    delete?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    connect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    update?: ContestParticipantUpdateWithWhereUniqueWithoutContestInput | ContestParticipantUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: ContestParticipantUpdateManyWithWhereWithoutContestInput | ContestParticipantUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: ContestParticipantScalarWhereInput | ContestParticipantScalarWhereInput[]
  }

  export type VoteUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<VoteCreateWithoutContestInput, VoteUncheckedCreateWithoutContestInput> | VoteCreateWithoutContestInput[] | VoteUncheckedCreateWithoutContestInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutContestInput | VoteCreateOrConnectWithoutContestInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutContestInput | VoteUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: VoteCreateManyContestInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutContestInput | VoteUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutContestInput | VoteUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type ContestRuleUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<ContestRuleCreateWithoutContestInput, ContestRuleUncheckedCreateWithoutContestInput> | ContestRuleCreateWithoutContestInput[] | ContestRuleUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestRuleCreateOrConnectWithoutContestInput | ContestRuleCreateOrConnectWithoutContestInput[]
    upsert?: ContestRuleUpsertWithWhereUniqueWithoutContestInput | ContestRuleUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: ContestRuleCreateManyContestInputEnvelope
    set?: ContestRuleWhereUniqueInput | ContestRuleWhereUniqueInput[]
    disconnect?: ContestRuleWhereUniqueInput | ContestRuleWhereUniqueInput[]
    delete?: ContestRuleWhereUniqueInput | ContestRuleWhereUniqueInput[]
    connect?: ContestRuleWhereUniqueInput | ContestRuleWhereUniqueInput[]
    update?: ContestRuleUpdateWithWhereUniqueWithoutContestInput | ContestRuleUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: ContestRuleUpdateManyWithWhereWithoutContestInput | ContestRuleUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: ContestRuleScalarWhereInput | ContestRuleScalarWhereInput[]
  }

  export type ContestPrizeUncheckedUpdateManyWithoutContestNestedInput = {
    create?: XOR<ContestPrizeCreateWithoutContestInput, ContestPrizeUncheckedCreateWithoutContestInput> | ContestPrizeCreateWithoutContestInput[] | ContestPrizeUncheckedCreateWithoutContestInput[]
    connectOrCreate?: ContestPrizeCreateOrConnectWithoutContestInput | ContestPrizeCreateOrConnectWithoutContestInput[]
    upsert?: ContestPrizeUpsertWithWhereUniqueWithoutContestInput | ContestPrizeUpsertWithWhereUniqueWithoutContestInput[]
    createMany?: ContestPrizeCreateManyContestInputEnvelope
    set?: ContestPrizeWhereUniqueInput | ContestPrizeWhereUniqueInput[]
    disconnect?: ContestPrizeWhereUniqueInput | ContestPrizeWhereUniqueInput[]
    delete?: ContestPrizeWhereUniqueInput | ContestPrizeWhereUniqueInput[]
    connect?: ContestPrizeWhereUniqueInput | ContestPrizeWhereUniqueInput[]
    update?: ContestPrizeUpdateWithWhereUniqueWithoutContestInput | ContestPrizeUpdateWithWhereUniqueWithoutContestInput[]
    updateMany?: ContestPrizeUpdateManyWithWhereWithoutContestInput | ContestPrizeUpdateManyWithWhereWithoutContestInput[]
    deleteMany?: ContestPrizeScalarWhereInput | ContestPrizeScalarWhereInput[]
  }

  export type RecurringContestDataUncheckedUpdateOneWithoutContestNestedInput = {
    create?: XOR<RecurringContestDataCreateWithoutContestInput, RecurringContestDataUncheckedCreateWithoutContestInput>
    connectOrCreate?: RecurringContestDataCreateOrConnectWithoutContestInput
    upsert?: RecurringContestDataUpsertWithoutContestInput
    disconnect?: RecurringContestDataWhereInput | boolean
    delete?: RecurringContestDataWhereInput | boolean
    connect?: RecurringContestDataWhereUniqueInput
    update?: XOR<XOR<RecurringContestDataUpdateToOneWithWhereWithoutContestInput, RecurringContestDataUpdateWithoutContestInput>, RecurringContestDataUncheckedUpdateWithoutContestInput>
  }

  export type ContestCreateNestedOneWithoutContestRulesInput = {
    create?: XOR<ContestCreateWithoutContestRulesInput, ContestUncheckedCreateWithoutContestRulesInput>
    connectOrCreate?: ContestCreateOrConnectWithoutContestRulesInput
    connect?: ContestWhereUniqueInput
  }

  export type ContestUpdateOneRequiredWithoutContestRulesNestedInput = {
    create?: XOR<ContestCreateWithoutContestRulesInput, ContestUncheckedCreateWithoutContestRulesInput>
    connectOrCreate?: ContestCreateOrConnectWithoutContestRulesInput
    upsert?: ContestUpsertWithoutContestRulesInput
    connect?: ContestWhereUniqueInput
    update?: XOR<XOR<ContestUpdateToOneWithWhereWithoutContestRulesInput, ContestUpdateWithoutContestRulesInput>, ContestUncheckedUpdateWithoutContestRulesInput>
  }

  export type ContestCreateNestedOneWithoutRecurringDataInput = {
    create?: XOR<ContestCreateWithoutRecurringDataInput, ContestUncheckedCreateWithoutRecurringDataInput>
    connectOrCreate?: ContestCreateOrConnectWithoutRecurringDataInput
    connect?: ContestWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type ContestUpdateOneRequiredWithoutRecurringDataNestedInput = {
    create?: XOR<ContestCreateWithoutRecurringDataInput, ContestUncheckedCreateWithoutRecurringDataInput>
    connectOrCreate?: ContestCreateOrConnectWithoutRecurringDataInput
    upsert?: ContestUpsertWithoutRecurringDataInput
    connect?: ContestWhereUniqueInput
    update?: XOR<XOR<ContestUpdateToOneWithWhereWithoutRecurringDataInput, ContestUpdateWithoutRecurringDataInput>, ContestUncheckedUpdateWithoutRecurringDataInput>
  }

  export type RecurringDataCreateEnvelopeInput = {
    set?: RecurringDataCreateInput
  }

  export type RecurringDataCreateInput = {
    recurringType: $Enums.RecurringType
    previousOccurrence: Date | string
    nextOccurrence: Date | string
    duration?: number
  }

  export type RecurringDataUpdateEnvelopeInput = {
    set?: RecurringDataCreateInput
    update?: RecurringDataUpdateInput
  }

  export type ContestParticipantCreateNestedOneWithoutPhotosInput = {
    create?: XOR<ContestParticipantCreateWithoutPhotosInput, ContestParticipantUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutPhotosInput
    connect?: ContestParticipantWhereUniqueInput
  }

  export type VoteCreateNestedManyWithoutPhotoInput = {
    create?: XOR<VoteCreateWithoutPhotoInput, VoteUncheckedCreateWithoutPhotoInput> | VoteCreateWithoutPhotoInput[] | VoteUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutPhotoInput | VoteCreateOrConnectWithoutPhotoInput[]
    createMany?: VoteCreateManyPhotoInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type UserPhotoCreateNestedOneWithoutContestUploadInput = {
    create?: XOR<UserPhotoCreateWithoutContestUploadInput, UserPhotoUncheckedCreateWithoutContestUploadInput>
    connectOrCreate?: UserPhotoCreateOrConnectWithoutContestUploadInput
    connect?: UserPhotoWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutReceiverInput = {
    create?: XOR<CommentCreateWithoutReceiverInput, CommentUncheckedCreateWithoutReceiverInput> | CommentCreateWithoutReceiverInput[] | CommentUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutReceiverInput | CommentCreateOrConnectWithoutReceiverInput[]
    createMany?: CommentCreateManyReceiverInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ContestAchievementCreateNestedManyWithoutPhotoInput = {
    create?: XOR<ContestAchievementCreateWithoutPhotoInput, ContestAchievementUncheckedCreateWithoutPhotoInput> | ContestAchievementCreateWithoutPhotoInput[] | ContestAchievementUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestAchievementCreateOrConnectWithoutPhotoInput | ContestAchievementCreateOrConnectWithoutPhotoInput[]
    createMany?: ContestAchievementCreateManyPhotoInputEnvelope
    connect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
  }

  export type ContestWinnerCreateNestedManyWithoutPhotoInput = {
    create?: XOR<ContestWinnerCreateWithoutPhotoInput, ContestWinnerUncheckedCreateWithoutPhotoInput> | ContestWinnerCreateWithoutPhotoInput[] | ContestWinnerUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestWinnerCreateOrConnectWithoutPhotoInput | ContestWinnerCreateOrConnectWithoutPhotoInput[]
    createMany?: ContestWinnerCreateManyPhotoInputEnvelope
    connect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
  }

  export type VoteUncheckedCreateNestedManyWithoutPhotoInput = {
    create?: XOR<VoteCreateWithoutPhotoInput, VoteUncheckedCreateWithoutPhotoInput> | VoteCreateWithoutPhotoInput[] | VoteUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutPhotoInput | VoteCreateOrConnectWithoutPhotoInput[]
    createMany?: VoteCreateManyPhotoInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<CommentCreateWithoutReceiverInput, CommentUncheckedCreateWithoutReceiverInput> | CommentCreateWithoutReceiverInput[] | CommentUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutReceiverInput | CommentCreateOrConnectWithoutReceiverInput[]
    createMany?: CommentCreateManyReceiverInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ContestAchievementUncheckedCreateNestedManyWithoutPhotoInput = {
    create?: XOR<ContestAchievementCreateWithoutPhotoInput, ContestAchievementUncheckedCreateWithoutPhotoInput> | ContestAchievementCreateWithoutPhotoInput[] | ContestAchievementUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestAchievementCreateOrConnectWithoutPhotoInput | ContestAchievementCreateOrConnectWithoutPhotoInput[]
    createMany?: ContestAchievementCreateManyPhotoInputEnvelope
    connect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
  }

  export type ContestWinnerUncheckedCreateNestedManyWithoutPhotoInput = {
    create?: XOR<ContestWinnerCreateWithoutPhotoInput, ContestWinnerUncheckedCreateWithoutPhotoInput> | ContestWinnerCreateWithoutPhotoInput[] | ContestWinnerUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestWinnerCreateOrConnectWithoutPhotoInput | ContestWinnerCreateOrConnectWithoutPhotoInput[]
    createMany?: ContestWinnerCreateManyPhotoInputEnvelope
    connect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
  }

  export type ContestParticipantUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<ContestParticipantCreateWithoutPhotosInput, ContestParticipantUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutPhotosInput
    upsert?: ContestParticipantUpsertWithoutPhotosInput
    connect?: ContestParticipantWhereUniqueInput
    update?: XOR<XOR<ContestParticipantUpdateToOneWithWhereWithoutPhotosInput, ContestParticipantUpdateWithoutPhotosInput>, ContestParticipantUncheckedUpdateWithoutPhotosInput>
  }

  export type VoteUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<VoteCreateWithoutPhotoInput, VoteUncheckedCreateWithoutPhotoInput> | VoteCreateWithoutPhotoInput[] | VoteUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutPhotoInput | VoteCreateOrConnectWithoutPhotoInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutPhotoInput | VoteUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: VoteCreateManyPhotoInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutPhotoInput | VoteUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutPhotoInput | VoteUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type UserPhotoUpdateOneRequiredWithoutContestUploadNestedInput = {
    create?: XOR<UserPhotoCreateWithoutContestUploadInput, UserPhotoUncheckedCreateWithoutContestUploadInput>
    connectOrCreate?: UserPhotoCreateOrConnectWithoutContestUploadInput
    upsert?: UserPhotoUpsertWithoutContestUploadInput
    connect?: UserPhotoWhereUniqueInput
    update?: XOR<XOR<UserPhotoUpdateToOneWithWhereWithoutContestUploadInput, UserPhotoUpdateWithoutContestUploadInput>, UserPhotoUncheckedUpdateWithoutContestUploadInput>
  }

  export type CommentUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<CommentCreateWithoutReceiverInput, CommentUncheckedCreateWithoutReceiverInput> | CommentCreateWithoutReceiverInput[] | CommentUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutReceiverInput | CommentCreateOrConnectWithoutReceiverInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutReceiverInput | CommentUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: CommentCreateManyReceiverInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutReceiverInput | CommentUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutReceiverInput | CommentUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ContestAchievementUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<ContestAchievementCreateWithoutPhotoInput, ContestAchievementUncheckedCreateWithoutPhotoInput> | ContestAchievementCreateWithoutPhotoInput[] | ContestAchievementUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestAchievementCreateOrConnectWithoutPhotoInput | ContestAchievementCreateOrConnectWithoutPhotoInput[]
    upsert?: ContestAchievementUpsertWithWhereUniqueWithoutPhotoInput | ContestAchievementUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: ContestAchievementCreateManyPhotoInputEnvelope
    set?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    disconnect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    delete?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    connect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    update?: ContestAchievementUpdateWithWhereUniqueWithoutPhotoInput | ContestAchievementUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: ContestAchievementUpdateManyWithWhereWithoutPhotoInput | ContestAchievementUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: ContestAchievementScalarWhereInput | ContestAchievementScalarWhereInput[]
  }

  export type ContestWinnerUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<ContestWinnerCreateWithoutPhotoInput, ContestWinnerUncheckedCreateWithoutPhotoInput> | ContestWinnerCreateWithoutPhotoInput[] | ContestWinnerUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestWinnerCreateOrConnectWithoutPhotoInput | ContestWinnerCreateOrConnectWithoutPhotoInput[]
    upsert?: ContestWinnerUpsertWithWhereUniqueWithoutPhotoInput | ContestWinnerUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: ContestWinnerCreateManyPhotoInputEnvelope
    set?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    disconnect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    delete?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    connect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    update?: ContestWinnerUpdateWithWhereUniqueWithoutPhotoInput | ContestWinnerUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: ContestWinnerUpdateManyWithWhereWithoutPhotoInput | ContestWinnerUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: ContestWinnerScalarWhereInput | ContestWinnerScalarWhereInput[]
  }

  export type VoteUncheckedUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<VoteCreateWithoutPhotoInput, VoteUncheckedCreateWithoutPhotoInput> | VoteCreateWithoutPhotoInput[] | VoteUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutPhotoInput | VoteCreateOrConnectWithoutPhotoInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutPhotoInput | VoteUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: VoteCreateManyPhotoInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutPhotoInput | VoteUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutPhotoInput | VoteUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<CommentCreateWithoutReceiverInput, CommentUncheckedCreateWithoutReceiverInput> | CommentCreateWithoutReceiverInput[] | CommentUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutReceiverInput | CommentCreateOrConnectWithoutReceiverInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutReceiverInput | CommentUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: CommentCreateManyReceiverInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutReceiverInput | CommentUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutReceiverInput | CommentUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ContestAchievementUncheckedUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<ContestAchievementCreateWithoutPhotoInput, ContestAchievementUncheckedCreateWithoutPhotoInput> | ContestAchievementCreateWithoutPhotoInput[] | ContestAchievementUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestAchievementCreateOrConnectWithoutPhotoInput | ContestAchievementCreateOrConnectWithoutPhotoInput[]
    upsert?: ContestAchievementUpsertWithWhereUniqueWithoutPhotoInput | ContestAchievementUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: ContestAchievementCreateManyPhotoInputEnvelope
    set?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    disconnect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    delete?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    connect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    update?: ContestAchievementUpdateWithWhereUniqueWithoutPhotoInput | ContestAchievementUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: ContestAchievementUpdateManyWithWhereWithoutPhotoInput | ContestAchievementUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: ContestAchievementScalarWhereInput | ContestAchievementScalarWhereInput[]
  }

  export type ContestWinnerUncheckedUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<ContestWinnerCreateWithoutPhotoInput, ContestWinnerUncheckedCreateWithoutPhotoInput> | ContestWinnerCreateWithoutPhotoInput[] | ContestWinnerUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestWinnerCreateOrConnectWithoutPhotoInput | ContestWinnerCreateOrConnectWithoutPhotoInput[]
    upsert?: ContestWinnerUpsertWithWhereUniqueWithoutPhotoInput | ContestWinnerUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: ContestWinnerCreateManyPhotoInputEnvelope
    set?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    disconnect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    delete?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    connect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    update?: ContestWinnerUpdateWithWhereUniqueWithoutPhotoInput | ContestWinnerUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: ContestWinnerUpdateManyWithWhereWithoutPhotoInput | ContestWinnerUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: ContestWinnerScalarWhereInput | ContestWinnerScalarWhereInput[]
  }

  export type ContestParticipantCreateNestedOneWithoutContestWinnerInput = {
    create?: XOR<ContestParticipantCreateWithoutContestWinnerInput, ContestParticipantUncheckedCreateWithoutContestWinnerInput>
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutContestWinnerInput
    connect?: ContestParticipantWhereUniqueInput
  }

  export type ContestPhotoCreateNestedOneWithoutContestWinnerInput = {
    create?: XOR<ContestPhotoCreateWithoutContestWinnerInput, ContestPhotoUncheckedCreateWithoutContestWinnerInput>
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutContestWinnerInput
    connect?: ContestPhotoWhereUniqueInput
  }

  export type ContestParticipantUpdateOneRequiredWithoutContestWinnerNestedInput = {
    create?: XOR<ContestParticipantCreateWithoutContestWinnerInput, ContestParticipantUncheckedCreateWithoutContestWinnerInput>
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutContestWinnerInput
    upsert?: ContestParticipantUpsertWithoutContestWinnerInput
    connect?: ContestParticipantWhereUniqueInput
    update?: XOR<XOR<ContestParticipantUpdateToOneWithWhereWithoutContestWinnerInput, ContestParticipantUpdateWithoutContestWinnerInput>, ContestParticipantUncheckedUpdateWithoutContestWinnerInput>
  }

  export type ContestPhotoUpdateOneRequiredWithoutContestWinnerNestedInput = {
    create?: XOR<ContestPhotoCreateWithoutContestWinnerInput, ContestPhotoUncheckedCreateWithoutContestWinnerInput>
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutContestWinnerInput
    upsert?: ContestPhotoUpsertWithoutContestWinnerInput
    connect?: ContestPhotoWhereUniqueInput
    update?: XOR<XOR<ContestPhotoUpdateToOneWithWhereWithoutContestWinnerInput, ContestPhotoUpdateWithoutContestWinnerInput>, ContestPhotoUncheckedUpdateWithoutContestWinnerInput>
  }

  export type ContestCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<ContestCreateWithoutParticipantsInput, ContestUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ContestCreateOrConnectWithoutParticipantsInput
    connect?: ContestWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutContestParticipantInput = {
    create?: XOR<UserCreateWithoutContestParticipantInput, UserUncheckedCreateWithoutContestParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutContestParticipantInput
    connect?: UserWhereUniqueInput
  }

  export type ContestPhotoCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ContestPhotoCreateWithoutParticipantInput, ContestPhotoUncheckedCreateWithoutParticipantInput> | ContestPhotoCreateWithoutParticipantInput[] | ContestPhotoUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutParticipantInput | ContestPhotoCreateOrConnectWithoutParticipantInput[]
    createMany?: ContestPhotoCreateManyParticipantInputEnvelope
    connect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
  }

  export type ContestWinnerCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ContestWinnerCreateWithoutParticipantInput, ContestWinnerUncheckedCreateWithoutParticipantInput> | ContestWinnerCreateWithoutParticipantInput[] | ContestWinnerUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestWinnerCreateOrConnectWithoutParticipantInput | ContestWinnerCreateOrConnectWithoutParticipantInput[]
    createMany?: ContestWinnerCreateManyParticipantInputEnvelope
    connect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
  }

  export type ContestAchievementCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ContestAchievementCreateWithoutParticipantInput, ContestAchievementUncheckedCreateWithoutParticipantInput> | ContestAchievementCreateWithoutParticipantInput[] | ContestAchievementUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestAchievementCreateOrConnectWithoutParticipantInput | ContestAchievementCreateOrConnectWithoutParticipantInput[]
    createMany?: ContestAchievementCreateManyParticipantInputEnvelope
    connect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
  }

  export type ContestPhotoUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ContestPhotoCreateWithoutParticipantInput, ContestPhotoUncheckedCreateWithoutParticipantInput> | ContestPhotoCreateWithoutParticipantInput[] | ContestPhotoUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutParticipantInput | ContestPhotoCreateOrConnectWithoutParticipantInput[]
    createMany?: ContestPhotoCreateManyParticipantInputEnvelope
    connect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
  }

  export type ContestWinnerUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ContestWinnerCreateWithoutParticipantInput, ContestWinnerUncheckedCreateWithoutParticipantInput> | ContestWinnerCreateWithoutParticipantInput[] | ContestWinnerUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestWinnerCreateOrConnectWithoutParticipantInput | ContestWinnerCreateOrConnectWithoutParticipantInput[]
    createMany?: ContestWinnerCreateManyParticipantInputEnvelope
    connect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
  }

  export type ContestAchievementUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ContestAchievementCreateWithoutParticipantInput, ContestAchievementUncheckedCreateWithoutParticipantInput> | ContestAchievementCreateWithoutParticipantInput[] | ContestAchievementUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestAchievementCreateOrConnectWithoutParticipantInput | ContestAchievementCreateOrConnectWithoutParticipantInput[]
    createMany?: ContestAchievementCreateManyParticipantInputEnvelope
    connect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
  }

  export type EnumContestParticipantStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContestParticipantStatus
  }

  export type EnumContestLevelFieldUpdateOperationsInput = {
    set?: $Enums.ContestLevel
  }

  export type ContestUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<ContestCreateWithoutParticipantsInput, ContestUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ContestCreateOrConnectWithoutParticipantsInput
    upsert?: ContestUpsertWithoutParticipantsInput
    connect?: ContestWhereUniqueInput
    update?: XOR<XOR<ContestUpdateToOneWithWhereWithoutParticipantsInput, ContestUpdateWithoutParticipantsInput>, ContestUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutContestParticipantNestedInput = {
    create?: XOR<UserCreateWithoutContestParticipantInput, UserUncheckedCreateWithoutContestParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutContestParticipantInput
    upsert?: UserUpsertWithoutContestParticipantInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContestParticipantInput, UserUpdateWithoutContestParticipantInput>, UserUncheckedUpdateWithoutContestParticipantInput>
  }

  export type ContestPhotoUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ContestPhotoCreateWithoutParticipantInput, ContestPhotoUncheckedCreateWithoutParticipantInput> | ContestPhotoCreateWithoutParticipantInput[] | ContestPhotoUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutParticipantInput | ContestPhotoCreateOrConnectWithoutParticipantInput[]
    upsert?: ContestPhotoUpsertWithWhereUniqueWithoutParticipantInput | ContestPhotoUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ContestPhotoCreateManyParticipantInputEnvelope
    set?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    disconnect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    delete?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    connect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    update?: ContestPhotoUpdateWithWhereUniqueWithoutParticipantInput | ContestPhotoUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ContestPhotoUpdateManyWithWhereWithoutParticipantInput | ContestPhotoUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ContestPhotoScalarWhereInput | ContestPhotoScalarWhereInput[]
  }

  export type ContestWinnerUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ContestWinnerCreateWithoutParticipantInput, ContestWinnerUncheckedCreateWithoutParticipantInput> | ContestWinnerCreateWithoutParticipantInput[] | ContestWinnerUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestWinnerCreateOrConnectWithoutParticipantInput | ContestWinnerCreateOrConnectWithoutParticipantInput[]
    upsert?: ContestWinnerUpsertWithWhereUniqueWithoutParticipantInput | ContestWinnerUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ContestWinnerCreateManyParticipantInputEnvelope
    set?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    disconnect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    delete?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    connect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    update?: ContestWinnerUpdateWithWhereUniqueWithoutParticipantInput | ContestWinnerUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ContestWinnerUpdateManyWithWhereWithoutParticipantInput | ContestWinnerUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ContestWinnerScalarWhereInput | ContestWinnerScalarWhereInput[]
  }

  export type ContestAchievementUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ContestAchievementCreateWithoutParticipantInput, ContestAchievementUncheckedCreateWithoutParticipantInput> | ContestAchievementCreateWithoutParticipantInput[] | ContestAchievementUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestAchievementCreateOrConnectWithoutParticipantInput | ContestAchievementCreateOrConnectWithoutParticipantInput[]
    upsert?: ContestAchievementUpsertWithWhereUniqueWithoutParticipantInput | ContestAchievementUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ContestAchievementCreateManyParticipantInputEnvelope
    set?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    disconnect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    delete?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    connect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    update?: ContestAchievementUpdateWithWhereUniqueWithoutParticipantInput | ContestAchievementUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ContestAchievementUpdateManyWithWhereWithoutParticipantInput | ContestAchievementUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ContestAchievementScalarWhereInput | ContestAchievementScalarWhereInput[]
  }

  export type ContestPhotoUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ContestPhotoCreateWithoutParticipantInput, ContestPhotoUncheckedCreateWithoutParticipantInput> | ContestPhotoCreateWithoutParticipantInput[] | ContestPhotoUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutParticipantInput | ContestPhotoCreateOrConnectWithoutParticipantInput[]
    upsert?: ContestPhotoUpsertWithWhereUniqueWithoutParticipantInput | ContestPhotoUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ContestPhotoCreateManyParticipantInputEnvelope
    set?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    disconnect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    delete?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    connect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    update?: ContestPhotoUpdateWithWhereUniqueWithoutParticipantInput | ContestPhotoUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ContestPhotoUpdateManyWithWhereWithoutParticipantInput | ContestPhotoUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ContestPhotoScalarWhereInput | ContestPhotoScalarWhereInput[]
  }

  export type ContestWinnerUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ContestWinnerCreateWithoutParticipantInput, ContestWinnerUncheckedCreateWithoutParticipantInput> | ContestWinnerCreateWithoutParticipantInput[] | ContestWinnerUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestWinnerCreateOrConnectWithoutParticipantInput | ContestWinnerCreateOrConnectWithoutParticipantInput[]
    upsert?: ContestWinnerUpsertWithWhereUniqueWithoutParticipantInput | ContestWinnerUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ContestWinnerCreateManyParticipantInputEnvelope
    set?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    disconnect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    delete?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    connect?: ContestWinnerWhereUniqueInput | ContestWinnerWhereUniqueInput[]
    update?: ContestWinnerUpdateWithWhereUniqueWithoutParticipantInput | ContestWinnerUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ContestWinnerUpdateManyWithWhereWithoutParticipantInput | ContestWinnerUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ContestWinnerScalarWhereInput | ContestWinnerScalarWhereInput[]
  }

  export type ContestAchievementUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ContestAchievementCreateWithoutParticipantInput, ContestAchievementUncheckedCreateWithoutParticipantInput> | ContestAchievementCreateWithoutParticipantInput[] | ContestAchievementUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ContestAchievementCreateOrConnectWithoutParticipantInput | ContestAchievementCreateOrConnectWithoutParticipantInput[]
    upsert?: ContestAchievementUpsertWithWhereUniqueWithoutParticipantInput | ContestAchievementUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ContestAchievementCreateManyParticipantInputEnvelope
    set?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    disconnect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    delete?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    connect?: ContestAchievementWhereUniqueInput | ContestAchievementWhereUniqueInput[]
    update?: ContestAchievementUpdateWithWhereUniqueWithoutParticipantInput | ContestAchievementUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ContestAchievementUpdateManyWithWhereWithoutParticipantInput | ContestAchievementUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ContestAchievementScalarWhereInput | ContestAchievementScalarWhereInput[]
  }

  export type ContestCreateNestedOneWithoutContestPrizesInput = {
    create?: XOR<ContestCreateWithoutContestPrizesInput, ContestUncheckedCreateWithoutContestPrizesInput>
    connectOrCreate?: ContestCreateOrConnectWithoutContestPrizesInput
    connect?: ContestWhereUniqueInput
  }

  export type EnumPrizeTypeFieldUpdateOperationsInput = {
    set?: $Enums.PrizeType
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ContestUpdateOneRequiredWithoutContestPrizesNestedInput = {
    create?: XOR<ContestCreateWithoutContestPrizesInput, ContestUncheckedCreateWithoutContestPrizesInput>
    connectOrCreate?: ContestCreateOrConnectWithoutContestPrizesInput
    upsert?: ContestUpsertWithoutContestPrizesInput
    connect?: ContestWhereUniqueInput
    update?: XOR<XOR<ContestUpdateToOneWithWhereWithoutContestPrizesInput, ContestUpdateWithoutContestPrizesInput>, ContestUncheckedUpdateWithoutContestPrizesInput>
  }

  export type ContestPhotoCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<ContestPhotoCreateWithoutAchievementsInput, ContestPhotoUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutAchievementsInput
    connect?: ContestPhotoWhereUniqueInput
  }

  export type ContestParticipantCreateNestedOneWithoutContestAchievementInput = {
    create?: XOR<ContestParticipantCreateWithoutContestAchievementInput, ContestParticipantUncheckedCreateWithoutContestAchievementInput>
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutContestAchievementInput
    connect?: ContestParticipantWhereUniqueInput
  }

  export type ContestPhotoUpdateOneWithoutAchievementsNestedInput = {
    create?: XOR<ContestPhotoCreateWithoutAchievementsInput, ContestPhotoUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutAchievementsInput
    upsert?: ContestPhotoUpsertWithoutAchievementsInput
    disconnect?: boolean
    delete?: ContestPhotoWhereInput | boolean
    connect?: ContestPhotoWhereUniqueInput
    update?: XOR<XOR<ContestPhotoUpdateToOneWithWhereWithoutAchievementsInput, ContestPhotoUpdateWithoutAchievementsInput>, ContestPhotoUncheckedUpdateWithoutAchievementsInput>
  }

  export type ContestParticipantUpdateOneWithoutContestAchievementNestedInput = {
    create?: XOR<ContestParticipantCreateWithoutContestAchievementInput, ContestParticipantUncheckedCreateWithoutContestAchievementInput>
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutContestAchievementInput
    upsert?: ContestParticipantUpsertWithoutContestAchievementInput
    disconnect?: boolean
    delete?: ContestParticipantWhereInput | boolean
    connect?: ContestParticipantWhereUniqueInput
    update?: XOR<XOR<ContestParticipantUpdateToOneWithWhereWithoutContestAchievementInput, ContestParticipantUpdateWithoutContestAchievementInput>, ContestParticipantUncheckedUpdateWithoutContestAchievementInput>
  }

  export type UserCreateNestedOneWithoutCreatedTeamInput = {
    create?: XOR<UserCreateWithoutCreatedTeamInput, UserUncheckedCreateWithoutCreatedTeamInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTeamInput
    connect?: UserWhereUniqueInput
  }

  export type TeamMemberCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type EnumTeamAccessibilityFieldUpdateOperationsInput = {
    set?: $Enums.TeamAccessibility
  }

  export type UserUpdateOneRequiredWithoutCreatedTeamNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTeamInput, UserUncheckedCreateWithoutCreatedTeamInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTeamInput
    upsert?: UserUpsertWithoutCreatedTeamInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTeamInput, UserUpdateWithoutCreatedTeamInput>, UserUncheckedUpdateWithoutCreatedTeamInput>
  }

  export type TeamMemberUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutJoinedTeamInput = {
    create?: XOR<UserCreateWithoutJoinedTeamInput, UserUncheckedCreateWithoutJoinedTeamInput>
    connectOrCreate?: UserCreateOrConnectWithoutJoinedTeamInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTeamMemberStatusFieldUpdateOperationsInput = {
    set?: $Enums.TeamMemberStatus
  }

  export type TeamUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    upsert?: TeamUpsertWithoutMembersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMembersInput, TeamUpdateWithoutMembersInput>, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutJoinedTeamNestedInput = {
    create?: XOR<UserCreateWithoutJoinedTeamInput, UserUncheckedCreateWithoutJoinedTeamInput>
    connectOrCreate?: UserCreateOrConnectWithoutJoinedTeamInput
    upsert?: UserUpsertWithoutJoinedTeamInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJoinedTeamInput, UserUpdateWithoutJoinedTeamInput>, UserUncheckedUpdateWithoutJoinedTeamInput>
  }

  export type OtpCreateNestedOneWithoutUserInput = {
    create?: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput>
    connectOrCreate?: OtpCreateOrConnectWithoutUserInput
    connect?: OtpWhereUniqueInput
  }

  export type TeamCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TeamCreateWithoutCreatorInput, TeamUncheckedCreateWithoutCreatorInput> | TeamCreateWithoutCreatorInput[] | TeamUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCreatorInput | TeamCreateOrConnectWithoutCreatorInput[]
    createMany?: TeamCreateManyCreatorInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type TeamMemberCreateNestedOneWithoutMemberInput = {
    create?: XOR<TeamMemberCreateWithoutMemberInput, TeamMemberUncheckedCreateWithoutMemberInput>
    connectOrCreate?: TeamMemberCreateOrConnectWithoutMemberInput
    connect?: TeamMemberWhereUniqueInput
  }

  export type ContestCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ContestCreateWithoutCreatorInput, ContestUncheckedCreateWithoutCreatorInput> | ContestCreateWithoutCreatorInput[] | ContestUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ContestCreateOrConnectWithoutCreatorInput | ContestCreateOrConnectWithoutCreatorInput[]
    createMany?: ContestCreateManyCreatorInputEnvelope
    connect?: ContestWhereUniqueInput | ContestWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutProviderInput = {
    create?: XOR<CommentCreateWithoutProviderInput, CommentUncheckedCreateWithoutProviderInput> | CommentCreateWithoutProviderInput[] | CommentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProviderInput | CommentCreateOrConnectWithoutProviderInput[]
    createMany?: CommentCreateManyProviderInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type VoteCreateNestedManyWithoutProviderInput = {
    create?: XOR<VoteCreateWithoutProviderInput, VoteUncheckedCreateWithoutProviderInput> | VoteCreateWithoutProviderInput[] | VoteUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutProviderInput | VoteCreateOrConnectWithoutProviderInput[]
    createMany?: VoteCreateManyProviderInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutProviderInput = {
    create?: XOR<LikeCreateWithoutProviderInput, LikeUncheckedCreateWithoutProviderInput> | LikeCreateWithoutProviderInput[] | LikeUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutProviderInput | LikeCreateOrConnectWithoutProviderInput[]
    createMany?: LikeCreateManyProviderInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type UserPhotoCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPhotoCreateWithoutUserInput, UserPhotoUncheckedCreateWithoutUserInput> | UserPhotoCreateWithoutUserInput[] | UserPhotoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPhotoCreateOrConnectWithoutUserInput | UserPhotoCreateOrConnectWithoutUserInput[]
    createMany?: UserPhotoCreateManyUserInputEnvelope
    connect?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
  }

  export type ContestParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<ContestParticipantCreateWithoutUserInput, ContestParticipantUncheckedCreateWithoutUserInput> | ContestParticipantCreateWithoutUserInput[] | ContestParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutUserInput | ContestParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ContestParticipantCreateManyUserInputEnvelope
    connect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
  }

  export type OtpUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput>
    connectOrCreate?: OtpCreateOrConnectWithoutUserInput
    connect?: OtpWhereUniqueInput
  }

  export type TeamUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TeamCreateWithoutCreatorInput, TeamUncheckedCreateWithoutCreatorInput> | TeamCreateWithoutCreatorInput[] | TeamUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCreatorInput | TeamCreateOrConnectWithoutCreatorInput[]
    createMany?: TeamCreateManyCreatorInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedOneWithoutMemberInput = {
    create?: XOR<TeamMemberCreateWithoutMemberInput, TeamMemberUncheckedCreateWithoutMemberInput>
    connectOrCreate?: TeamMemberCreateOrConnectWithoutMemberInput
    connect?: TeamMemberWhereUniqueInput
  }

  export type ContestUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ContestCreateWithoutCreatorInput, ContestUncheckedCreateWithoutCreatorInput> | ContestCreateWithoutCreatorInput[] | ContestUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ContestCreateOrConnectWithoutCreatorInput | ContestCreateOrConnectWithoutCreatorInput[]
    createMany?: ContestCreateManyCreatorInputEnvelope
    connect?: ContestWhereUniqueInput | ContestWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<CommentCreateWithoutProviderInput, CommentUncheckedCreateWithoutProviderInput> | CommentCreateWithoutProviderInput[] | CommentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProviderInput | CommentCreateOrConnectWithoutProviderInput[]
    createMany?: CommentCreateManyProviderInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type VoteUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<VoteCreateWithoutProviderInput, VoteUncheckedCreateWithoutProviderInput> | VoteCreateWithoutProviderInput[] | VoteUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutProviderInput | VoteCreateOrConnectWithoutProviderInput[]
    createMany?: VoteCreateManyProviderInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<LikeCreateWithoutProviderInput, LikeUncheckedCreateWithoutProviderInput> | LikeCreateWithoutProviderInput[] | LikeUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutProviderInput | LikeCreateOrConnectWithoutProviderInput[]
    createMany?: LikeCreateManyProviderInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type UserPhotoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPhotoCreateWithoutUserInput, UserPhotoUncheckedCreateWithoutUserInput> | UserPhotoCreateWithoutUserInput[] | UserPhotoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPhotoCreateOrConnectWithoutUserInput | UserPhotoCreateOrConnectWithoutUserInput[]
    createMany?: UserPhotoCreateManyUserInputEnvelope
    connect?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
  }

  export type ContestParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContestParticipantCreateWithoutUserInput, ContestParticipantUncheckedCreateWithoutUserInput> | ContestParticipantCreateWithoutUserInput[] | ContestParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutUserInput | ContestParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ContestParticipantCreateManyUserInputEnvelope
    connect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
  }

  export type NullableEnumUserLevelFieldUpdateOperationsInput = {
    set?: $Enums.UserLevel | null
    unset?: boolean
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type OtpUpdateOneWithoutUserNestedInput = {
    create?: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput>
    connectOrCreate?: OtpCreateOrConnectWithoutUserInput
    upsert?: OtpUpsertWithoutUserInput
    disconnect?: OtpWhereInput | boolean
    delete?: OtpWhereInput | boolean
    connect?: OtpWhereUniqueInput
    update?: XOR<XOR<OtpUpdateToOneWithWhereWithoutUserInput, OtpUpdateWithoutUserInput>, OtpUncheckedUpdateWithoutUserInput>
  }

  export type TeamUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TeamCreateWithoutCreatorInput, TeamUncheckedCreateWithoutCreatorInput> | TeamCreateWithoutCreatorInput[] | TeamUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCreatorInput | TeamCreateOrConnectWithoutCreatorInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutCreatorInput | TeamUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TeamCreateManyCreatorInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutCreatorInput | TeamUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutCreatorInput | TeamUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type TeamMemberUpdateOneWithoutMemberNestedInput = {
    create?: XOR<TeamMemberCreateWithoutMemberInput, TeamMemberUncheckedCreateWithoutMemberInput>
    connectOrCreate?: TeamMemberCreateOrConnectWithoutMemberInput
    upsert?: TeamMemberUpsertWithoutMemberInput
    disconnect?: TeamMemberWhereInput | boolean
    delete?: TeamMemberWhereInput | boolean
    connect?: TeamMemberWhereUniqueInput
    update?: XOR<XOR<TeamMemberUpdateToOneWithWhereWithoutMemberInput, TeamMemberUpdateWithoutMemberInput>, TeamMemberUncheckedUpdateWithoutMemberInput>
  }

  export type ContestUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ContestCreateWithoutCreatorInput, ContestUncheckedCreateWithoutCreatorInput> | ContestCreateWithoutCreatorInput[] | ContestUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ContestCreateOrConnectWithoutCreatorInput | ContestCreateOrConnectWithoutCreatorInput[]
    upsert?: ContestUpsertWithWhereUniqueWithoutCreatorInput | ContestUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ContestCreateManyCreatorInputEnvelope
    set?: ContestWhereUniqueInput | ContestWhereUniqueInput[]
    disconnect?: ContestWhereUniqueInput | ContestWhereUniqueInput[]
    delete?: ContestWhereUniqueInput | ContestWhereUniqueInput[]
    connect?: ContestWhereUniqueInput | ContestWhereUniqueInput[]
    update?: ContestUpdateWithWhereUniqueWithoutCreatorInput | ContestUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ContestUpdateManyWithWhereWithoutCreatorInput | ContestUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ContestScalarWhereInput | ContestScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutProviderNestedInput = {
    create?: XOR<CommentCreateWithoutProviderInput, CommentUncheckedCreateWithoutProviderInput> | CommentCreateWithoutProviderInput[] | CommentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProviderInput | CommentCreateOrConnectWithoutProviderInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutProviderInput | CommentUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: CommentCreateManyProviderInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutProviderInput | CommentUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutProviderInput | CommentUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type VoteUpdateManyWithoutProviderNestedInput = {
    create?: XOR<VoteCreateWithoutProviderInput, VoteUncheckedCreateWithoutProviderInput> | VoteCreateWithoutProviderInput[] | VoteUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutProviderInput | VoteCreateOrConnectWithoutProviderInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutProviderInput | VoteUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: VoteCreateManyProviderInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutProviderInput | VoteUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutProviderInput | VoteUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutProviderNestedInput = {
    create?: XOR<LikeCreateWithoutProviderInput, LikeUncheckedCreateWithoutProviderInput> | LikeCreateWithoutProviderInput[] | LikeUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutProviderInput | LikeCreateOrConnectWithoutProviderInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutProviderInput | LikeUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: LikeCreateManyProviderInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutProviderInput | LikeUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutProviderInput | LikeUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type UserPhotoUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPhotoCreateWithoutUserInput, UserPhotoUncheckedCreateWithoutUserInput> | UserPhotoCreateWithoutUserInput[] | UserPhotoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPhotoCreateOrConnectWithoutUserInput | UserPhotoCreateOrConnectWithoutUserInput[]
    upsert?: UserPhotoUpsertWithWhereUniqueWithoutUserInput | UserPhotoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPhotoCreateManyUserInputEnvelope
    set?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    disconnect?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    delete?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    connect?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    update?: UserPhotoUpdateWithWhereUniqueWithoutUserInput | UserPhotoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPhotoUpdateManyWithWhereWithoutUserInput | UserPhotoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPhotoScalarWhereInput | UserPhotoScalarWhereInput[]
  }

  export type ContestParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContestParticipantCreateWithoutUserInput, ContestParticipantUncheckedCreateWithoutUserInput> | ContestParticipantCreateWithoutUserInput[] | ContestParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutUserInput | ContestParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ContestParticipantUpsertWithWhereUniqueWithoutUserInput | ContestParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContestParticipantCreateManyUserInputEnvelope
    set?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    disconnect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    delete?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    connect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    update?: ContestParticipantUpdateWithWhereUniqueWithoutUserInput | ContestParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContestParticipantUpdateManyWithWhereWithoutUserInput | ContestParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContestParticipantScalarWhereInput | ContestParticipantScalarWhereInput[]
  }

  export type OtpUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput>
    connectOrCreate?: OtpCreateOrConnectWithoutUserInput
    upsert?: OtpUpsertWithoutUserInput
    disconnect?: OtpWhereInput | boolean
    delete?: OtpWhereInput | boolean
    connect?: OtpWhereUniqueInput
    update?: XOR<XOR<OtpUpdateToOneWithWhereWithoutUserInput, OtpUpdateWithoutUserInput>, OtpUncheckedUpdateWithoutUserInput>
  }

  export type TeamUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TeamCreateWithoutCreatorInput, TeamUncheckedCreateWithoutCreatorInput> | TeamCreateWithoutCreatorInput[] | TeamUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCreatorInput | TeamCreateOrConnectWithoutCreatorInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutCreatorInput | TeamUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TeamCreateManyCreatorInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutCreatorInput | TeamUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutCreatorInput | TeamUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateOneWithoutMemberNestedInput = {
    create?: XOR<TeamMemberCreateWithoutMemberInput, TeamMemberUncheckedCreateWithoutMemberInput>
    connectOrCreate?: TeamMemberCreateOrConnectWithoutMemberInput
    upsert?: TeamMemberUpsertWithoutMemberInput
    disconnect?: TeamMemberWhereInput | boolean
    delete?: TeamMemberWhereInput | boolean
    connect?: TeamMemberWhereUniqueInput
    update?: XOR<XOR<TeamMemberUpdateToOneWithWhereWithoutMemberInput, TeamMemberUpdateWithoutMemberInput>, TeamMemberUncheckedUpdateWithoutMemberInput>
  }

  export type ContestUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ContestCreateWithoutCreatorInput, ContestUncheckedCreateWithoutCreatorInput> | ContestCreateWithoutCreatorInput[] | ContestUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ContestCreateOrConnectWithoutCreatorInput | ContestCreateOrConnectWithoutCreatorInput[]
    upsert?: ContestUpsertWithWhereUniqueWithoutCreatorInput | ContestUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ContestCreateManyCreatorInputEnvelope
    set?: ContestWhereUniqueInput | ContestWhereUniqueInput[]
    disconnect?: ContestWhereUniqueInput | ContestWhereUniqueInput[]
    delete?: ContestWhereUniqueInput | ContestWhereUniqueInput[]
    connect?: ContestWhereUniqueInput | ContestWhereUniqueInput[]
    update?: ContestUpdateWithWhereUniqueWithoutCreatorInput | ContestUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ContestUpdateManyWithWhereWithoutCreatorInput | ContestUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ContestScalarWhereInput | ContestScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<CommentCreateWithoutProviderInput, CommentUncheckedCreateWithoutProviderInput> | CommentCreateWithoutProviderInput[] | CommentUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProviderInput | CommentCreateOrConnectWithoutProviderInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutProviderInput | CommentUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: CommentCreateManyProviderInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutProviderInput | CommentUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutProviderInput | CommentUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput> | FollowCreateWithoutFollowingInput[] | FollowUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowingInput | FollowCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowingInput | FollowUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowCreateManyFollowingInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowingInput | FollowUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowingInput | FollowUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type VoteUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<VoteCreateWithoutProviderInput, VoteUncheckedCreateWithoutProviderInput> | VoteCreateWithoutProviderInput[] | VoteUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutProviderInput | VoteCreateOrConnectWithoutProviderInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutProviderInput | VoteUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: VoteCreateManyProviderInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutProviderInput | VoteUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutProviderInput | VoteUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<LikeCreateWithoutProviderInput, LikeUncheckedCreateWithoutProviderInput> | LikeCreateWithoutProviderInput[] | LikeUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutProviderInput | LikeCreateOrConnectWithoutProviderInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutProviderInput | LikeUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: LikeCreateManyProviderInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutProviderInput | LikeUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutProviderInput | LikeUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type UserPhotoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPhotoCreateWithoutUserInput, UserPhotoUncheckedCreateWithoutUserInput> | UserPhotoCreateWithoutUserInput[] | UserPhotoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPhotoCreateOrConnectWithoutUserInput | UserPhotoCreateOrConnectWithoutUserInput[]
    upsert?: UserPhotoUpsertWithWhereUniqueWithoutUserInput | UserPhotoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPhotoCreateManyUserInputEnvelope
    set?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    disconnect?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    delete?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    connect?: UserPhotoWhereUniqueInput | UserPhotoWhereUniqueInput[]
    update?: UserPhotoUpdateWithWhereUniqueWithoutUserInput | UserPhotoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPhotoUpdateManyWithWhereWithoutUserInput | UserPhotoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPhotoScalarWhereInput | UserPhotoScalarWhereInput[]
  }

  export type ContestParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContestParticipantCreateWithoutUserInput, ContestParticipantUncheckedCreateWithoutUserInput> | ContestParticipantCreateWithoutUserInput[] | ContestParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContestParticipantCreateOrConnectWithoutUserInput | ContestParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ContestParticipantUpsertWithWhereUniqueWithoutUserInput | ContestParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContestParticipantCreateManyUserInputEnvelope
    set?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    disconnect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    delete?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    connect?: ContestParticipantWhereUniqueInput | ContestParticipantWhereUniqueInput[]
    update?: ContestParticipantUpdateWithWhereUniqueWithoutUserInput | ContestParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContestParticipantUpdateManyWithWhereWithoutUserInput | ContestParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContestParticipantScalarWhereInput | ContestParticipantScalarWhereInput[]
  }

  export type PhotoStatsNullableCreateEnvelopeInput = {
    set?: PhotoStatsCreateInput | null
  }

  export type PhotoStatsCreateInput = {
    Composition?: number
    Content?: number
    Creativity?: number
    Technique?: number
  }

  export type UserPhotoCreatelabelsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutUserPhotosInput = {
    create?: XOR<UserCreateWithoutUserPhotosInput, UserUncheckedCreateWithoutUserPhotosInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPhotosInput
    connect?: UserWhereUniqueInput
  }

  export type ContestPhotoCreateNestedManyWithoutPhotoInput = {
    create?: XOR<ContestPhotoCreateWithoutPhotoInput, ContestPhotoUncheckedCreateWithoutPhotoInput> | ContestPhotoCreateWithoutPhotoInput[] | ContestPhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutPhotoInput | ContestPhotoCreateOrConnectWithoutPhotoInput[]
    createMany?: ContestPhotoCreateManyPhotoInputEnvelope
    connect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutPhotoInput = {
    create?: XOR<LikeCreateWithoutPhotoInput, LikeUncheckedCreateWithoutPhotoInput> | LikeCreateWithoutPhotoInput[] | LikeUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPhotoInput | LikeCreateOrConnectWithoutPhotoInput[]
    createMany?: LikeCreateManyPhotoInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type ContestPhotoUncheckedCreateNestedManyWithoutPhotoInput = {
    create?: XOR<ContestPhotoCreateWithoutPhotoInput, ContestPhotoUncheckedCreateWithoutPhotoInput> | ContestPhotoCreateWithoutPhotoInput[] | ContestPhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutPhotoInput | ContestPhotoCreateOrConnectWithoutPhotoInput[]
    createMany?: ContestPhotoCreateManyPhotoInputEnvelope
    connect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutPhotoInput = {
    create?: XOR<LikeCreateWithoutPhotoInput, LikeUncheckedCreateWithoutPhotoInput> | LikeCreateWithoutPhotoInput[] | LikeUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPhotoInput | LikeCreateOrConnectWithoutPhotoInput[]
    createMany?: LikeCreateManyPhotoInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type PhotoStatsNullableUpdateEnvelopeInput = {
    set?: PhotoStatsCreateInput | null
    upsert?: PhotoStatsUpsertInput
    unset?: boolean
  }

  export type UserPhotoUpdatelabelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutUserPhotosNestedInput = {
    create?: XOR<UserCreateWithoutUserPhotosInput, UserUncheckedCreateWithoutUserPhotosInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPhotosInput
    upsert?: UserUpsertWithoutUserPhotosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserPhotosInput, UserUpdateWithoutUserPhotosInput>, UserUncheckedUpdateWithoutUserPhotosInput>
  }

  export type ContestPhotoUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<ContestPhotoCreateWithoutPhotoInput, ContestPhotoUncheckedCreateWithoutPhotoInput> | ContestPhotoCreateWithoutPhotoInput[] | ContestPhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutPhotoInput | ContestPhotoCreateOrConnectWithoutPhotoInput[]
    upsert?: ContestPhotoUpsertWithWhereUniqueWithoutPhotoInput | ContestPhotoUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: ContestPhotoCreateManyPhotoInputEnvelope
    set?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    disconnect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    delete?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    connect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    update?: ContestPhotoUpdateWithWhereUniqueWithoutPhotoInput | ContestPhotoUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: ContestPhotoUpdateManyWithWhereWithoutPhotoInput | ContestPhotoUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: ContestPhotoScalarWhereInput | ContestPhotoScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<LikeCreateWithoutPhotoInput, LikeUncheckedCreateWithoutPhotoInput> | LikeCreateWithoutPhotoInput[] | LikeUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPhotoInput | LikeCreateOrConnectWithoutPhotoInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPhotoInput | LikeUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: LikeCreateManyPhotoInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPhotoInput | LikeUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPhotoInput | LikeUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type ContestPhotoUncheckedUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<ContestPhotoCreateWithoutPhotoInput, ContestPhotoUncheckedCreateWithoutPhotoInput> | ContestPhotoCreateWithoutPhotoInput[] | ContestPhotoUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutPhotoInput | ContestPhotoCreateOrConnectWithoutPhotoInput[]
    upsert?: ContestPhotoUpsertWithWhereUniqueWithoutPhotoInput | ContestPhotoUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: ContestPhotoCreateManyPhotoInputEnvelope
    set?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    disconnect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    delete?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    connect?: ContestPhotoWhereUniqueInput | ContestPhotoWhereUniqueInput[]
    update?: ContestPhotoUpdateWithWhereUniqueWithoutPhotoInput | ContestPhotoUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: ContestPhotoUpdateManyWithWhereWithoutPhotoInput | ContestPhotoUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: ContestPhotoScalarWhereInput | ContestPhotoScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutPhotoNestedInput = {
    create?: XOR<LikeCreateWithoutPhotoInput, LikeUncheckedCreateWithoutPhotoInput> | LikeCreateWithoutPhotoInput[] | LikeUncheckedCreateWithoutPhotoInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPhotoInput | LikeCreateOrConnectWithoutPhotoInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPhotoInput | LikeUpsertWithWhereUniqueWithoutPhotoInput[]
    createMany?: LikeCreateManyPhotoInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPhotoInput | LikeUpdateWithWhereUniqueWithoutPhotoInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPhotoInput | LikeUpdateManyWithWhereWithoutPhotoInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLikesInput = {
    create?: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesInput
    connect?: UserWhereUniqueInput
  }

  export type UserPhotoCreateNestedOneWithoutLikesInput = {
    create?: XOR<UserPhotoCreateWithoutLikesInput, UserPhotoUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserPhotoCreateOrConnectWithoutLikesInput
    connect?: UserPhotoWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesInput
    upsert?: UserUpsertWithoutLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikesInput, UserUpdateWithoutLikesInput>, UserUncheckedUpdateWithoutLikesInput>
  }

  export type UserPhotoUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<UserPhotoCreateWithoutLikesInput, UserPhotoUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserPhotoCreateOrConnectWithoutLikesInput
    upsert?: UserPhotoUpsertWithoutLikesInput
    connect?: UserPhotoWhereUniqueInput
    update?: XOR<XOR<UserPhotoUpdateToOneWithWhereWithoutLikesInput, UserPhotoUpdateWithoutLikesInput>, UserPhotoUncheckedUpdateWithoutLikesInput>
  }

  export type UserCreateNestedOneWithoutOtpsInput = {
    create?: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumOtpStatusFieldUpdateOperationsInput = {
    set?: $Enums.OtpStatus
  }

  export type UserUpdateOneRequiredWithoutOtpsNestedInput = {
    create?: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOtpsInput
    upsert?: UserUpsertWithoutOtpsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOtpsInput, UserUpdateWithoutOtpsInput>, UserUncheckedUpdateWithoutOtpsInput>
  }

  export type UserCreateNestedOneWithoutCommentProvidesInput = {
    create?: XOR<UserCreateWithoutCommentProvidesInput, UserUncheckedCreateWithoutCommentProvidesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentProvidesInput
    connect?: UserWhereUniqueInput
  }

  export type ContestPhotoCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ContestPhotoCreateWithoutCommentsInput, ContestPhotoUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutCommentsInput
    connect?: ContestPhotoWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCommentProvidesNestedInput = {
    create?: XOR<UserCreateWithoutCommentProvidesInput, UserUncheckedCreateWithoutCommentProvidesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentProvidesInput
    upsert?: UserUpsertWithoutCommentProvidesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentProvidesInput, UserUpdateWithoutCommentProvidesInput>, UserUncheckedUpdateWithoutCommentProvidesInput>
  }

  export type ContestPhotoUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ContestPhotoCreateWithoutCommentsInput, ContestPhotoUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutCommentsInput
    upsert?: ContestPhotoUpsertWithoutCommentsInput
    connect?: ContestPhotoWhereUniqueInput
    update?: XOR<XOR<ContestPhotoUpdateToOneWithWhereWithoutCommentsInput, ContestPhotoUpdateWithoutCommentsInput>, ContestPhotoUncheckedUpdateWithoutCommentsInput>
  }

  export type UserCreateNestedOneWithoutFollowersInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFollowingsInput = {
    create?: XOR<UserCreateWithoutFollowingsInput, UserUncheckedCreateWithoutFollowingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFollowersNestedInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    upsert?: UserUpsertWithoutFollowersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowersInput, UserUpdateWithoutFollowersInput>, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserUpdateOneRequiredWithoutFollowingsNestedInput = {
    create?: XOR<UserCreateWithoutFollowingsInput, UserUncheckedCreateWithoutFollowingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingsInput
    upsert?: UserUpsertWithoutFollowingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowingsInput, UserUpdateWithoutFollowingsInput>, UserUncheckedUpdateWithoutFollowingsInput>
  }

  export type UserCreateNestedOneWithoutVotesInput = {
    create?: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVotesInput
    connect?: UserWhereUniqueInput
  }

  export type ContestPhotoCreateNestedOneWithoutVotesInput = {
    create?: XOR<ContestPhotoCreateWithoutVotesInput, ContestPhotoUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutVotesInput
    connect?: ContestPhotoWhereUniqueInput
  }

  export type ContestCreateNestedOneWithoutVotesInput = {
    create?: XOR<ContestCreateWithoutVotesInput, ContestUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ContestCreateOrConnectWithoutVotesInput
    connect?: ContestWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVotesInput
    upsert?: UserUpsertWithoutVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVotesInput, UserUpdateWithoutVotesInput>, UserUncheckedUpdateWithoutVotesInput>
  }

  export type ContestPhotoUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<ContestPhotoCreateWithoutVotesInput, ContestPhotoUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ContestPhotoCreateOrConnectWithoutVotesInput
    upsert?: ContestPhotoUpsertWithoutVotesInput
    connect?: ContestPhotoWhereUniqueInput
    update?: XOR<XOR<ContestPhotoUpdateToOneWithWhereWithoutVotesInput, ContestPhotoUpdateWithoutVotesInput>, ContestPhotoUncheckedUpdateWithoutVotesInput>
  }

  export type ContestUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<ContestCreateWithoutVotesInput, ContestUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ContestCreateOrConnectWithoutVotesInput
    upsert?: ContestUpsertWithoutVotesInput
    connect?: ContestWhereUniqueInput
    update?: XOR<XOR<ContestUpdateToOneWithWhereWithoutVotesInput, ContestUpdateWithoutVotesInput>, ContestUncheckedUpdateWithoutVotesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedEnumContestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestStatus | EnumContestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContestStatus[] | ListEnumContestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestStatus[] | ListEnumContestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContestStatusFilter<$PrismaModel> | $Enums.ContestStatus
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumContestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestStatus | EnumContestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContestStatus[] | ListEnumContestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestStatus[] | ListEnumContestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContestStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContestStatusFilter<$PrismaModel>
    _max?: NestedEnumContestStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type RecurringDataWhereInput = {
    AND?: RecurringDataWhereInput | RecurringDataWhereInput[]
    OR?: RecurringDataWhereInput[]
    NOT?: RecurringDataWhereInput | RecurringDataWhereInput[]
    recurringType?: EnumRecurringTypeFilter<"RecurringData"> | $Enums.RecurringType
    previousOccurrence?: DateTimeFilter<"RecurringData"> | Date | string
    nextOccurrence?: DateTimeFilter<"RecurringData"> | Date | string
    duration?: IntFilter<"RecurringData"> | number
  }

  export type NestedEnumContestParticipantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestParticipantStatus | EnumContestParticipantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContestParticipantStatus[] | ListEnumContestParticipantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestParticipantStatus[] | ListEnumContestParticipantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContestParticipantStatusFilter<$PrismaModel> | $Enums.ContestParticipantStatus
  }

  export type NestedEnumContestLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestLevel | EnumContestLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ContestLevel[] | ListEnumContestLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestLevel[] | ListEnumContestLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumContestLevelFilter<$PrismaModel> | $Enums.ContestLevel
  }

  export type NestedEnumContestParticipantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestParticipantStatus | EnumContestParticipantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContestParticipantStatus[] | ListEnumContestParticipantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestParticipantStatus[] | ListEnumContestParticipantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContestParticipantStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContestParticipantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContestParticipantStatusFilter<$PrismaModel>
    _max?: NestedEnumContestParticipantStatusFilter<$PrismaModel>
  }

  export type NestedEnumContestLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContestLevel | EnumContestLevelFieldRefInput<$PrismaModel>
    in?: $Enums.ContestLevel[] | ListEnumContestLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContestLevel[] | ListEnumContestLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumContestLevelWithAggregatesFilter<$PrismaModel> | $Enums.ContestLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContestLevelFilter<$PrismaModel>
    _max?: NestedEnumContestLevelFilter<$PrismaModel>
  }

  export type NestedEnumPrizeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PrizeType | EnumPrizeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PrizeType[] | ListEnumPrizeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrizeType[] | ListEnumPrizeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPrizeTypeFilter<$PrismaModel> | $Enums.PrizeType
  }

  export type NestedEnumPrizeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrizeType | EnumPrizeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PrizeType[] | ListEnumPrizeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrizeType[] | ListEnumPrizeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPrizeTypeWithAggregatesFilter<$PrismaModel> | $Enums.PrizeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrizeTypeFilter<$PrismaModel>
    _max?: NestedEnumPrizeTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumTeamAccessibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamAccessibility | EnumTeamAccessibilityFieldRefInput<$PrismaModel>
    in?: $Enums.TeamAccessibility[] | ListEnumTeamAccessibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamAccessibility[] | ListEnumTeamAccessibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamAccessibilityFilter<$PrismaModel> | $Enums.TeamAccessibility
  }

  export type NestedEnumTeamAccessibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamAccessibility | EnumTeamAccessibilityFieldRefInput<$PrismaModel>
    in?: $Enums.TeamAccessibility[] | ListEnumTeamAccessibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamAccessibility[] | ListEnumTeamAccessibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamAccessibilityWithAggregatesFilter<$PrismaModel> | $Enums.TeamAccessibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamAccessibilityFilter<$PrismaModel>
    _max?: NestedEnumTeamAccessibilityFilter<$PrismaModel>
  }

  export type NestedEnumTeamMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamMemberStatus | EnumTeamMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TeamMemberStatus[] | ListEnumTeamMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamMemberStatus[] | ListEnumTeamMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamMemberStatusFilter<$PrismaModel> | $Enums.TeamMemberStatus
  }

  export type NestedEnumTeamMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamMemberStatus | EnumTeamMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TeamMemberStatus[] | ListEnumTeamMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamMemberStatus[] | ListEnumTeamMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.TeamMemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumTeamMemberStatusFilter<$PrismaModel>
  }

  export type NestedEnumUserLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserLevel | EnumUserLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserLevel[] | ListEnumUserLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserLevel[] | ListEnumUserLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserLevelNullableFilter<$PrismaModel> | $Enums.UserLevel | null
    isSet?: boolean
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserLevel | EnumUserLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserLevel[] | ListEnumUserLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserLevel[] | ListEnumUserLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumUserLevelNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type PhotoStatsWhereInput = {
    AND?: PhotoStatsWhereInput | PhotoStatsWhereInput[]
    OR?: PhotoStatsWhereInput[]
    NOT?: PhotoStatsWhereInput | PhotoStatsWhereInput[]
    Composition?: IntFilter<"PhotoStats"> | number
    Content?: IntFilter<"PhotoStats"> | number
    Creativity?: IntFilter<"PhotoStats"> | number
    Technique?: IntFilter<"PhotoStats"> | number
  }

  export type NestedEnumOtpStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OtpStatus | EnumOtpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OtpStatus[] | ListEnumOtpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OtpStatus[] | ListEnumOtpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOtpStatusFilter<$PrismaModel> | $Enums.OtpStatus
  }

  export type NestedEnumOtpStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OtpStatus | EnumOtpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OtpStatus[] | ListEnumOtpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OtpStatus[] | ListEnumOtpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOtpStatusWithAggregatesFilter<$PrismaModel> | $Enums.OtpStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOtpStatusFilter<$PrismaModel>
    _max?: NestedEnumOtpStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutCreatedContestsInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedContestsInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedContestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedContestsInput, UserUncheckedCreateWithoutCreatedContestsInput>
  }

  export type ContestParticipantCreateWithoutContestInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    level?: $Enums.ContestLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContestParticipantInput
    photos?: ContestPhotoCreateNestedManyWithoutParticipantInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantUncheckedCreateWithoutContestInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    userId: string
    level?: $Enums.ContestLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ContestPhotoUncheckedCreateNestedManyWithoutParticipantInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantCreateOrConnectWithoutContestInput = {
    where: ContestParticipantWhereUniqueInput
    create: XOR<ContestParticipantCreateWithoutContestInput, ContestParticipantUncheckedCreateWithoutContestInput>
  }

  export type ContestParticipantCreateManyContestInputEnvelope = {
    data: ContestParticipantCreateManyContestInput | ContestParticipantCreateManyContestInput[]
  }

  export type VoteCreateWithoutContestInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: UserCreateNestedOneWithoutVotesInput
    photo: ContestPhotoCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateWithoutContestInput = {
    id?: string
    providerId: string
    photoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteCreateOrConnectWithoutContestInput = {
    where: VoteWhereUniqueInput
    create: XOR<VoteCreateWithoutContestInput, VoteUncheckedCreateWithoutContestInput>
  }

  export type VoteCreateManyContestInputEnvelope = {
    data: VoteCreateManyContestInput | VoteCreateManyContestInput[]
  }

  export type ContestRuleCreateWithoutContestInput = {
    id?: string
    icon?: string | null
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestRuleUncheckedCreateWithoutContestInput = {
    id?: string
    icon?: string | null
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestRuleCreateOrConnectWithoutContestInput = {
    where: ContestRuleWhereUniqueInput
    create: XOR<ContestRuleCreateWithoutContestInput, ContestRuleUncheckedCreateWithoutContestInput>
  }

  export type ContestRuleCreateManyContestInputEnvelope = {
    data: ContestRuleCreateManyContestInput | ContestRuleCreateManyContestInput[]
  }

  export type ContestPrizeCreateWithoutContestInput = {
    id?: string
    category: $Enums.PrizeType
    trades?: number
    charges?: number
    keys?: number
  }

  export type ContestPrizeUncheckedCreateWithoutContestInput = {
    id?: string
    category: $Enums.PrizeType
    trades?: number
    charges?: number
    keys?: number
  }

  export type ContestPrizeCreateOrConnectWithoutContestInput = {
    where: ContestPrizeWhereUniqueInput
    create: XOR<ContestPrizeCreateWithoutContestInput, ContestPrizeUncheckedCreateWithoutContestInput>
  }

  export type ContestPrizeCreateManyContestInputEnvelope = {
    data: ContestPrizeCreateManyContestInput | ContestPrizeCreateManyContestInput[]
  }

  export type RecurringContestDataCreateWithoutContestInput = {
    id?: string
    lastRunAt?: Date | string | null
    nextRunAt: Date | string
  }

  export type RecurringContestDataUncheckedCreateWithoutContestInput = {
    id?: string
    lastRunAt?: Date | string | null
    nextRunAt: Date | string
  }

  export type RecurringContestDataCreateOrConnectWithoutContestInput = {
    where: RecurringContestDataWhereUniqueInput
    create: XOR<RecurringContestDataCreateWithoutContestInput, RecurringContestDataUncheckedCreateWithoutContestInput>
  }

  export type UserUpsertWithoutCreatedContestsInput = {
    update: XOR<UserUpdateWithoutCreatedContestsInput, UserUncheckedUpdateWithoutCreatedContestsInput>
    create: XOR<UserCreateWithoutCreatedContestsInput, UserUncheckedCreateWithoutCreatedContestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedContestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedContestsInput, UserUncheckedUpdateWithoutCreatedContestsInput>
  }

  export type UserUpdateWithoutCreatedContestsInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedContestsInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContestParticipantUpsertWithWhereUniqueWithoutContestInput = {
    where: ContestParticipantWhereUniqueInput
    update: XOR<ContestParticipantUpdateWithoutContestInput, ContestParticipantUncheckedUpdateWithoutContestInput>
    create: XOR<ContestParticipantCreateWithoutContestInput, ContestParticipantUncheckedCreateWithoutContestInput>
  }

  export type ContestParticipantUpdateWithWhereUniqueWithoutContestInput = {
    where: ContestParticipantWhereUniqueInput
    data: XOR<ContestParticipantUpdateWithoutContestInput, ContestParticipantUncheckedUpdateWithoutContestInput>
  }

  export type ContestParticipantUpdateManyWithWhereWithoutContestInput = {
    where: ContestParticipantScalarWhereInput
    data: XOR<ContestParticipantUpdateManyMutationInput, ContestParticipantUncheckedUpdateManyWithoutContestInput>
  }

  export type ContestParticipantScalarWhereInput = {
    AND?: ContestParticipantScalarWhereInput | ContestParticipantScalarWhereInput[]
    OR?: ContestParticipantScalarWhereInput[]
    NOT?: ContestParticipantScalarWhereInput | ContestParticipantScalarWhereInput[]
    id?: StringFilter<"ContestParticipant"> | string
    status?: EnumContestParticipantStatusFilter<"ContestParticipant"> | $Enums.ContestParticipantStatus
    contestId?: StringFilter<"ContestParticipant"> | string
    userId?: StringFilter<"ContestParticipant"> | string
    level?: EnumContestLevelFilter<"ContestParticipant"> | $Enums.ContestLevel
    rank?: IntNullableFilter<"ContestParticipant"> | number | null
    createdAt?: DateTimeFilter<"ContestParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"ContestParticipant"> | Date | string
  }

  export type VoteUpsertWithWhereUniqueWithoutContestInput = {
    where: VoteWhereUniqueInput
    update: XOR<VoteUpdateWithoutContestInput, VoteUncheckedUpdateWithoutContestInput>
    create: XOR<VoteCreateWithoutContestInput, VoteUncheckedCreateWithoutContestInput>
  }

  export type VoteUpdateWithWhereUniqueWithoutContestInput = {
    where: VoteWhereUniqueInput
    data: XOR<VoteUpdateWithoutContestInput, VoteUncheckedUpdateWithoutContestInput>
  }

  export type VoteUpdateManyWithWhereWithoutContestInput = {
    where: VoteScalarWhereInput
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyWithoutContestInput>
  }

  export type VoteScalarWhereInput = {
    AND?: VoteScalarWhereInput | VoteScalarWhereInput[]
    OR?: VoteScalarWhereInput[]
    NOT?: VoteScalarWhereInput | VoteScalarWhereInput[]
    id?: StringFilter<"Vote"> | string
    providerId?: StringFilter<"Vote"> | string
    photoId?: StringFilter<"Vote"> | string
    contestId?: StringFilter<"Vote"> | string
    createdAt?: DateTimeFilter<"Vote"> | Date | string
    updatedAt?: DateTimeFilter<"Vote"> | Date | string
  }

  export type ContestRuleUpsertWithWhereUniqueWithoutContestInput = {
    where: ContestRuleWhereUniqueInput
    update: XOR<ContestRuleUpdateWithoutContestInput, ContestRuleUncheckedUpdateWithoutContestInput>
    create: XOR<ContestRuleCreateWithoutContestInput, ContestRuleUncheckedCreateWithoutContestInput>
  }

  export type ContestRuleUpdateWithWhereUniqueWithoutContestInput = {
    where: ContestRuleWhereUniqueInput
    data: XOR<ContestRuleUpdateWithoutContestInput, ContestRuleUncheckedUpdateWithoutContestInput>
  }

  export type ContestRuleUpdateManyWithWhereWithoutContestInput = {
    where: ContestRuleScalarWhereInput
    data: XOR<ContestRuleUpdateManyMutationInput, ContestRuleUncheckedUpdateManyWithoutContestInput>
  }

  export type ContestRuleScalarWhereInput = {
    AND?: ContestRuleScalarWhereInput | ContestRuleScalarWhereInput[]
    OR?: ContestRuleScalarWhereInput[]
    NOT?: ContestRuleScalarWhereInput | ContestRuleScalarWhereInput[]
    id?: StringFilter<"ContestRule"> | string
    icon?: StringNullableFilter<"ContestRule"> | string | null
    name?: StringFilter<"ContestRule"> | string
    description?: StringFilter<"ContestRule"> | string
    contestId?: StringFilter<"ContestRule"> | string
    createdAt?: DateTimeFilter<"ContestRule"> | Date | string
    updatedAt?: DateTimeFilter<"ContestRule"> | Date | string
  }

  export type ContestPrizeUpsertWithWhereUniqueWithoutContestInput = {
    where: ContestPrizeWhereUniqueInput
    update: XOR<ContestPrizeUpdateWithoutContestInput, ContestPrizeUncheckedUpdateWithoutContestInput>
    create: XOR<ContestPrizeCreateWithoutContestInput, ContestPrizeUncheckedCreateWithoutContestInput>
  }

  export type ContestPrizeUpdateWithWhereUniqueWithoutContestInput = {
    where: ContestPrizeWhereUniqueInput
    data: XOR<ContestPrizeUpdateWithoutContestInput, ContestPrizeUncheckedUpdateWithoutContestInput>
  }

  export type ContestPrizeUpdateManyWithWhereWithoutContestInput = {
    where: ContestPrizeScalarWhereInput
    data: XOR<ContestPrizeUpdateManyMutationInput, ContestPrizeUncheckedUpdateManyWithoutContestInput>
  }

  export type ContestPrizeScalarWhereInput = {
    AND?: ContestPrizeScalarWhereInput | ContestPrizeScalarWhereInput[]
    OR?: ContestPrizeScalarWhereInput[]
    NOT?: ContestPrizeScalarWhereInput | ContestPrizeScalarWhereInput[]
    id?: StringFilter<"ContestPrize"> | string
    category?: EnumPrizeTypeFilter<"ContestPrize"> | $Enums.PrizeType
    trades?: IntFilter<"ContestPrize"> | number
    charges?: IntFilter<"ContestPrize"> | number
    keys?: IntFilter<"ContestPrize"> | number
    contestId?: StringFilter<"ContestPrize"> | string
  }

  export type RecurringContestDataUpsertWithoutContestInput = {
    update: XOR<RecurringContestDataUpdateWithoutContestInput, RecurringContestDataUncheckedUpdateWithoutContestInput>
    create: XOR<RecurringContestDataCreateWithoutContestInput, RecurringContestDataUncheckedCreateWithoutContestInput>
    where?: RecurringContestDataWhereInput
  }

  export type RecurringContestDataUpdateToOneWithWhereWithoutContestInput = {
    where?: RecurringContestDataWhereInput
    data: XOR<RecurringContestDataUpdateWithoutContestInput, RecurringContestDataUncheckedUpdateWithoutContestInput>
  }

  export type RecurringContestDataUpdateWithoutContestInput = {
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecurringContestDataUncheckedUpdateWithoutContestInput = {
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextRunAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestCreateWithoutContestRulesInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    maxUploads?: number | null
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedContestsInput
    participants?: ContestParticipantCreateNestedManyWithoutContestInput
    votes?: VoteCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeCreateNestedManyWithoutContestInput
    recurringData?: RecurringContestDataCreateNestedOneWithoutContestInput
  }

  export type ContestUncheckedCreateWithoutContestRulesInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    maxUploads?: number | null
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ContestParticipantUncheckedCreateNestedManyWithoutContestInput
    votes?: VoteUncheckedCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeUncheckedCreateNestedManyWithoutContestInput
    recurringData?: RecurringContestDataUncheckedCreateNestedOneWithoutContestInput
  }

  export type ContestCreateOrConnectWithoutContestRulesInput = {
    where: ContestWhereUniqueInput
    create: XOR<ContestCreateWithoutContestRulesInput, ContestUncheckedCreateWithoutContestRulesInput>
  }

  export type ContestUpsertWithoutContestRulesInput = {
    update: XOR<ContestUpdateWithoutContestRulesInput, ContestUncheckedUpdateWithoutContestRulesInput>
    create: XOR<ContestCreateWithoutContestRulesInput, ContestUncheckedCreateWithoutContestRulesInput>
    where?: ContestWhereInput
  }

  export type ContestUpdateToOneWithWhereWithoutContestRulesInput = {
    where?: ContestWhereInput
    data: XOR<ContestUpdateWithoutContestRulesInput, ContestUncheckedUpdateWithoutContestRulesInput>
  }

  export type ContestUpdateWithoutContestRulesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedContestsNestedInput
    participants?: ContestParticipantUpdateManyWithoutContestNestedInput
    votes?: VoteUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUpdateManyWithoutContestNestedInput
    recurringData?: RecurringContestDataUpdateOneWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateWithoutContestRulesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ContestParticipantUncheckedUpdateManyWithoutContestNestedInput
    votes?: VoteUncheckedUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUncheckedUpdateManyWithoutContestNestedInput
    recurringData?: RecurringContestDataUncheckedUpdateOneWithoutContestNestedInput
  }

  export type ContestCreateWithoutRecurringDataInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    maxUploads?: number | null
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedContestsInput
    participants?: ContestParticipantCreateNestedManyWithoutContestInput
    votes?: VoteCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeCreateNestedManyWithoutContestInput
  }

  export type ContestUncheckedCreateWithoutRecurringDataInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    maxUploads?: number | null
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ContestParticipantUncheckedCreateNestedManyWithoutContestInput
    votes?: VoteUncheckedCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleUncheckedCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeUncheckedCreateNestedManyWithoutContestInput
  }

  export type ContestCreateOrConnectWithoutRecurringDataInput = {
    where: ContestWhereUniqueInput
    create: XOR<ContestCreateWithoutRecurringDataInput, ContestUncheckedCreateWithoutRecurringDataInput>
  }

  export type ContestUpsertWithoutRecurringDataInput = {
    update: XOR<ContestUpdateWithoutRecurringDataInput, ContestUncheckedUpdateWithoutRecurringDataInput>
    create: XOR<ContestCreateWithoutRecurringDataInput, ContestUncheckedCreateWithoutRecurringDataInput>
    where?: ContestWhereInput
  }

  export type ContestUpdateToOneWithWhereWithoutRecurringDataInput = {
    where?: ContestWhereInput
    data: XOR<ContestUpdateWithoutRecurringDataInput, ContestUncheckedUpdateWithoutRecurringDataInput>
  }

  export type ContestUpdateWithoutRecurringDataInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedContestsNestedInput
    participants?: ContestParticipantUpdateManyWithoutContestNestedInput
    votes?: VoteUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUpdateManyWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateWithoutRecurringDataInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ContestParticipantUncheckedUpdateManyWithoutContestNestedInput
    votes?: VoteUncheckedUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUncheckedUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUncheckedUpdateManyWithoutContestNestedInput
  }

  export type RecurringDataUpdateInput = {
    recurringType?: EnumRecurringTypeFieldUpdateOperationsInput | $Enums.RecurringType
    previousOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    nextOccurrence?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
  }

  export type ContestParticipantCreateWithoutPhotosInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    level?: $Enums.ContestLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contest: ContestCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutContestParticipantInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantUncheckedCreateWithoutPhotosInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    contestId: string
    userId: string
    level?: $Enums.ContestLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantCreateOrConnectWithoutPhotosInput = {
    where: ContestParticipantWhereUniqueInput
    create: XOR<ContestParticipantCreateWithoutPhotosInput, ContestParticipantUncheckedCreateWithoutPhotosInput>
  }

  export type VoteCreateWithoutPhotoInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: UserCreateNestedOneWithoutVotesInput
    contest: ContestCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateWithoutPhotoInput = {
    id?: string
    providerId: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteCreateOrConnectWithoutPhotoInput = {
    where: VoteWhereUniqueInput
    create: XOR<VoteCreateWithoutPhotoInput, VoteUncheckedCreateWithoutPhotoInput>
  }

  export type VoteCreateManyPhotoInputEnvelope = {
    data: VoteCreateManyPhotoInput | VoteCreateManyPhotoInput[]
  }

  export type UserPhotoCreateWithoutContestUploadInput = {
    id?: string
    url: string
    states?: XOR<PhotoStatsNullableCreateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: number
    labels?: UserPhotoCreatelabelsInput | string[]
    title?: string | null
    description?: string | null
    adult?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserPhotosInput
    likes?: LikeCreateNestedManyWithoutPhotoInput
  }

  export type UserPhotoUncheckedCreateWithoutContestUploadInput = {
    id?: string
    url: string
    userId: string
    states?: XOR<PhotoStatsNullableCreateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: number
    labels?: UserPhotoCreatelabelsInput | string[]
    title?: string | null
    description?: string | null
    adult?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: LikeUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type UserPhotoCreateOrConnectWithoutContestUploadInput = {
    where: UserPhotoWhereUniqueInput
    create: XOR<UserPhotoCreateWithoutContestUploadInput, UserPhotoUncheckedCreateWithoutContestUploadInput>
  }

  export type CommentCreateWithoutReceiverInput = {
    id?: string
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: UserCreateNestedOneWithoutCommentProvidesInput
  }

  export type CommentUncheckedCreateWithoutReceiverInput = {
    id?: string
    text: string
    providerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutReceiverInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutReceiverInput, CommentUncheckedCreateWithoutReceiverInput>
  }

  export type CommentCreateManyReceiverInputEnvelope = {
    data: CommentCreateManyReceiverInput | CommentCreateManyReceiverInput[]
  }

  export type ContestAchievementCreateWithoutPhotoInput = {
    id?: string
    category: $Enums.PrizeType
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participant?: ContestParticipantCreateNestedOneWithoutContestAchievementInput
  }

  export type ContestAchievementUncheckedCreateWithoutPhotoInput = {
    id?: string
    category: $Enums.PrizeType
    participantId?: string | null
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestAchievementCreateOrConnectWithoutPhotoInput = {
    where: ContestAchievementWhereUniqueInput
    create: XOR<ContestAchievementCreateWithoutPhotoInput, ContestAchievementUncheckedCreateWithoutPhotoInput>
  }

  export type ContestAchievementCreateManyPhotoInputEnvelope = {
    data: ContestAchievementCreateManyPhotoInput | ContestAchievementCreateManyPhotoInput[]
  }

  export type ContestWinnerCreateWithoutPhotoInput = {
    id?: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participant: ContestParticipantCreateNestedOneWithoutContestWinnerInput
  }

  export type ContestWinnerUncheckedCreateWithoutPhotoInput = {
    id?: string
    participantId: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestWinnerCreateOrConnectWithoutPhotoInput = {
    where: ContestWinnerWhereUniqueInput
    create: XOR<ContestWinnerCreateWithoutPhotoInput, ContestWinnerUncheckedCreateWithoutPhotoInput>
  }

  export type ContestWinnerCreateManyPhotoInputEnvelope = {
    data: ContestWinnerCreateManyPhotoInput | ContestWinnerCreateManyPhotoInput[]
  }

  export type ContestParticipantUpsertWithoutPhotosInput = {
    update: XOR<ContestParticipantUpdateWithoutPhotosInput, ContestParticipantUncheckedUpdateWithoutPhotosInput>
    create: XOR<ContestParticipantCreateWithoutPhotosInput, ContestParticipantUncheckedCreateWithoutPhotosInput>
    where?: ContestParticipantWhereInput
  }

  export type ContestParticipantUpdateToOneWithWhereWithoutPhotosInput = {
    where?: ContestParticipantWhereInput
    data: XOR<ContestParticipantUpdateWithoutPhotosInput, ContestParticipantUncheckedUpdateWithoutPhotosInput>
  }

  export type ContestParticipantUpdateWithoutPhotosInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    level?: EnumContestLevelFieldUpdateOperationsInput | $Enums.ContestLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contest?: ContestUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutContestParticipantNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUpdateManyWithoutParticipantNestedInput
  }

  export type ContestParticipantUncheckedUpdateWithoutPhotosInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    contestId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    level?: EnumContestLevelFieldUpdateOperationsInput | $Enums.ContestLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type VoteUpsertWithWhereUniqueWithoutPhotoInput = {
    where: VoteWhereUniqueInput
    update: XOR<VoteUpdateWithoutPhotoInput, VoteUncheckedUpdateWithoutPhotoInput>
    create: XOR<VoteCreateWithoutPhotoInput, VoteUncheckedCreateWithoutPhotoInput>
  }

  export type VoteUpdateWithWhereUniqueWithoutPhotoInput = {
    where: VoteWhereUniqueInput
    data: XOR<VoteUpdateWithoutPhotoInput, VoteUncheckedUpdateWithoutPhotoInput>
  }

  export type VoteUpdateManyWithWhereWithoutPhotoInput = {
    where: VoteScalarWhereInput
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyWithoutPhotoInput>
  }

  export type UserPhotoUpsertWithoutContestUploadInput = {
    update: XOR<UserPhotoUpdateWithoutContestUploadInput, UserPhotoUncheckedUpdateWithoutContestUploadInput>
    create: XOR<UserPhotoCreateWithoutContestUploadInput, UserPhotoUncheckedCreateWithoutContestUploadInput>
    where?: UserPhotoWhereInput
  }

  export type UserPhotoUpdateToOneWithWhereWithoutContestUploadInput = {
    where?: UserPhotoWhereInput
    data: XOR<UserPhotoUpdateWithoutContestUploadInput, UserPhotoUncheckedUpdateWithoutContestUploadInput>
  }

  export type UserPhotoUpdateWithoutContestUploadInput = {
    url?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserPhotosNestedInput
    likes?: LikeUpdateManyWithoutPhotoNestedInput
  }

  export type UserPhotoUncheckedUpdateWithoutContestUploadInput = {
    url?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: LikeUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutReceiverInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutReceiverInput, CommentUncheckedUpdateWithoutReceiverInput>
    create: XOR<CommentCreateWithoutReceiverInput, CommentUncheckedCreateWithoutReceiverInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutReceiverInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutReceiverInput, CommentUncheckedUpdateWithoutReceiverInput>
  }

  export type CommentUpdateManyWithWhereWithoutReceiverInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutReceiverInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    text?: StringFilter<"Comment"> | string
    providerId?: StringFilter<"Comment"> | string
    receiverId?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type ContestAchievementUpsertWithWhereUniqueWithoutPhotoInput = {
    where: ContestAchievementWhereUniqueInput
    update: XOR<ContestAchievementUpdateWithoutPhotoInput, ContestAchievementUncheckedUpdateWithoutPhotoInput>
    create: XOR<ContestAchievementCreateWithoutPhotoInput, ContestAchievementUncheckedCreateWithoutPhotoInput>
  }

  export type ContestAchievementUpdateWithWhereUniqueWithoutPhotoInput = {
    where: ContestAchievementWhereUniqueInput
    data: XOR<ContestAchievementUpdateWithoutPhotoInput, ContestAchievementUncheckedUpdateWithoutPhotoInput>
  }

  export type ContestAchievementUpdateManyWithWhereWithoutPhotoInput = {
    where: ContestAchievementScalarWhereInput
    data: XOR<ContestAchievementUpdateManyMutationInput, ContestAchievementUncheckedUpdateManyWithoutPhotoInput>
  }

  export type ContestAchievementScalarWhereInput = {
    AND?: ContestAchievementScalarWhereInput | ContestAchievementScalarWhereInput[]
    OR?: ContestAchievementScalarWhereInput[]
    NOT?: ContestAchievementScalarWhereInput | ContestAchievementScalarWhereInput[]
    id?: StringFilter<"ContestAchievement"> | string
    category?: EnumPrizeTypeFilter<"ContestAchievement"> | $Enums.PrizeType
    photoId?: StringNullableFilter<"ContestAchievement"> | string | null
    participantId?: StringNullableFilter<"ContestAchievement"> | string | null
    contestId?: StringFilter<"ContestAchievement"> | string
    createdAt?: DateTimeFilter<"ContestAchievement"> | Date | string
    updatedAt?: DateTimeFilter<"ContestAchievement"> | Date | string
  }

  export type ContestWinnerUpsertWithWhereUniqueWithoutPhotoInput = {
    where: ContestWinnerWhereUniqueInput
    update: XOR<ContestWinnerUpdateWithoutPhotoInput, ContestWinnerUncheckedUpdateWithoutPhotoInput>
    create: XOR<ContestWinnerCreateWithoutPhotoInput, ContestWinnerUncheckedCreateWithoutPhotoInput>
  }

  export type ContestWinnerUpdateWithWhereUniqueWithoutPhotoInput = {
    where: ContestWinnerWhereUniqueInput
    data: XOR<ContestWinnerUpdateWithoutPhotoInput, ContestWinnerUncheckedUpdateWithoutPhotoInput>
  }

  export type ContestWinnerUpdateManyWithWhereWithoutPhotoInput = {
    where: ContestWinnerScalarWhereInput
    data: XOR<ContestWinnerUpdateManyMutationInput, ContestWinnerUncheckedUpdateManyWithoutPhotoInput>
  }

  export type ContestWinnerScalarWhereInput = {
    AND?: ContestWinnerScalarWhereInput | ContestWinnerScalarWhereInput[]
    OR?: ContestWinnerScalarWhereInput[]
    NOT?: ContestWinnerScalarWhereInput | ContestWinnerScalarWhereInput[]
    id?: StringFilter<"ContestWinner"> | string
    participantId?: StringFilter<"ContestWinner"> | string
    contestId?: StringFilter<"ContestWinner"> | string
    contestPhotoId?: StringFilter<"ContestWinner"> | string
    createdAt?: DateTimeFilter<"ContestWinner"> | Date | string
    updatedAt?: DateTimeFilter<"ContestWinner"> | Date | string
  }

  export type ContestParticipantCreateWithoutContestWinnerInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    level?: $Enums.ContestLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contest: ContestCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutContestParticipantInput
    photos?: ContestPhotoCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantUncheckedCreateWithoutContestWinnerInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    contestId: string
    userId: string
    level?: $Enums.ContestLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ContestPhotoUncheckedCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantCreateOrConnectWithoutContestWinnerInput = {
    where: ContestParticipantWhereUniqueInput
    create: XOR<ContestParticipantCreateWithoutContestWinnerInput, ContestParticipantUncheckedCreateWithoutContestWinnerInput>
  }

  export type ContestPhotoCreateWithoutContestWinnerInput = {
    id?: string
    title?: string | null
    contestId: string
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participant: ContestParticipantCreateNestedOneWithoutPhotosInput
    votes?: VoteCreateNestedManyWithoutPhotoInput
    photo: UserPhotoCreateNestedOneWithoutContestUploadInput
    comments?: CommentCreateNestedManyWithoutReceiverInput
    achievements?: ContestAchievementCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoUncheckedCreateWithoutContestWinnerInput = {
    id?: string
    title?: string | null
    contestId: string
    participantId: string
    photoId: string
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutPhotoInput
    comments?: CommentUncheckedCreateNestedManyWithoutReceiverInput
    achievements?: ContestAchievementUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoCreateOrConnectWithoutContestWinnerInput = {
    where: ContestPhotoWhereUniqueInput
    create: XOR<ContestPhotoCreateWithoutContestWinnerInput, ContestPhotoUncheckedCreateWithoutContestWinnerInput>
  }

  export type ContestParticipantUpsertWithoutContestWinnerInput = {
    update: XOR<ContestParticipantUpdateWithoutContestWinnerInput, ContestParticipantUncheckedUpdateWithoutContestWinnerInput>
    create: XOR<ContestParticipantCreateWithoutContestWinnerInput, ContestParticipantUncheckedCreateWithoutContestWinnerInput>
    where?: ContestParticipantWhereInput
  }

  export type ContestParticipantUpdateToOneWithWhereWithoutContestWinnerInput = {
    where?: ContestParticipantWhereInput
    data: XOR<ContestParticipantUpdateWithoutContestWinnerInput, ContestParticipantUncheckedUpdateWithoutContestWinnerInput>
  }

  export type ContestParticipantUpdateWithoutContestWinnerInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    level?: EnumContestLevelFieldUpdateOperationsInput | $Enums.ContestLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contest?: ContestUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutContestParticipantNestedInput
    photos?: ContestPhotoUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUpdateManyWithoutParticipantNestedInput
  }

  export type ContestParticipantUncheckedUpdateWithoutContestWinnerInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    contestId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    level?: EnumContestLevelFieldUpdateOperationsInput | $Enums.ContestLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ContestPhotoUncheckedUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type ContestPhotoUpsertWithoutContestWinnerInput = {
    update: XOR<ContestPhotoUpdateWithoutContestWinnerInput, ContestPhotoUncheckedUpdateWithoutContestWinnerInput>
    create: XOR<ContestPhotoCreateWithoutContestWinnerInput, ContestPhotoUncheckedCreateWithoutContestWinnerInput>
    where?: ContestPhotoWhereInput
  }

  export type ContestPhotoUpdateToOneWithWhereWithoutContestWinnerInput = {
    where?: ContestPhotoWhereInput
    data: XOR<ContestPhotoUpdateWithoutContestWinnerInput, ContestPhotoUncheckedUpdateWithoutContestWinnerInput>
  }

  export type ContestPhotoUpdateWithoutContestWinnerInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ContestParticipantUpdateOneRequiredWithoutPhotosNestedInput
    votes?: VoteUpdateManyWithoutPhotoNestedInput
    photo?: UserPhotoUpdateOneRequiredWithoutContestUploadNestedInput
    comments?: CommentUpdateManyWithoutReceiverNestedInput
    achievements?: ContestAchievementUpdateManyWithoutPhotoNestedInput
  }

  export type ContestPhotoUncheckedUpdateWithoutContestWinnerInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutPhotoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutReceiverNestedInput
    achievements?: ContestAchievementUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type ContestCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    maxUploads?: number | null
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedContestsInput
    votes?: VoteCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeCreateNestedManyWithoutContestInput
    recurringData?: RecurringContestDataCreateNestedOneWithoutContestInput
  }

  export type ContestUncheckedCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    maxUploads?: number | null
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleUncheckedCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeUncheckedCreateNestedManyWithoutContestInput
    recurringData?: RecurringContestDataUncheckedCreateNestedOneWithoutContestInput
  }

  export type ContestCreateOrConnectWithoutParticipantsInput = {
    where: ContestWhereUniqueInput
    create: XOR<ContestCreateWithoutParticipantsInput, ContestUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutContestParticipantInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutContestParticipantInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutContestParticipantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContestParticipantInput, UserUncheckedCreateWithoutContestParticipantInput>
  }

  export type ContestPhotoCreateWithoutParticipantInput = {
    id?: string
    title?: string | null
    contestId: string
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: VoteCreateNestedManyWithoutPhotoInput
    photo: UserPhotoCreateNestedOneWithoutContestUploadInput
    comments?: CommentCreateNestedManyWithoutReceiverInput
    achievements?: ContestAchievementCreateNestedManyWithoutPhotoInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoUncheckedCreateWithoutParticipantInput = {
    id?: string
    title?: string | null
    contestId: string
    photoId: string
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutPhotoInput
    comments?: CommentUncheckedCreateNestedManyWithoutReceiverInput
    achievements?: ContestAchievementUncheckedCreateNestedManyWithoutPhotoInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoCreateOrConnectWithoutParticipantInput = {
    where: ContestPhotoWhereUniqueInput
    create: XOR<ContestPhotoCreateWithoutParticipantInput, ContestPhotoUncheckedCreateWithoutParticipantInput>
  }

  export type ContestPhotoCreateManyParticipantInputEnvelope = {
    data: ContestPhotoCreateManyParticipantInput | ContestPhotoCreateManyParticipantInput[]
  }

  export type ContestWinnerCreateWithoutParticipantInput = {
    id?: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    photo: ContestPhotoCreateNestedOneWithoutContestWinnerInput
  }

  export type ContestWinnerUncheckedCreateWithoutParticipantInput = {
    id?: string
    contestId: string
    contestPhotoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestWinnerCreateOrConnectWithoutParticipantInput = {
    where: ContestWinnerWhereUniqueInput
    create: XOR<ContestWinnerCreateWithoutParticipantInput, ContestWinnerUncheckedCreateWithoutParticipantInput>
  }

  export type ContestWinnerCreateManyParticipantInputEnvelope = {
    data: ContestWinnerCreateManyParticipantInput | ContestWinnerCreateManyParticipantInput[]
  }

  export type ContestAchievementCreateWithoutParticipantInput = {
    id?: string
    category: $Enums.PrizeType
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    photo?: ContestPhotoCreateNestedOneWithoutAchievementsInput
  }

  export type ContestAchievementUncheckedCreateWithoutParticipantInput = {
    id?: string
    category: $Enums.PrizeType
    photoId?: string | null
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestAchievementCreateOrConnectWithoutParticipantInput = {
    where: ContestAchievementWhereUniqueInput
    create: XOR<ContestAchievementCreateWithoutParticipantInput, ContestAchievementUncheckedCreateWithoutParticipantInput>
  }

  export type ContestAchievementCreateManyParticipantInputEnvelope = {
    data: ContestAchievementCreateManyParticipantInput | ContestAchievementCreateManyParticipantInput[]
  }

  export type ContestUpsertWithoutParticipantsInput = {
    update: XOR<ContestUpdateWithoutParticipantsInput, ContestUncheckedUpdateWithoutParticipantsInput>
    create: XOR<ContestCreateWithoutParticipantsInput, ContestUncheckedCreateWithoutParticipantsInput>
    where?: ContestWhereInput
  }

  export type ContestUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: ContestWhereInput
    data: XOR<ContestUpdateWithoutParticipantsInput, ContestUncheckedUpdateWithoutParticipantsInput>
  }

  export type ContestUpdateWithoutParticipantsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedContestsNestedInput
    votes?: VoteUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUpdateManyWithoutContestNestedInput
    recurringData?: RecurringContestDataUpdateOneWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateWithoutParticipantsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUncheckedUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUncheckedUpdateManyWithoutContestNestedInput
    recurringData?: RecurringContestDataUncheckedUpdateOneWithoutContestNestedInput
  }

  export type UserUpsertWithoutContestParticipantInput = {
    update: XOR<UserUpdateWithoutContestParticipantInput, UserUncheckedUpdateWithoutContestParticipantInput>
    create: XOR<UserCreateWithoutContestParticipantInput, UserUncheckedCreateWithoutContestParticipantInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContestParticipantInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContestParticipantInput, UserUncheckedUpdateWithoutContestParticipantInput>
  }

  export type UserUpdateWithoutContestParticipantInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutContestParticipantInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContestPhotoUpsertWithWhereUniqueWithoutParticipantInput = {
    where: ContestPhotoWhereUniqueInput
    update: XOR<ContestPhotoUpdateWithoutParticipantInput, ContestPhotoUncheckedUpdateWithoutParticipantInput>
    create: XOR<ContestPhotoCreateWithoutParticipantInput, ContestPhotoUncheckedCreateWithoutParticipantInput>
  }

  export type ContestPhotoUpdateWithWhereUniqueWithoutParticipantInput = {
    where: ContestPhotoWhereUniqueInput
    data: XOR<ContestPhotoUpdateWithoutParticipantInput, ContestPhotoUncheckedUpdateWithoutParticipantInput>
  }

  export type ContestPhotoUpdateManyWithWhereWithoutParticipantInput = {
    where: ContestPhotoScalarWhereInput
    data: XOR<ContestPhotoUpdateManyMutationInput, ContestPhotoUncheckedUpdateManyWithoutParticipantInput>
  }

  export type ContestPhotoScalarWhereInput = {
    AND?: ContestPhotoScalarWhereInput | ContestPhotoScalarWhereInput[]
    OR?: ContestPhotoScalarWhereInput[]
    NOT?: ContestPhotoScalarWhereInput | ContestPhotoScalarWhereInput[]
    id?: StringFilter<"ContestPhoto"> | string
    title?: StringNullableFilter<"ContestPhoto"> | string | null
    contestId?: StringFilter<"ContestPhoto"> | string
    participantId?: StringFilter<"ContestPhoto"> | string
    photoId?: StringFilter<"ContestPhoto"> | string
    rank?: IntNullableFilter<"ContestPhoto"> | number | null
    createdAt?: DateTimeFilter<"ContestPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"ContestPhoto"> | Date | string
  }

  export type ContestWinnerUpsertWithWhereUniqueWithoutParticipantInput = {
    where: ContestWinnerWhereUniqueInput
    update: XOR<ContestWinnerUpdateWithoutParticipantInput, ContestWinnerUncheckedUpdateWithoutParticipantInput>
    create: XOR<ContestWinnerCreateWithoutParticipantInput, ContestWinnerUncheckedCreateWithoutParticipantInput>
  }

  export type ContestWinnerUpdateWithWhereUniqueWithoutParticipantInput = {
    where: ContestWinnerWhereUniqueInput
    data: XOR<ContestWinnerUpdateWithoutParticipantInput, ContestWinnerUncheckedUpdateWithoutParticipantInput>
  }

  export type ContestWinnerUpdateManyWithWhereWithoutParticipantInput = {
    where: ContestWinnerScalarWhereInput
    data: XOR<ContestWinnerUpdateManyMutationInput, ContestWinnerUncheckedUpdateManyWithoutParticipantInput>
  }

  export type ContestAchievementUpsertWithWhereUniqueWithoutParticipantInput = {
    where: ContestAchievementWhereUniqueInput
    update: XOR<ContestAchievementUpdateWithoutParticipantInput, ContestAchievementUncheckedUpdateWithoutParticipantInput>
    create: XOR<ContestAchievementCreateWithoutParticipantInput, ContestAchievementUncheckedCreateWithoutParticipantInput>
  }

  export type ContestAchievementUpdateWithWhereUniqueWithoutParticipantInput = {
    where: ContestAchievementWhereUniqueInput
    data: XOR<ContestAchievementUpdateWithoutParticipantInput, ContestAchievementUncheckedUpdateWithoutParticipantInput>
  }

  export type ContestAchievementUpdateManyWithWhereWithoutParticipantInput = {
    where: ContestAchievementScalarWhereInput
    data: XOR<ContestAchievementUpdateManyMutationInput, ContestAchievementUncheckedUpdateManyWithoutParticipantInput>
  }

  export type ContestCreateWithoutContestPrizesInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    maxUploads?: number | null
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedContestsInput
    participants?: ContestParticipantCreateNestedManyWithoutContestInput
    votes?: VoteCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleCreateNestedManyWithoutContestInput
    recurringData?: RecurringContestDataCreateNestedOneWithoutContestInput
  }

  export type ContestUncheckedCreateWithoutContestPrizesInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    maxUploads?: number | null
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ContestParticipantUncheckedCreateNestedManyWithoutContestInput
    votes?: VoteUncheckedCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleUncheckedCreateNestedManyWithoutContestInput
    recurringData?: RecurringContestDataUncheckedCreateNestedOneWithoutContestInput
  }

  export type ContestCreateOrConnectWithoutContestPrizesInput = {
    where: ContestWhereUniqueInput
    create: XOR<ContestCreateWithoutContestPrizesInput, ContestUncheckedCreateWithoutContestPrizesInput>
  }

  export type ContestUpsertWithoutContestPrizesInput = {
    update: XOR<ContestUpdateWithoutContestPrizesInput, ContestUncheckedUpdateWithoutContestPrizesInput>
    create: XOR<ContestCreateWithoutContestPrizesInput, ContestUncheckedCreateWithoutContestPrizesInput>
    where?: ContestWhereInput
  }

  export type ContestUpdateToOneWithWhereWithoutContestPrizesInput = {
    where?: ContestWhereInput
    data: XOR<ContestUpdateWithoutContestPrizesInput, ContestUncheckedUpdateWithoutContestPrizesInput>
  }

  export type ContestUpdateWithoutContestPrizesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedContestsNestedInput
    participants?: ContestParticipantUpdateManyWithoutContestNestedInput
    votes?: VoteUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUpdateManyWithoutContestNestedInput
    recurringData?: RecurringContestDataUpdateOneWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateWithoutContestPrizesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ContestParticipantUncheckedUpdateManyWithoutContestNestedInput
    votes?: VoteUncheckedUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUncheckedUpdateManyWithoutContestNestedInput
    recurringData?: RecurringContestDataUncheckedUpdateOneWithoutContestNestedInput
  }

  export type ContestPhotoCreateWithoutAchievementsInput = {
    id?: string
    title?: string | null
    contestId: string
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participant: ContestParticipantCreateNestedOneWithoutPhotosInput
    votes?: VoteCreateNestedManyWithoutPhotoInput
    photo: UserPhotoCreateNestedOneWithoutContestUploadInput
    comments?: CommentCreateNestedManyWithoutReceiverInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoUncheckedCreateWithoutAchievementsInput = {
    id?: string
    title?: string | null
    contestId: string
    participantId: string
    photoId: string
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutPhotoInput
    comments?: CommentUncheckedCreateNestedManyWithoutReceiverInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoCreateOrConnectWithoutAchievementsInput = {
    where: ContestPhotoWhereUniqueInput
    create: XOR<ContestPhotoCreateWithoutAchievementsInput, ContestPhotoUncheckedCreateWithoutAchievementsInput>
  }

  export type ContestParticipantCreateWithoutContestAchievementInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    level?: $Enums.ContestLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contest: ContestCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutContestParticipantInput
    photos?: ContestPhotoCreateNestedManyWithoutParticipantInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantUncheckedCreateWithoutContestAchievementInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    contestId: string
    userId: string
    level?: $Enums.ContestLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ContestPhotoUncheckedCreateNestedManyWithoutParticipantInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantCreateOrConnectWithoutContestAchievementInput = {
    where: ContestParticipantWhereUniqueInput
    create: XOR<ContestParticipantCreateWithoutContestAchievementInput, ContestParticipantUncheckedCreateWithoutContestAchievementInput>
  }

  export type ContestPhotoUpsertWithoutAchievementsInput = {
    update: XOR<ContestPhotoUpdateWithoutAchievementsInput, ContestPhotoUncheckedUpdateWithoutAchievementsInput>
    create: XOR<ContestPhotoCreateWithoutAchievementsInput, ContestPhotoUncheckedCreateWithoutAchievementsInput>
    where?: ContestPhotoWhereInput
  }

  export type ContestPhotoUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: ContestPhotoWhereInput
    data: XOR<ContestPhotoUpdateWithoutAchievementsInput, ContestPhotoUncheckedUpdateWithoutAchievementsInput>
  }

  export type ContestPhotoUpdateWithoutAchievementsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ContestParticipantUpdateOneRequiredWithoutPhotosNestedInput
    votes?: VoteUpdateManyWithoutPhotoNestedInput
    photo?: UserPhotoUpdateOneRequiredWithoutContestUploadNestedInput
    comments?: CommentUpdateManyWithoutReceiverNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutPhotoNestedInput
  }

  export type ContestPhotoUncheckedUpdateWithoutAchievementsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutPhotoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutReceiverNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type ContestParticipantUpsertWithoutContestAchievementInput = {
    update: XOR<ContestParticipantUpdateWithoutContestAchievementInput, ContestParticipantUncheckedUpdateWithoutContestAchievementInput>
    create: XOR<ContestParticipantCreateWithoutContestAchievementInput, ContestParticipantUncheckedCreateWithoutContestAchievementInput>
    where?: ContestParticipantWhereInput
  }

  export type ContestParticipantUpdateToOneWithWhereWithoutContestAchievementInput = {
    where?: ContestParticipantWhereInput
    data: XOR<ContestParticipantUpdateWithoutContestAchievementInput, ContestParticipantUncheckedUpdateWithoutContestAchievementInput>
  }

  export type ContestParticipantUpdateWithoutContestAchievementInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    level?: EnumContestLevelFieldUpdateOperationsInput | $Enums.ContestLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contest?: ContestUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutContestParticipantNestedInput
    photos?: ContestPhotoUpdateManyWithoutParticipantNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutParticipantNestedInput
  }

  export type ContestParticipantUncheckedUpdateWithoutContestAchievementInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    contestId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    level?: EnumContestLevelFieldUpdateOperationsInput | $Enums.ContestLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ContestPhotoUncheckedUpdateManyWithoutParticipantNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type UserCreateWithoutCreatedTeamInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedTeamInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedTeamInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTeamInput, UserUncheckedCreateWithoutCreatedTeamInput>
  }

  export type TeamMemberCreateWithoutTeamInput = {
    id?: string
    status?: $Enums.TeamMemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    member: UserCreateNestedOneWithoutJoinedTeamInput
  }

  export type TeamMemberUncheckedCreateWithoutTeamInput = {
    id?: string
    status?: $Enums.TeamMemberStatus
    memberId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberCreateManyTeamInputEnvelope = {
    data: TeamMemberCreateManyTeamInput | TeamMemberCreateManyTeamInput[]
  }

  export type UserUpsertWithoutCreatedTeamInput = {
    update: XOR<UserUpdateWithoutCreatedTeamInput, UserUncheckedUpdateWithoutCreatedTeamInput>
    create: XOR<UserCreateWithoutCreatedTeamInput, UserUncheckedCreateWithoutCreatedTeamInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTeamInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTeamInput, UserUncheckedUpdateWithoutCreatedTeamInput>
  }

  export type UserUpdateWithoutCreatedTeamInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTeamInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamMemberScalarWhereInput = {
    AND?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    OR?: TeamMemberScalarWhereInput[]
    NOT?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    status?: EnumTeamMemberStatusFilter<"TeamMember"> | $Enums.TeamMemberStatus
    teamId?: StringFilter<"TeamMember"> | string
    memberId?: StringFilter<"TeamMember"> | string
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"TeamMember"> | Date | string
  }

  export type TeamCreateWithoutMembersInput = {
    id?: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility: $Enums.TeamAccessibility
    badge: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedTeamInput
  }

  export type TeamUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility: $Enums.TeamAccessibility
    badge: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamCreateOrConnectWithoutMembersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutJoinedTeamInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutJoinedTeamInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutJoinedTeamInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJoinedTeamInput, UserUncheckedCreateWithoutJoinedTeamInput>
  }

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type TeamUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    badge?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    badge?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutJoinedTeamInput = {
    update: XOR<UserUpdateWithoutJoinedTeamInput, UserUncheckedUpdateWithoutJoinedTeamInput>
    create: XOR<UserCreateWithoutJoinedTeamInput, UserUncheckedCreateWithoutJoinedTeamInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJoinedTeamInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJoinedTeamInput, UserUncheckedUpdateWithoutJoinedTeamInput>
  }

  export type UserUpdateWithoutJoinedTeamInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutJoinedTeamInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OtpCreateWithoutUserInput = {
    id?: string
    code: string
    expires_in: Date | string
    otpStatus?: $Enums.OtpStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
  }

  export type OtpUncheckedCreateWithoutUserInput = {
    id?: string
    code: string
    expires_in: Date | string
    otpStatus?: $Enums.OtpStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
  }

  export type OtpCreateOrConnectWithoutUserInput = {
    where: OtpWhereUniqueInput
    create: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput>
  }

  export type TeamCreateWithoutCreatorInput = {
    id?: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility: $Enums.TeamAccessibility
    badge: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility: $Enums.TeamAccessibility
    badge: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutCreatorInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutCreatorInput, TeamUncheckedCreateWithoutCreatorInput>
  }

  export type TeamCreateManyCreatorInputEnvelope = {
    data: TeamCreateManyCreatorInput | TeamCreateManyCreatorInput[]
  }

  export type TeamMemberCreateWithoutMemberInput = {
    id?: string
    status?: $Enums.TeamMemberStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
  }

  export type TeamMemberUncheckedCreateWithoutMemberInput = {
    id?: string
    status?: $Enums.TeamMemberStatus
    teamId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutMemberInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutMemberInput, TeamMemberUncheckedCreateWithoutMemberInput>
  }

  export type ContestCreateWithoutCreatorInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    maxUploads?: number | null
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ContestParticipantCreateNestedManyWithoutContestInput
    votes?: VoteCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeCreateNestedManyWithoutContestInput
    recurringData?: RecurringContestDataCreateNestedOneWithoutContestInput
  }

  export type ContestUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    maxUploads?: number | null
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ContestParticipantUncheckedCreateNestedManyWithoutContestInput
    votes?: VoteUncheckedCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleUncheckedCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeUncheckedCreateNestedManyWithoutContestInput
    recurringData?: RecurringContestDataUncheckedCreateNestedOneWithoutContestInput
  }

  export type ContestCreateOrConnectWithoutCreatorInput = {
    where: ContestWhereUniqueInput
    create: XOR<ContestCreateWithoutCreatorInput, ContestUncheckedCreateWithoutCreatorInput>
  }

  export type ContestCreateManyCreatorInputEnvelope = {
    data: ContestCreateManyCreatorInput | ContestCreateManyCreatorInput[]
  }

  export type CommentCreateWithoutProviderInput = {
    id?: string
    text: string
    createdAt?: Date | string
    updatedAt?: Date | string
    receiver: ContestPhotoCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutProviderInput = {
    id?: string
    text: string
    receiverId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutProviderInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutProviderInput, CommentUncheckedCreateWithoutProviderInput>
  }

  export type CommentCreateManyProviderInputEnvelope = {
    data: CommentCreateManyProviderInput | CommentCreateManyProviderInput[]
  }

  export type FollowCreateWithoutFollowerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    following: UserCreateNestedOneWithoutFollowingsInput
  }

  export type FollowUncheckedCreateWithoutFollowerInput = {
    id?: string
    followingId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowCreateOrConnectWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowCreateManyFollowerInputEnvelope = {
    data: FollowCreateManyFollowerInput | FollowCreateManyFollowerInput[]
  }

  export type FollowCreateWithoutFollowingInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    follower: UserCreateNestedOneWithoutFollowersInput
  }

  export type FollowUncheckedCreateWithoutFollowingInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowCreateOrConnectWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowCreateManyFollowingInputEnvelope = {
    data: FollowCreateManyFollowingInput | FollowCreateManyFollowingInput[]
  }

  export type VoteCreateWithoutProviderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    photo: ContestPhotoCreateNestedOneWithoutVotesInput
    contest: ContestCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateWithoutProviderInput = {
    id?: string
    photoId: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteCreateOrConnectWithoutProviderInput = {
    where: VoteWhereUniqueInput
    create: XOR<VoteCreateWithoutProviderInput, VoteUncheckedCreateWithoutProviderInput>
  }

  export type VoteCreateManyProviderInputEnvelope = {
    data: VoteCreateManyProviderInput | VoteCreateManyProviderInput[]
  }

  export type LikeCreateWithoutProviderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    photo: UserPhotoCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutProviderInput = {
    id?: string
    photoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutProviderInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutProviderInput, LikeUncheckedCreateWithoutProviderInput>
  }

  export type LikeCreateManyProviderInputEnvelope = {
    data: LikeCreateManyProviderInput | LikeCreateManyProviderInput[]
  }

  export type UserPhotoCreateWithoutUserInput = {
    id?: string
    url: string
    states?: XOR<PhotoStatsNullableCreateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: number
    labels?: UserPhotoCreatelabelsInput | string[]
    title?: string | null
    description?: string | null
    adult?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contestUpload?: ContestPhotoCreateNestedManyWithoutPhotoInput
    likes?: LikeCreateNestedManyWithoutPhotoInput
  }

  export type UserPhotoUncheckedCreateWithoutUserInput = {
    id?: string
    url: string
    states?: XOR<PhotoStatsNullableCreateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: number
    labels?: UserPhotoCreatelabelsInput | string[]
    title?: string | null
    description?: string | null
    adult?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contestUpload?: ContestPhotoUncheckedCreateNestedManyWithoutPhotoInput
    likes?: LikeUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type UserPhotoCreateOrConnectWithoutUserInput = {
    where: UserPhotoWhereUniqueInput
    create: XOR<UserPhotoCreateWithoutUserInput, UserPhotoUncheckedCreateWithoutUserInput>
  }

  export type UserPhotoCreateManyUserInputEnvelope = {
    data: UserPhotoCreateManyUserInput | UserPhotoCreateManyUserInput[]
  }

  export type ContestParticipantCreateWithoutUserInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    level?: $Enums.ContestLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contest: ContestCreateNestedOneWithoutParticipantsInput
    photos?: ContestPhotoCreateNestedManyWithoutParticipantInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    contestId: string
    level?: $Enums.ContestLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ContestPhotoUncheckedCreateNestedManyWithoutParticipantInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutParticipantInput
    contestAchievement?: ContestAchievementUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ContestParticipantCreateOrConnectWithoutUserInput = {
    where: ContestParticipantWhereUniqueInput
    create: XOR<ContestParticipantCreateWithoutUserInput, ContestParticipantUncheckedCreateWithoutUserInput>
  }

  export type ContestParticipantCreateManyUserInputEnvelope = {
    data: ContestParticipantCreateManyUserInput | ContestParticipantCreateManyUserInput[]
  }

  export type OtpUpsertWithoutUserInput = {
    update: XOR<OtpUpdateWithoutUserInput, OtpUncheckedUpdateWithoutUserInput>
    create: XOR<OtpCreateWithoutUserInput, OtpUncheckedCreateWithoutUserInput>
    where?: OtpWhereInput
  }

  export type OtpUpdateToOneWithWhereWithoutUserInput = {
    where?: OtpWhereInput
    data: XOR<OtpUpdateWithoutUserInput, OtpUncheckedUpdateWithoutUserInput>
  }

  export type OtpUpdateWithoutUserInput = {
    code?: StringFieldUpdateOperationsInput | string
    expires_in?: DateTimeFieldUpdateOperationsInput | Date | string
    otpStatus?: EnumOtpStatusFieldUpdateOperationsInput | $Enums.OtpStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUncheckedUpdateWithoutUserInput = {
    code?: StringFieldUpdateOperationsInput | string
    expires_in?: DateTimeFieldUpdateOperationsInput | Date | string
    otpStatus?: EnumOtpStatusFieldUpdateOperationsInput | $Enums.OtpStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutCreatorInput, TeamUncheckedUpdateWithoutCreatorInput>
    create: XOR<TeamCreateWithoutCreatorInput, TeamUncheckedCreateWithoutCreatorInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutCreatorInput, TeamUncheckedUpdateWithoutCreatorInput>
  }

  export type TeamUpdateManyWithWhereWithoutCreatorInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    level?: StringFilter<"Team"> | string
    language?: StringFilter<"Team"> | string
    country?: StringFilter<"Team"> | string
    description?: StringFilter<"Team"> | string
    accessibility?: EnumTeamAccessibilityFilter<"Team"> | $Enums.TeamAccessibility
    badge?: StringFilter<"Team"> | string
    creatorId?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
  }

  export type TeamMemberUpsertWithoutMemberInput = {
    update: XOR<TeamMemberUpdateWithoutMemberInput, TeamMemberUncheckedUpdateWithoutMemberInput>
    create: XOR<TeamMemberCreateWithoutMemberInput, TeamMemberUncheckedCreateWithoutMemberInput>
    where?: TeamMemberWhereInput
  }

  export type TeamMemberUpdateToOneWithWhereWithoutMemberInput = {
    where?: TeamMemberWhereInput
    data: XOR<TeamMemberUpdateWithoutMemberInput, TeamMemberUncheckedUpdateWithoutMemberInput>
  }

  export type TeamMemberUpdateWithoutMemberInput = {
    status?: EnumTeamMemberStatusFieldUpdateOperationsInput | $Enums.TeamMemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutMemberInput = {
    status?: EnumTeamMemberStatusFieldUpdateOperationsInput | $Enums.TeamMemberStatus
    teamId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ContestWhereUniqueInput
    update: XOR<ContestUpdateWithoutCreatorInput, ContestUncheckedUpdateWithoutCreatorInput>
    create: XOR<ContestCreateWithoutCreatorInput, ContestUncheckedCreateWithoutCreatorInput>
  }

  export type ContestUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ContestWhereUniqueInput
    data: XOR<ContestUpdateWithoutCreatorInput, ContestUncheckedUpdateWithoutCreatorInput>
  }

  export type ContestUpdateManyWithWhereWithoutCreatorInput = {
    where: ContestScalarWhereInput
    data: XOR<ContestUpdateManyMutationInput, ContestUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ContestScalarWhereInput = {
    AND?: ContestScalarWhereInput | ContestScalarWhereInput[]
    OR?: ContestScalarWhereInput[]
    NOT?: ContestScalarWhereInput | ContestScalarWhereInput[]
    id?: StringFilter<"Contest"> | string
    title?: StringFilter<"Contest"> | string
    description?: StringFilter<"Contest"> | string
    banner?: StringNullableFilter<"Contest"> | string | null
    status?: EnumContestStatusFilter<"Contest"> | $Enums.ContestStatus
    maxUploads?: IntNullableFilter<"Contest"> | number | null
    isMoneyContest?: BoolFilter<"Contest"> | boolean
    maxPrize?: IntNullableFilter<"Contest"> | number | null
    minPrize?: IntNullableFilter<"Contest"> | number | null
    startDate?: DateTimeFilter<"Contest"> | Date | string
    endDate?: DateTimeFilter<"Contest"> | Date | string
    creatorId?: StringFilter<"Contest"> | string
    createdAt?: DateTimeFilter<"Contest"> | Date | string
    updatedAt?: DateTimeFilter<"Contest"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutProviderInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutProviderInput, CommentUncheckedUpdateWithoutProviderInput>
    create: XOR<CommentCreateWithoutProviderInput, CommentUncheckedCreateWithoutProviderInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutProviderInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutProviderInput, CommentUncheckedUpdateWithoutProviderInput>
  }

  export type CommentUpdateManyWithWhereWithoutProviderInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutProviderInput>
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowerInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowerInput>
  }

  export type FollowScalarWhereInput = {
    AND?: FollowScalarWhereInput | FollowScalarWhereInput[]
    OR?: FollowScalarWhereInput[]
    NOT?: FollowScalarWhereInput | FollowScalarWhereInput[]
    id?: StringFilter<"Follow"> | string
    followerId?: StringFilter<"Follow"> | string
    followingId?: StringFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    updatedAt?: DateTimeFilter<"Follow"> | Date | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
    create: XOR<FollowCreateWithoutFollowingInput, FollowUncheckedCreateWithoutFollowingInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowingInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowingInput, FollowUncheckedUpdateWithoutFollowingInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowingInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowingInput>
  }

  export type VoteUpsertWithWhereUniqueWithoutProviderInput = {
    where: VoteWhereUniqueInput
    update: XOR<VoteUpdateWithoutProviderInput, VoteUncheckedUpdateWithoutProviderInput>
    create: XOR<VoteCreateWithoutProviderInput, VoteUncheckedCreateWithoutProviderInput>
  }

  export type VoteUpdateWithWhereUniqueWithoutProviderInput = {
    where: VoteWhereUniqueInput
    data: XOR<VoteUpdateWithoutProviderInput, VoteUncheckedUpdateWithoutProviderInput>
  }

  export type VoteUpdateManyWithWhereWithoutProviderInput = {
    where: VoteScalarWhereInput
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyWithoutProviderInput>
  }

  export type LikeUpsertWithWhereUniqueWithoutProviderInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutProviderInput, LikeUncheckedUpdateWithoutProviderInput>
    create: XOR<LikeCreateWithoutProviderInput, LikeUncheckedCreateWithoutProviderInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutProviderInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutProviderInput, LikeUncheckedUpdateWithoutProviderInput>
  }

  export type LikeUpdateManyWithWhereWithoutProviderInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutProviderInput>
  }

  export type LikeScalarWhereInput = {
    AND?: LikeScalarWhereInput | LikeScalarWhereInput[]
    OR?: LikeScalarWhereInput[]
    NOT?: LikeScalarWhereInput | LikeScalarWhereInput[]
    id?: StringFilter<"Like"> | string
    providerId?: StringFilter<"Like"> | string
    photoId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    updatedAt?: DateTimeFilter<"Like"> | Date | string
  }

  export type UserPhotoUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPhotoWhereUniqueInput
    update: XOR<UserPhotoUpdateWithoutUserInput, UserPhotoUncheckedUpdateWithoutUserInput>
    create: XOR<UserPhotoCreateWithoutUserInput, UserPhotoUncheckedCreateWithoutUserInput>
  }

  export type UserPhotoUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPhotoWhereUniqueInput
    data: XOR<UserPhotoUpdateWithoutUserInput, UserPhotoUncheckedUpdateWithoutUserInput>
  }

  export type UserPhotoUpdateManyWithWhereWithoutUserInput = {
    where: UserPhotoScalarWhereInput
    data: XOR<UserPhotoUpdateManyMutationInput, UserPhotoUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPhotoScalarWhereInput = {
    AND?: UserPhotoScalarWhereInput | UserPhotoScalarWhereInput[]
    OR?: UserPhotoScalarWhereInput[]
    NOT?: UserPhotoScalarWhereInput | UserPhotoScalarWhereInput[]
    id?: StringFilter<"UserPhoto"> | string
    url?: StringFilter<"UserPhoto"> | string
    userId?: StringFilter<"UserPhoto"> | string
    views?: IntFilter<"UserPhoto"> | number
    labels?: StringNullableListFilter<"UserPhoto">
    title?: StringNullableFilter<"UserPhoto"> | string | null
    description?: StringNullableFilter<"UserPhoto"> | string | null
    adult?: BoolFilter<"UserPhoto"> | boolean
    createdAt?: DateTimeFilter<"UserPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"UserPhoto"> | Date | string
  }

  export type ContestParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: ContestParticipantWhereUniqueInput
    update: XOR<ContestParticipantUpdateWithoutUserInput, ContestParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<ContestParticipantCreateWithoutUserInput, ContestParticipantUncheckedCreateWithoutUserInput>
  }

  export type ContestParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: ContestParticipantWhereUniqueInput
    data: XOR<ContestParticipantUpdateWithoutUserInput, ContestParticipantUncheckedUpdateWithoutUserInput>
  }

  export type ContestParticipantUpdateManyWithWhereWithoutUserInput = {
    where: ContestParticipantScalarWhereInput
    data: XOR<ContestParticipantUpdateManyMutationInput, ContestParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCreateWithoutUserPhotosInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserPhotosInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserPhotosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPhotosInput, UserUncheckedCreateWithoutUserPhotosInput>
  }

  export type ContestPhotoCreateWithoutPhotoInput = {
    id?: string
    title?: string | null
    contestId: string
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participant: ContestParticipantCreateNestedOneWithoutPhotosInput
    votes?: VoteCreateNestedManyWithoutPhotoInput
    comments?: CommentCreateNestedManyWithoutReceiverInput
    achievements?: ContestAchievementCreateNestedManyWithoutPhotoInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoUncheckedCreateWithoutPhotoInput = {
    id?: string
    title?: string | null
    contestId: string
    participantId: string
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutPhotoInput
    comments?: CommentUncheckedCreateNestedManyWithoutReceiverInput
    achievements?: ContestAchievementUncheckedCreateNestedManyWithoutPhotoInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoCreateOrConnectWithoutPhotoInput = {
    where: ContestPhotoWhereUniqueInput
    create: XOR<ContestPhotoCreateWithoutPhotoInput, ContestPhotoUncheckedCreateWithoutPhotoInput>
  }

  export type ContestPhotoCreateManyPhotoInputEnvelope = {
    data: ContestPhotoCreateManyPhotoInput | ContestPhotoCreateManyPhotoInput[]
  }

  export type LikeCreateWithoutPhotoInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: UserCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutPhotoInput = {
    id?: string
    providerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutPhotoInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutPhotoInput, LikeUncheckedCreateWithoutPhotoInput>
  }

  export type LikeCreateManyPhotoInputEnvelope = {
    data: LikeCreateManyPhotoInput | LikeCreateManyPhotoInput[]
  }

  export type PhotoStatsUpsertInput = {
    set: PhotoStatsCreateInput | null
    update: PhotoStatsUpdateInput
  }

  export type UserUpsertWithoutUserPhotosInput = {
    update: XOR<UserUpdateWithoutUserPhotosInput, UserUncheckedUpdateWithoutUserPhotosInput>
    create: XOR<UserCreateWithoutUserPhotosInput, UserUncheckedCreateWithoutUserPhotosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserPhotosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserPhotosInput, UserUncheckedUpdateWithoutUserPhotosInput>
  }

  export type UserUpdateWithoutUserPhotosInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserPhotosInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContestPhotoUpsertWithWhereUniqueWithoutPhotoInput = {
    where: ContestPhotoWhereUniqueInput
    update: XOR<ContestPhotoUpdateWithoutPhotoInput, ContestPhotoUncheckedUpdateWithoutPhotoInput>
    create: XOR<ContestPhotoCreateWithoutPhotoInput, ContestPhotoUncheckedCreateWithoutPhotoInput>
  }

  export type ContestPhotoUpdateWithWhereUniqueWithoutPhotoInput = {
    where: ContestPhotoWhereUniqueInput
    data: XOR<ContestPhotoUpdateWithoutPhotoInput, ContestPhotoUncheckedUpdateWithoutPhotoInput>
  }

  export type ContestPhotoUpdateManyWithWhereWithoutPhotoInput = {
    where: ContestPhotoScalarWhereInput
    data: XOR<ContestPhotoUpdateManyMutationInput, ContestPhotoUncheckedUpdateManyWithoutPhotoInput>
  }

  export type LikeUpsertWithWhereUniqueWithoutPhotoInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutPhotoInput, LikeUncheckedUpdateWithoutPhotoInput>
    create: XOR<LikeCreateWithoutPhotoInput, LikeUncheckedCreateWithoutPhotoInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutPhotoInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutPhotoInput, LikeUncheckedUpdateWithoutPhotoInput>
  }

  export type LikeUpdateManyWithWhereWithoutPhotoInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutPhotoInput>
  }

  export type UserCreateWithoutLikesInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLikesInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
  }

  export type UserPhotoCreateWithoutLikesInput = {
    id?: string
    url: string
    states?: XOR<PhotoStatsNullableCreateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: number
    labels?: UserPhotoCreatelabelsInput | string[]
    title?: string | null
    description?: string | null
    adult?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserPhotosInput
    contestUpload?: ContestPhotoCreateNestedManyWithoutPhotoInput
  }

  export type UserPhotoUncheckedCreateWithoutLikesInput = {
    id?: string
    url: string
    userId: string
    states?: XOR<PhotoStatsNullableCreateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: number
    labels?: UserPhotoCreatelabelsInput | string[]
    title?: string | null
    description?: string | null
    adult?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contestUpload?: ContestPhotoUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type UserPhotoCreateOrConnectWithoutLikesInput = {
    where: UserPhotoWhereUniqueInput
    create: XOR<UserPhotoCreateWithoutLikesInput, UserPhotoUncheckedCreateWithoutLikesInput>
  }

  export type UserUpsertWithoutLikesInput = {
    update: XOR<UserUpdateWithoutLikesInput, UserUncheckedUpdateWithoutLikesInput>
    create: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikesInput, UserUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateWithoutLikesInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLikesInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserPhotoUpsertWithoutLikesInput = {
    update: XOR<UserPhotoUpdateWithoutLikesInput, UserPhotoUncheckedUpdateWithoutLikesInput>
    create: XOR<UserPhotoCreateWithoutLikesInput, UserPhotoUncheckedCreateWithoutLikesInput>
    where?: UserPhotoWhereInput
  }

  export type UserPhotoUpdateToOneWithWhereWithoutLikesInput = {
    where?: UserPhotoWhereInput
    data: XOR<UserPhotoUpdateWithoutLikesInput, UserPhotoUncheckedUpdateWithoutLikesInput>
  }

  export type UserPhotoUpdateWithoutLikesInput = {
    url?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserPhotosNestedInput
    contestUpload?: ContestPhotoUpdateManyWithoutPhotoNestedInput
  }

  export type UserPhotoUncheckedUpdateWithoutLikesInput = {
    url?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contestUpload?: ContestPhotoUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type UserCreateWithoutOtpsInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOtpsInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOtpsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
  }

  export type UserUpsertWithoutOtpsInput = {
    update: XOR<UserUpdateWithoutOtpsInput, UserUncheckedUpdateWithoutOtpsInput>
    create: XOR<UserCreateWithoutOtpsInput, UserUncheckedCreateWithoutOtpsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOtpsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOtpsInput, UserUncheckedUpdateWithoutOtpsInput>
  }

  export type UserUpdateWithoutOtpsInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOtpsInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCommentProvidesInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentProvidesInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentProvidesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentProvidesInput, UserUncheckedCreateWithoutCommentProvidesInput>
  }

  export type ContestPhotoCreateWithoutCommentsInput = {
    id?: string
    title?: string | null
    contestId: string
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participant: ContestParticipantCreateNestedOneWithoutPhotosInput
    votes?: VoteCreateNestedManyWithoutPhotoInput
    photo: UserPhotoCreateNestedOneWithoutContestUploadInput
    achievements?: ContestAchievementCreateNestedManyWithoutPhotoInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoUncheckedCreateWithoutCommentsInput = {
    id?: string
    title?: string | null
    contestId: string
    participantId: string
    photoId: string
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: VoteUncheckedCreateNestedManyWithoutPhotoInput
    achievements?: ContestAchievementUncheckedCreateNestedManyWithoutPhotoInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoCreateOrConnectWithoutCommentsInput = {
    where: ContestPhotoWhereUniqueInput
    create: XOR<ContestPhotoCreateWithoutCommentsInput, ContestPhotoUncheckedCreateWithoutCommentsInput>
  }

  export type UserUpsertWithoutCommentProvidesInput = {
    update: XOR<UserUpdateWithoutCommentProvidesInput, UserUncheckedUpdateWithoutCommentProvidesInput>
    create: XOR<UserCreateWithoutCommentProvidesInput, UserUncheckedCreateWithoutCommentProvidesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentProvidesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentProvidesInput, UserUncheckedUpdateWithoutCommentProvidesInput>
  }

  export type UserUpdateWithoutCommentProvidesInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentProvidesInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContestPhotoUpsertWithoutCommentsInput = {
    update: XOR<ContestPhotoUpdateWithoutCommentsInput, ContestPhotoUncheckedUpdateWithoutCommentsInput>
    create: XOR<ContestPhotoCreateWithoutCommentsInput, ContestPhotoUncheckedCreateWithoutCommentsInput>
    where?: ContestPhotoWhereInput
  }

  export type ContestPhotoUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ContestPhotoWhereInput
    data: XOR<ContestPhotoUpdateWithoutCommentsInput, ContestPhotoUncheckedUpdateWithoutCommentsInput>
  }

  export type ContestPhotoUpdateWithoutCommentsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ContestParticipantUpdateOneRequiredWithoutPhotosNestedInput
    votes?: VoteUpdateManyWithoutPhotoNestedInput
    photo?: UserPhotoUpdateOneRequiredWithoutContestUploadNestedInput
    achievements?: ContestAchievementUpdateManyWithoutPhotoNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutPhotoNestedInput
  }

  export type ContestPhotoUncheckedUpdateWithoutCommentsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutPhotoNestedInput
    achievements?: ContestAchievementUncheckedUpdateManyWithoutPhotoNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type UserCreateWithoutFollowersInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFollowersInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFollowersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
  }

  export type UserCreateWithoutFollowingsInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    votes?: VoteCreateNestedManyWithoutProviderInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFollowingsInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    votes?: VoteUncheckedCreateNestedManyWithoutProviderInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFollowingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingsInput, UserUncheckedCreateWithoutFollowingsInput>
  }

  export type UserUpsertWithoutFollowersInput = {
    update: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserUpdateWithoutFollowersInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowersInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutFollowingsInput = {
    update: XOR<UserUpdateWithoutFollowingsInput, UserUncheckedUpdateWithoutFollowingsInput>
    create: XOR<UserCreateWithoutFollowingsInput, UserUncheckedCreateWithoutFollowingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowingsInput, UserUncheckedUpdateWithoutFollowingsInput>
  }

  export type UserUpdateWithoutFollowingsInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    votes?: VoteUpdateManyWithoutProviderNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowingsInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    votes?: VoteUncheckedUpdateManyWithoutProviderNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutVotesInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpCreateNestedOneWithoutUserInput
    createdTeam?: TeamCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberCreateNestedOneWithoutMemberInput
    createdContests?: ContestCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentCreateNestedManyWithoutProviderInput
    followers?: FollowCreateNestedManyWithoutFollowerInput
    followings?: FollowCreateNestedManyWithoutFollowingInput
    likes?: LikeCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVotesInput = {
    id?: string
    cover?: string | null
    avatar?: string | null
    socialId?: string | null
    socialProvider?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    username?: string | null
    phone?: string | null
    email: string
    location?: string | null
    level?: $Enums.UserLevel | null
    password?: string | null
    role?: $Enums.UserRole
    accessToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    otps?: OtpUncheckedCreateNestedOneWithoutUserInput
    createdTeam?: TeamUncheckedCreateNestedManyWithoutCreatorInput
    joinedTeam?: TeamMemberUncheckedCreateNestedOneWithoutMemberInput
    createdContests?: ContestUncheckedCreateNestedManyWithoutCreatorInput
    commentProvides?: CommentUncheckedCreateNestedManyWithoutProviderInput
    followers?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followings?: FollowUncheckedCreateNestedManyWithoutFollowingInput
    likes?: LikeUncheckedCreateNestedManyWithoutProviderInput
    userPhotos?: UserPhotoUncheckedCreateNestedManyWithoutUserInput
    ContestParticipant?: ContestParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
  }

  export type ContestPhotoCreateWithoutVotesInput = {
    id?: string
    title?: string | null
    contestId: string
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participant: ContestParticipantCreateNestedOneWithoutPhotosInput
    photo: UserPhotoCreateNestedOneWithoutContestUploadInput
    comments?: CommentCreateNestedManyWithoutReceiverInput
    achievements?: ContestAchievementCreateNestedManyWithoutPhotoInput
    ContestWinner?: ContestWinnerCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoUncheckedCreateWithoutVotesInput = {
    id?: string
    title?: string | null
    contestId: string
    participantId: string
    photoId: string
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutReceiverInput
    achievements?: ContestAchievementUncheckedCreateNestedManyWithoutPhotoInput
    ContestWinner?: ContestWinnerUncheckedCreateNestedManyWithoutPhotoInput
  }

  export type ContestPhotoCreateOrConnectWithoutVotesInput = {
    where: ContestPhotoWhereUniqueInput
    create: XOR<ContestPhotoCreateWithoutVotesInput, ContestPhotoUncheckedCreateWithoutVotesInput>
  }

  export type ContestCreateWithoutVotesInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    maxUploads?: number | null
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedContestsInput
    participants?: ContestParticipantCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeCreateNestedManyWithoutContestInput
    recurringData?: RecurringContestDataCreateNestedOneWithoutContestInput
  }

  export type ContestUncheckedCreateWithoutVotesInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    maxUploads?: number | null
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    startDate: Date | string
    endDate: Date | string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ContestParticipantUncheckedCreateNestedManyWithoutContestInput
    contestRules?: ContestRuleUncheckedCreateNestedManyWithoutContestInput
    contestPrizes?: ContestPrizeUncheckedCreateNestedManyWithoutContestInput
    recurringData?: RecurringContestDataUncheckedCreateNestedOneWithoutContestInput
  }

  export type ContestCreateOrConnectWithoutVotesInput = {
    where: ContestWhereUniqueInput
    create: XOR<ContestCreateWithoutVotesInput, ContestUncheckedCreateWithoutVotesInput>
  }

  export type UserUpsertWithoutVotesInput = {
    update: XOR<UserUpdateWithoutVotesInput, UserUncheckedUpdateWithoutVotesInput>
    create: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVotesInput, UserUncheckedUpdateWithoutVotesInput>
  }

  export type UserUpdateWithoutVotesInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUpdateManyWithoutProviderNestedInput
    followers?: FollowUpdateManyWithoutFollowerNestedInput
    followings?: FollowUpdateManyWithoutFollowingNestedInput
    likes?: LikeUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVotesInput = {
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: NullableStringFieldUpdateOperationsInput | string | null
    socialProvider?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableEnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otps?: OtpUncheckedUpdateOneWithoutUserNestedInput
    createdTeam?: TeamUncheckedUpdateManyWithoutCreatorNestedInput
    joinedTeam?: TeamMemberUncheckedUpdateOneWithoutMemberNestedInput
    createdContests?: ContestUncheckedUpdateManyWithoutCreatorNestedInput
    commentProvides?: CommentUncheckedUpdateManyWithoutProviderNestedInput
    followers?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followings?: FollowUncheckedUpdateManyWithoutFollowingNestedInput
    likes?: LikeUncheckedUpdateManyWithoutProviderNestedInput
    userPhotos?: UserPhotoUncheckedUpdateManyWithoutUserNestedInput
    ContestParticipant?: ContestParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContestPhotoUpsertWithoutVotesInput = {
    update: XOR<ContestPhotoUpdateWithoutVotesInput, ContestPhotoUncheckedUpdateWithoutVotesInput>
    create: XOR<ContestPhotoCreateWithoutVotesInput, ContestPhotoUncheckedCreateWithoutVotesInput>
    where?: ContestPhotoWhereInput
  }

  export type ContestPhotoUpdateToOneWithWhereWithoutVotesInput = {
    where?: ContestPhotoWhereInput
    data: XOR<ContestPhotoUpdateWithoutVotesInput, ContestPhotoUncheckedUpdateWithoutVotesInput>
  }

  export type ContestPhotoUpdateWithoutVotesInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ContestParticipantUpdateOneRequiredWithoutPhotosNestedInput
    photo?: UserPhotoUpdateOneRequiredWithoutContestUploadNestedInput
    comments?: CommentUpdateManyWithoutReceiverNestedInput
    achievements?: ContestAchievementUpdateManyWithoutPhotoNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutPhotoNestedInput
  }

  export type ContestPhotoUncheckedUpdateWithoutVotesInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutReceiverNestedInput
    achievements?: ContestAchievementUncheckedUpdateManyWithoutPhotoNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type ContestUpsertWithoutVotesInput = {
    update: XOR<ContestUpdateWithoutVotesInput, ContestUncheckedUpdateWithoutVotesInput>
    create: XOR<ContestCreateWithoutVotesInput, ContestUncheckedCreateWithoutVotesInput>
    where?: ContestWhereInput
  }

  export type ContestUpdateToOneWithWhereWithoutVotesInput = {
    where?: ContestWhereInput
    data: XOR<ContestUpdateWithoutVotesInput, ContestUncheckedUpdateWithoutVotesInput>
  }

  export type ContestUpdateWithoutVotesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedContestsNestedInput
    participants?: ContestParticipantUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUpdateManyWithoutContestNestedInput
    recurringData?: RecurringContestDataUpdateOneWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateWithoutVotesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ContestParticipantUncheckedUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUncheckedUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUncheckedUpdateManyWithoutContestNestedInput
    recurringData?: RecurringContestDataUncheckedUpdateOneWithoutContestNestedInput
  }

  export type EnumRecurringTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurringType | EnumRecurringTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RecurringType[] | ListEnumRecurringTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecurringType[] | ListEnumRecurringTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurringTypeFilter<$PrismaModel> | $Enums.RecurringType
  }

  export type ContestParticipantCreateManyContestInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    userId: string
    level?: $Enums.ContestLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteCreateManyContestInput = {
    id?: string
    providerId: string
    photoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestRuleCreateManyContestInput = {
    id?: string
    icon?: string | null
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestPrizeCreateManyContestInput = {
    id?: string
    category: $Enums.PrizeType
    trades?: number
    charges?: number
    keys?: number
  }

  export type ContestParticipantUpdateWithoutContestInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    level?: EnumContestLevelFieldUpdateOperationsInput | $Enums.ContestLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContestParticipantNestedInput
    photos?: ContestPhotoUpdateManyWithoutParticipantNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUpdateManyWithoutParticipantNestedInput
  }

  export type ContestParticipantUncheckedUpdateWithoutContestInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    userId?: StringFieldUpdateOperationsInput | string
    level?: EnumContestLevelFieldUpdateOperationsInput | $Enums.ContestLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ContestPhotoUncheckedUpdateManyWithoutParticipantNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type ContestParticipantUncheckedUpdateManyWithoutContestInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    userId?: StringFieldUpdateOperationsInput | string
    level?: EnumContestLevelFieldUpdateOperationsInput | $Enums.ContestLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUpdateWithoutContestInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: UserUpdateOneRequiredWithoutVotesNestedInput
    photo?: ContestPhotoUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateWithoutContestInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUncheckedUpdateManyWithoutContestInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestRuleUpdateWithoutContestInput = {
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestRuleUncheckedUpdateWithoutContestInput = {
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestRuleUncheckedUpdateManyWithoutContestInput = {
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestPrizeUpdateWithoutContestInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    trades?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    keys?: IntFieldUpdateOperationsInput | number
  }

  export type ContestPrizeUncheckedUpdateWithoutContestInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    trades?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    keys?: IntFieldUpdateOperationsInput | number
  }

  export type ContestPrizeUncheckedUpdateManyWithoutContestInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    trades?: IntFieldUpdateOperationsInput | number
    charges?: IntFieldUpdateOperationsInput | number
    keys?: IntFieldUpdateOperationsInput | number
  }

  export type EnumRecurringTypeFieldUpdateOperationsInput = {
    set?: $Enums.RecurringType
  }

  export type VoteCreateManyPhotoInput = {
    id?: string
    providerId: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyReceiverInput = {
    id?: string
    text: string
    providerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestAchievementCreateManyPhotoInput = {
    id?: string
    category: $Enums.PrizeType
    participantId?: string | null
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestWinnerCreateManyPhotoInput = {
    id?: string
    participantId: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteUpdateWithoutPhotoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: UserUpdateOneRequiredWithoutVotesNestedInput
    contest?: ContestUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateWithoutPhotoInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUncheckedUpdateManyWithoutPhotoInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutReceiverInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: UserUpdateOneRequiredWithoutCommentProvidesNestedInput
  }

  export type CommentUncheckedUpdateWithoutReceiverInput = {
    text?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutReceiverInput = {
    text?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestAchievementUpdateWithoutPhotoInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ContestParticipantUpdateOneWithoutContestAchievementNestedInput
  }

  export type ContestAchievementUncheckedUpdateWithoutPhotoInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestAchievementUncheckedUpdateManyWithoutPhotoInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    participantId?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestWinnerUpdateWithoutPhotoInput = {
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ContestParticipantUpdateOneRequiredWithoutContestWinnerNestedInput
  }

  export type ContestWinnerUncheckedUpdateWithoutPhotoInput = {
    participantId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestWinnerUncheckedUpdateManyWithoutPhotoInput = {
    participantId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestPhotoCreateManyParticipantInput = {
    id?: string
    title?: string | null
    contestId: string
    photoId: string
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestWinnerCreateManyParticipantInput = {
    id?: string
    contestId: string
    contestPhotoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestAchievementCreateManyParticipantInput = {
    id?: string
    category: $Enums.PrizeType
    photoId?: string | null
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestPhotoUpdateWithoutParticipantInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUpdateManyWithoutPhotoNestedInput
    photo?: UserPhotoUpdateOneRequiredWithoutContestUploadNestedInput
    comments?: CommentUpdateManyWithoutReceiverNestedInput
    achievements?: ContestAchievementUpdateManyWithoutPhotoNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutPhotoNestedInput
  }

  export type ContestPhotoUncheckedUpdateWithoutParticipantInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutPhotoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutReceiverNestedInput
    achievements?: ContestAchievementUncheckedUpdateManyWithoutPhotoNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type ContestPhotoUncheckedUpdateManyWithoutParticipantInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    photoId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestWinnerUpdateWithoutParticipantInput = {
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: ContestPhotoUpdateOneRequiredWithoutContestWinnerNestedInput
  }

  export type ContestWinnerUncheckedUpdateWithoutParticipantInput = {
    contestId?: StringFieldUpdateOperationsInput | string
    contestPhotoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestWinnerUncheckedUpdateManyWithoutParticipantInput = {
    contestId?: StringFieldUpdateOperationsInput | string
    contestPhotoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestAchievementUpdateWithoutParticipantInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: ContestPhotoUpdateOneWithoutAchievementsNestedInput
  }

  export type ContestAchievementUncheckedUpdateWithoutParticipantInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    photoId?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestAchievementUncheckedUpdateManyWithoutParticipantInput = {
    category?: EnumPrizeTypeFieldUpdateOperationsInput | $Enums.PrizeType
    photoId?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyTeamInput = {
    id?: string
    status?: $Enums.TeamMemberStatus
    memberId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateWithoutTeamInput = {
    status?: EnumTeamMemberStatusFieldUpdateOperationsInput | $Enums.TeamMemberStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: UserUpdateOneRequiredWithoutJoinedTeamNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutTeamInput = {
    status?: EnumTeamMemberStatusFieldUpdateOperationsInput | $Enums.TeamMemberStatus
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamInput = {
    status?: EnumTeamMemberStatusFieldUpdateOperationsInput | $Enums.TeamMemberStatus
    memberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateManyCreatorInput = {
    id?: string
    name: string
    level: string
    language: string
    country: string
    description: string
    accessibility: $Enums.TeamAccessibility
    badge: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestCreateManyCreatorInput = {
    id?: string
    title: string
    description: string
    banner?: string | null
    status?: $Enums.ContestStatus
    maxUploads?: number | null
    isMoneyContest?: boolean
    maxPrize?: number | null
    minPrize?: number | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyProviderInput = {
    id?: string
    text: string
    receiverId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowCreateManyFollowerInput = {
    id?: string
    followingId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowCreateManyFollowingInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteCreateManyProviderInput = {
    id?: string
    photoId: string
    contestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeCreateManyProviderInput = {
    id?: string
    photoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPhotoCreateManyUserInput = {
    id?: string
    url: string
    states?: XOR<PhotoStatsNullableCreateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: number
    labels?: UserPhotoCreatelabelsInput | string[]
    title?: string | null
    description?: string | null
    adult?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContestParticipantCreateManyUserInput = {
    id?: string
    status?: $Enums.ContestParticipantStatus
    contestId: string
    level?: $Enums.ContestLevel
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    badge?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    badge?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    accessibility?: EnumTeamAccessibilityFieldUpdateOperationsInput | $Enums.TeamAccessibility
    badge?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestUpdateWithoutCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ContestParticipantUpdateManyWithoutContestNestedInput
    votes?: VoteUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUpdateManyWithoutContestNestedInput
    recurringData?: RecurringContestDataUpdateOneWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateWithoutCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ContestParticipantUncheckedUpdateManyWithoutContestNestedInput
    votes?: VoteUncheckedUpdateManyWithoutContestNestedInput
    contestRules?: ContestRuleUncheckedUpdateManyWithoutContestNestedInput
    contestPrizes?: ContestPrizeUncheckedUpdateManyWithoutContestNestedInput
    recurringData?: RecurringContestDataUncheckedUpdateOneWithoutContestNestedInput
  }

  export type ContestUncheckedUpdateManyWithoutCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContestStatusFieldUpdateOperationsInput | $Enums.ContestStatus
    maxUploads?: NullableIntFieldUpdateOperationsInput | number | null
    isMoneyContest?: BoolFieldUpdateOperationsInput | boolean
    maxPrize?: NullableIntFieldUpdateOperationsInput | number | null
    minPrize?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutProviderInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: ContestPhotoUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutProviderInput = {
    text?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutProviderInput = {
    text?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFollowerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    following?: UserUpdateOneRequiredWithoutFollowingsNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowerInput = {
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowerInput = {
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFollowingInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UserUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowingInput = {
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowingInput = {
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUpdateWithoutProviderInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: ContestPhotoUpdateOneRequiredWithoutVotesNestedInput
    contest?: ContestUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateWithoutProviderInput = {
    photoId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUncheckedUpdateManyWithoutProviderInput = {
    photoId?: StringFieldUpdateOperationsInput | string
    contestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutProviderInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photo?: UserPhotoUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutProviderInput = {
    photoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutProviderInput = {
    photoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhotoUpdateWithoutUserInput = {
    url?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contestUpload?: ContestPhotoUpdateManyWithoutPhotoNestedInput
    likes?: LikeUpdateManyWithoutPhotoNestedInput
  }

  export type UserPhotoUncheckedUpdateWithoutUserInput = {
    url?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contestUpload?: ContestPhotoUncheckedUpdateManyWithoutPhotoNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type UserPhotoUncheckedUpdateManyWithoutUserInput = {
    url?: StringFieldUpdateOperationsInput | string
    states?: XOR<PhotoStatsNullableUpdateEnvelopeInput, PhotoStatsCreateInput> | null
    views?: IntFieldUpdateOperationsInput | number
    labels?: UserPhotoUpdatelabelsInput | string[]
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adult?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestParticipantUpdateWithoutUserInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    level?: EnumContestLevelFieldUpdateOperationsInput | $Enums.ContestLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contest?: ContestUpdateOneRequiredWithoutParticipantsNestedInput
    photos?: ContestPhotoUpdateManyWithoutParticipantNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUpdateManyWithoutParticipantNestedInput
  }

  export type ContestParticipantUncheckedUpdateWithoutUserInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    contestId?: StringFieldUpdateOperationsInput | string
    level?: EnumContestLevelFieldUpdateOperationsInput | $Enums.ContestLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ContestPhotoUncheckedUpdateManyWithoutParticipantNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutParticipantNestedInput
    contestAchievement?: ContestAchievementUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type ContestParticipantUncheckedUpdateManyWithoutUserInput = {
    status?: EnumContestParticipantStatusFieldUpdateOperationsInput | $Enums.ContestParticipantStatus
    contestId?: StringFieldUpdateOperationsInput | string
    level?: EnumContestLevelFieldUpdateOperationsInput | $Enums.ContestLevel
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContestPhotoCreateManyPhotoInput = {
    id?: string
    title?: string | null
    contestId: string
    participantId: string
    rank?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeCreateManyPhotoInput = {
    id?: string
    providerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhotoStatsUpdateInput = {
    Composition?: IntFieldUpdateOperationsInput | number
    Content?: IntFieldUpdateOperationsInput | number
    Creativity?: IntFieldUpdateOperationsInput | number
    Technique?: IntFieldUpdateOperationsInput | number
  }

  export type ContestPhotoUpdateWithoutPhotoInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participant?: ContestParticipantUpdateOneRequiredWithoutPhotosNestedInput
    votes?: VoteUpdateManyWithoutPhotoNestedInput
    comments?: CommentUpdateManyWithoutReceiverNestedInput
    achievements?: ContestAchievementUpdateManyWithoutPhotoNestedInput
    ContestWinner?: ContestWinnerUpdateManyWithoutPhotoNestedInput
  }

  export type ContestPhotoUncheckedUpdateWithoutPhotoInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: VoteUncheckedUpdateManyWithoutPhotoNestedInput
    comments?: CommentUncheckedUpdateManyWithoutReceiverNestedInput
    achievements?: ContestAchievementUncheckedUpdateManyWithoutPhotoNestedInput
    ContestWinner?: ContestWinnerUncheckedUpdateManyWithoutPhotoNestedInput
  }

  export type ContestPhotoUncheckedUpdateManyWithoutPhotoInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    contestId?: StringFieldUpdateOperationsInput | string
    participantId?: StringFieldUpdateOperationsInput | string
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutPhotoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: UserUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutPhotoInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutPhotoInput = {
    providerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NestedEnumRecurringTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurringType | EnumRecurringTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RecurringType[] | ListEnumRecurringTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecurringType[] | ListEnumRecurringTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRecurringTypeFilter<$PrismaModel> | $Enums.RecurringType
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}